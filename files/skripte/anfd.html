<!DOCTYPE html>
<html lang="">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>Skripte/anfd › ubuntuusers statisches Wiki</title>
<link href="../_/34e5d78db234405457773cc26741aada99f7fff2.css" rel="stylesheet" type="text/css"/>
<link href="../_/61af784fc5c93e296fec3be63b8e0bb48443727c.css" rel="stylesheet" type="text/css"/>
<link href="../_/634e8d1015b02df998cdec7cb07c5aff61d068b5.css" rel="stylesheet" type="text/css"/>
<link href="../_/b583ff7e37147497a59224ccf54cfee812a1d21b.css" rel="stylesheet" type="text/css"/>
<link href="../_/a0d5775ed6f36f8cc5b12bcf2f1c1bd98a3eb225.css" rel="stylesheet" type="text/css"/>
<link href="../_/98de73bded109a634cbd1e924abdd8c8964b8df2.css" media="print" rel="stylesheet" type="text/css"/>

<meta content="#a87300" name="theme-color"/>

</head>
<body>
<div class="wrap">
<div class="header">
<h1><a href="http://ubuntuusers.de/"><span>ubuntuusers.de</span></a></h1>
<ul class="tabbar">
<li class="portal">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://ubuntuusers.de/">Portal<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="forum">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://forum.ubuntuusers.de/">Forum<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="wiki active">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://wiki.ubuntuusers.de/">Wiki<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="ikhaya">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://ikhaya.ubuntuusers.de/">Ikhaya<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="planet">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://planet.ubuntuusers.de/">Planet<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="community">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://wiki.ubuntuusers.de/Mitmachen">Mitmachen<span></span></a></div>
<div class="tab_right"></div>
</li>
</ul>
</div>
<div class="body">
<div class="appheader">

<div class="pagetitle">
<h1 class="breadcrumb_title">
<a class="separator" href="../startseite.html">
              Wiki
            </a>
</h1>
<h2 class="breadcrumb_subtitle"><a href="../skripte/anfd.html">anfd</a></h2>
</div>
</div><div class="message staticwikinote"><strong>Hinweis:</strong> Dies ist ein statischer Snapshot unseres Wikis vom Jan. 17, 2018 und kann daher nicht bearbeitet werden. Der aktuelle Artikel ist unter <a href="http://wiki.ubuntuusers.de/Skripte/anfd">wiki.ubuntuusers.de</a> zu finden.</div>

<!--[if lt IE 8]>
      <div class="message fail">Bitte installiere den Internet Explorer 8 oder neuer.</div>
      <![endif]-->
<div class="page_content">
<div class="navi_sidebar navigation">
<div class="container">
<h3 class="navi_wiki">Wiki</h3>
<ul>
<li><a href="../wiki/index.html">Index</a></li>
<li><a href="../wiki/recentchanges.html">Letzte Änderungen</a></li>
<li><a href="../wiki/neue_artikel.html">Liste neuer Artikel</a></li>
<li><a href="../wiki.html">Übersicht</a></li>
<li><a href="../wiki/faq_-_häufig_gestellte_fragen.html">FAQ</a></li>
<li><a href="../wiki/benutzung.html">Benutzung</a></li>
<li><a href="../kategorien.html">Kategorie</a></li>
<li><a href="../wiki/tagcloud.html">Wortwolke</a></li>
</ul>
<h3 class="navi_join">Mitmachen</h3>
<ul>
<li><a href="../wikiartikel_anlegen.html">Wikiartikel anlegen</a></li>
<li><a href="../howto.html">Howto anlegen</a></li>
<li><a href="../wiki/referenz.html">Wiki-Referenz</a></li>
<li><a href="../wiki/syntax.html">Wiki-Syntax</a></li>
<li><a href="../baustelle.html">Baustellen</a></li>
<li><a href="../wiki/artikelideen.html">Artikelideen</a></li>
<li><a href="../wiki/ungetestet.html">Ungetestete Artikel</a></li>
<li><a href="../wiki/vorlagen/ausbaufähig/a/backlinks.html">Ausbaufähige Artikel</a></li>
<li><a href="../wiki/vorlagen/fehlerhaft/a/backlinks.html">Fehlerhafte Artikel</a></li>
<li><a href="https://forum.ubuntuusers.de/forum/wiki/">Rund ums Wiki</a></li>
</ul>
<h3 class="navi_config">Konfiguration</h3>
<ul>
<li><a href="../skripte/anfd/a/backlinks.html">Backlinks anzeigen</a></li>
<li>
        Exportieren
        <ul>
<li><a href="../skripte/anfd/a/export/meta.html" rel="nofollow">Metadaten</a></li>
<li><a href="../skripte/anfd/a/export/raw.html" rel="nofollow">Rohformat</a></li>
<li><a href="../skripte/anfd/a/export/html.html" rel="nofollow">HTML</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div class="content content_tabbar content_sidebar">
<h1 class="pagetitle"><a href="../skripte/anfd/a/backlinks.html">anfd</a></h1>
<div id="page"><div class="box knowledge"><h3 class="box knowledge">Zum Verständnis dieses Artikels sind folgende Seiten hilfreich:</h3><div class="contents"><p>
</p><ol class="arabic"><li><p><a class="crosslink anchor" href="#source-1" id="source-1"></a> <a class="internal" href="../pakete_installieren.html">Installation von Programmen</a> </p></li><li><p><a class="crosslink anchor" href="#source-2" id="source-2"></a> <a class="internal" href="../paketquellen_freischalten.html">Bearbeiten von Paketquellen</a> </p></li><li><p><a class="crosslink anchor" href="#source-3" id="source-3"></a> <a class="internal" href="../terminal.html">Ein Terminal öffnen</a> </p></li><li><p><a class="crosslink anchor" href="#source-4" id="source-4"></a> <a class="internal" href="../editor.html">Einen Editor öffnen</a> </p></li><li><p><a class="crosslink anchor" href="#source-5" id="source-5"></a> <a class="internal" href="../dienste.html">Dienste beim Bootvorgang starten</a> </p></li></ol></div></div><div class="toc toc-depth-2"><div class="head">Inhaltsverzeichnis</div><ol class="arabic"><li><a class="crosslink" href="#Anfd-Ain-t-No-Firewall-Daemon">Anfd - Ain't No Firewall Daemon
</a></li><li><a class="crosslink" href="#Funktionsweise">Funktionsweise
</a></li><li><a class="crosslink" href="#Installation">Installation
</a></li><li><a class="crosslink" href="#Benutzung">Benutzung
</a><ol class="arabic"><li><a class="crosslink" href="#Optionen">Optionen
</a></li><li><a class="crosslink" href="#Konfiguration">Konfiguration
</a></li></ol></li><li><a class="crosslink" href="#Beschraenkungen">Beschränkungen
</a></li><li><a class="crosslink" href="#Links">Links
</a></li></ol></div><div class="section_1"><h2 id="Anfd-Ain-t-No-Firewall-Daemon">Anfd - Ain't No Firewall Daemon<a class="headerlink" href="#Anfd-Ain-t-No-Firewall-Daemon">¶</a></h2><p>
Immer wieder werden Umsteiger von anderen Betriebssystemen bei ihren ersten Kontakten zu Ubuntu-Anwendern damit konfrontiert, dass sie bei Ubuntu keine <a class="internal" href="../personal_firewalls.html">Personal Firewalls</a> benötigen. Lassen sich die meisten von ihnen noch relativ leicht davon überzeugen, dass eine gepflegte Ubuntu-Installation nach außen hin auch ohne Paketfilter genau so wenig Angriffsfläche bietet, so kommt doch immer wieder der Wunsch auf, den Internetzugriff lokal laufender Applikationen zu kontrollieren.</p><p>Auch dieser Wunsch ist auf einem Ubuntu-System in den meisten Fällen nicht nötig - zumindest braucht man dafür keine "Personal Firewall" mit bunten Pop-Up-Fenstern, unterschiedlichen "Warnleveln" und was man sonst noch so aus der schillernden Welt der Sicherheitssoftware-Industrie kennt.</p><p>Solche Software kann einen vor ernsthafter Schadsoftware sowieso nicht ernsthaft schützen. (Siehe weiterführende Links.) In legitimer Open-Source-Software lassen sich Spywarefunktionen dagegen nicht verstecken, und sie könnten quasi sofort von den Distributoren herausgepatcht werden. Bleibt also nur noch jene Handvoll Closed-Source-Applikationen, die auch unter Linux Verwendung finden, deren Hersteller aber wenig Wert auf die Privatsphäre der Nutzer legen. Hier setzt <strong>anfd</strong> an.</p><p>Wichtig ist zu begreifen, dass <strong>anfd</strong> <strong>keine Sicherheitssoftware</strong> ist, sondern <strong>Datenschutzsoftware</strong>. Der beste Schutz gegen Trojaner und verwandte Software ist immer noch, keine Software aus unbekannter Quelle zu installieren. <strong>Anfd</strong> kümmert sich nicht um Software, die der Benutzer unbewusst installiert, sondern blockiert bestimmte, aus Benutzersicht unerwünschte Internetverbindungen jener Software, deren Primärfunktionen er gerne trotzdem nutzen will.</p><p>Dabei ist es möglich, einzelnen Applikationen selektiv den Internetzugang komplett zu verweigern, auf bestimmte Adressbereiche zu beschränken, oder nur bestimmte Bereiche (z.B. das Netz des Herstellers) zu blockieren.</p></div><div class="section_1"><h2 id="Funktionsweise">Funktionsweise<a class="headerlink" href="#Funktionsweise">¶</a></h2><p>
Da die Zuordnung bestimmter Internetverbindungen zu einzelnen Applikationen innerhalb von <a class="internal" href="../iptables.html">iptables</a> / <strong>netfilter</strong> nicht problemlos möglich ist - und die rudimentäre Unterstützung dafür im Ubuntu-Kernel deaktiviert ist - findet die Filterung mittels <strong>anfd</strong> im sog. Userspace, also außerhalb des Kernels, statt. Die Pakete werden mittels des IP_Queue-Mechanismus an den <strong>anfd</strong>-Daemon übertragen, der dann über die Legitimation der betreffenden Verbindung entscheidet. Standardmäßig erstellt <strong>anfd</strong> eine passende <strong>iptables</strong>-Regel, die auf einem System ohne (auf dem Desktop meist sowieso überflüssige) "Firewall" funktioniert.</p><div class="box experts"><h3 class="box experts">Experten-Info:</h3><div class="contents"><p>
Wer <strong>anfd</strong> parallel mit anderen Filterregeln einsetzen will, kann über die Kommandozeilenoption <code class="notranslate">-i</code> eine passendere <strong>iptables</strong>-Regel definieren, oder mit der Option <code class="notranslate">-x</code> deutlich machen, dass er sich lieber selber um die Erstellung der <em>QUEUE</em>-Regel(n) kümmern will.</p></div></div></div><div class="section_1"><h2 id="Installation">Installation<a class="headerlink" href="#Installation">¶</a></h2><p>
Folgenden Pakete müssen vor der Installation von <strong>anfd</strong> installiert werden <sup><a href="#source-1">[1]</a></sup>:</p><ul><li><p><strong>libiptables-ipv4-ipqueue-perl</strong> (<em>universe</em>, <sup><a href="#source-2">[2]</a></sup>) </p></li><li><p><strong>libnet-cidr-perl</strong> (<em>universe</em>) </p></li><li><p><strong>libnet-rawip-perl</strong> (<em>universe</em>) </p></li></ul><p>Das Skript selber kopiert man einfach an eine geeignete Stelle im Pfad, z.B. nach <strong>/usr/local/sbin</strong>.</p><p>Wenn man <strong>anfd</strong> dauerhaft verwenden will, sollte man noch ein Startskript <strong>/etc/init.d/anfd</strong> erstellen <sup><a href="#source-4">[4]</a></sup> und beim Systemstart aktivieren <sup><a href="#source-5">[5]</a></sup>.</p></div><div class="section_1"><h2 id="Benutzung">Benutzung<a class="headerlink" href="#Benutzung">¶</a></h2><p>
<strong>Anfd</strong> selber wird über Kommandozeilenoptionen und eine Konfigurationsdatei (standardmäßig <strong>/etc/anfd.conf</strong>) gesteuert: 
</p><pre class="notranslate">anfd [-D] [-i 'iptables command'] [-x] [-c configfile] [-p pidfile]
anfd -k [-p pidfile]
anfd (-h|-?)</pre><div class="section_2"><h3 id="Optionen">Optionen<a class="headerlink" href="#Optionen">¶</a></h3><p>
</p><ul><li><p><code class="notranslate">-h</code> oder <strong>-?</strong>: Hilfe. Gibt eine kurze Syntax-Beschreibung aus. </p></li><li><p><code class="notranslate">-k</code>: Stoppt einen laufenden <strong>anfd</strong>-Prozess. </p></li><li><p><code class="notranslate">-D</code>: "Debug-Modus". <strong>Anfd</strong> löst sich in diesem Fall nicht vom Terminal, sondern gibt detaillierte Angaben zu jedem geprüften Datenpaket aus. Das kann benutzt werden, um die Aktivitäten bestimmter Software zu verfolgen und die Konfiguration zu verfeinern. </p></li><li><p><code class="notranslate">-c file</code>: Alternative Konfigurationsdatei. Standard ist <strong>/etc/anfd.conf</strong> </p></li><li><p><code class="notranslate">-p file</code>: Alternative Pid-Datei. In der Pid-Datei wird die Prozess-ID des laufenden <strong>anfd</strong> hinterlegt. Das verhindert unabsichtliche Mehrfachstarts des Daemons und wird von <strong>anfd -k</strong> benutzt. Standard ist <strong>/var/run/anfd.pid</strong>. </p></li><li><p><code class="notranslate">-i command</code>: Hiermit kann man ein alternatives <strong>iptables</strong>-Kommando wählen, mit dem die Datenpakete an den <strong>anfd</strong>-Daemon geschickt werden. Den Standard erhält man mit <strong>anfd -h</strong>. </p></li><li><p><code class="notranslate">-x</code>: Der Daemon erzeugt keine <strong>iptables</strong>-Regel beim Start. Die korrekte Übergabe der Datenpakete an den <strong>anfd</strong>-Daemon wird vom Administrator anderweitig geregelt. </p></li></ul><p>
</p></div><div class="section_2"><h3 id="Konfiguration">Konfiguration<a class="headerlink" href="#Konfiguration">¶</a></h3><p>
Die Konfigurationsdatei (standardmäßig <strong>/etc/anfd.conf</strong>) ist zeilenweise aufgebaut. Leerzeilen werden ignoriert, ebenso alles zwischen dem <strong>#</strong>-Zeichen und dem Zeilenende. Ansonsten bezeichnet jede Zeile die Regel(n) für eine bestimmte Applikation. Die einzelnen Bezeichner werden mit Leerzeichen getrennt.</p><div class="section_3"><h4 id="Programmteil">Programmteil<a class="headerlink" href="#Programmteil">¶</a></h4><p>
Jede Zeile beginnt mit der Definition der Applikation, für die die Regel gelten soll. Leerzeichen sind innerhalb dieser Definition nicht erlaubt. Es gibt drei Möglichkeiten, diese anzugeben:</p><ul><li><p><strong>vollständiger Pfad</strong>: Wird ein vollständiger Pfad (beginnend mit einem <strong>/</strong>) angegeben, so gilt die Regel erwartungsgemäß genau für das bezeichnete Programm. </p></li><li><p><strong>Programmname</strong>: Der einfache Name einer ausführbaren Datei bezeichnet eine Regel, die für alle Dateien dieses Namens gilt, unabhängig von der Position im Dateisystem. </p></li><li><p><strong>^Kommandozeile</strong>: Diese Regel trifft zu, wenn eines der Kommandozeilenargumente des Programms mit der durch das Zirkumflex-Zeichen gekennzeichneten Zeichenkette übereinstimmt. Das ist vor allem sinnvoll, um Skripte in Interpretersprachen zuverlässig unterscheiden zu können. </p></li></ul><p>
</p></div><div class="section_3"><h4 id="Regelteil">Regelteil<a class="headerlink" href="#Regelteil">¶</a></h4><p>
Der Rest jeder Zeile beinhaltet beliebig viele Regeln. Folgende Formen sind erlaubt:</p><ul><li><p><strong>*</strong>: Jeglicher Internetzugriff wird dieser Applikation verweigert. </p></li><li><p><strong>IP-Adresse</strong> (z.B. 10.10.10.10): Zugriff auf eine bestimmte IP-Adresse wird verweigert. </p></li><li><p><strong>Netzwerk-Adresse</strong> (z.B. 10.0.0.0/8): Zugriff auf ein komplettes Netzwerk wird verweigert. </p></li><li><p><strong>IP-Bereich</strong> (z.B. 10.0.0.1-10.0.2.254): Zugriff auf alle IPs des angegebenen Bereichs wird verweigert. </p></li><li><p><strong>!</strong> (z.B. !10.0.0.14): Kehrt den Sinn einer der drei o.a. Regeln um, d.h. der Zugriff auf bezeichnete IP, Netzwerk oder IP-Bereich wird erlaubt. Ein Leerzeichen zwischen dem <strong>!</strong> und der IP ist nicht gestattet. </p></li></ul><p>Wenn auf ein Datenpaket sowohl eine Verbots- als auch eine Erlaubnis-Regel passt, wird die Verbindung erlaubt, unabhängig von der Reihenfolge der Regeln.</p></div></div></div><div class="section_1"><h2 id="Beschraenkungen">Beschränkungen<a class="headerlink" href="#Beschraenkungen">¶</a></h2><p>
</p><ul><li><p>Der IP_Queue-Mechanismus kennt leider nur die Möglichkeiten <em>DROP</em> und <em>ACCEPT</em>, um mit Paketen zu verfahren. Damit ge<em>drop</em>pte Verbindungen nicht bis zum Timeout hängen bleiben, erzeugt <strong>anfd</strong> selber ein passendes <em>network-unreachable</em>-Paket. Dieses wird leider vom <em>Connection Tracking</em> als <em>INVALID</em> angesehen. Man sollte also auf der <em>Loopback</em>-Schnittstelle keine Regel haben, die diese Pakete blockiert. </p></li><li><p>Wenn sich <strong>anfd</strong> außerplanmäßig beendet, wird die Aufräumroutine nicht durchgeführt und die <strong>iptables</strong>-QUEUE-Regel muss von Hand gelöscht werden. Das sollte aber eigentlich nicht vorkommen. </p></li><li><p>IP_Queue ist veraltet. Es gibt einen neueren Mechanismus namens <strong>nfnetlink_queue</strong> in aktuellen Kerneln. Dieser ist allerdings sehr neu, so gut wie gar nicht dokumentiert und es gibt noch kein passendes Perl-Modul. Deswegen erschien es sinnvoll, vorerst auf den alten Mechanismus zu setzen. </p></li></ul><p>
</p></div><div class="section_1"><h2 id="Links">Links<a class="headerlink" href="#Links">¶</a></h2><p>
</p><ul><li><p><a class="internal" href="../personal_firewalls.html">Personal Firewalls: Sinn und Unsinn dieser Programme</a> </p></li><li><p><a class="external" href="http://ulm.ccc.de/ChaosSeminar/2004/12_Personal_Firewalls" rel="nofollow">Chaosseminar: Personal Firewalls (CCC)</a> <img alt="{de}" src="../_/ffd333e1d59794eac31aea8b3e984e1b88473c33.png"/> </p></li><li><p><a class="crosslink" href="http://www.ubuntuusers.de/ikhaya/245/">Ikhaya: Test der Panda-Suite</a> </p></li></ul><p>
</p><hr/><ul><li><p><a class="interwiki interwiki-attachment" href="../skripte/anfd.html">Hier das Skript herunterladen.</a> </p><pre class="notranslate">#!/usr/bin/perl -w
#
# anfd - Ain't no firewall daemon
#
# Autoren: ostcar und otzenpunk
# Homepage: http://wiki.UbuntuUsers.de/Skripte/anfd
# Lizenz: Gnu GPL Version 2 oder höher
#
# Changelog:
#    18.11.2006: v0.1
#                initial release

use strict;

use POSIX;
use Getopt::Std;
use IPTables::IPv4::IPQueue qw(:constants);
use Net::CIDR qw(:all);
use Net::RawIP;

use constant VERSION =&gt;"0.1";

my @IP_PROTO ;
$IP_PROTO[0]='IP';       # Dummy protocol for IP
$IP_PROTO[1]='ICMP';                    # Internet Control Message Protocol
$IP_PROTO[2]='IGMP';                    # Internet Group Management Protocol
$IP_PROTO[4]='IPIP';                    # IP in IP encapsulation
$IP_PROTO[6]='TCP';                     # Transmission Control Protocol
$IP_PROTO[17]='UDP';                    # User Datagram Protocol


my %opts;
my (%allow,%forbidden);
my (%use_cmdline);
my @ipt_command = qw(/sbin/iptables -I OUTPUT -m state --state NEW -j QUEUE);
my $ipt_done;   # wichtig für cleanup
my $default_config = '/etc/anfd.conf';
my $pid_file = '/var/run/anfd.pid';

getopts('kph?Dxc:i:', \%opts);
$opts{'h'} || $opts{'?'} and usage();

$&lt; and info("You must be root to use $0.",4);
$opts{'k'} and killUs();               # We'll never come back from there

sub cleanup { #in dieser funktion kein info() verwenden, da es zu einer endlosschleife führen könnte
        print ("\tReceiving Term-Signal. Cleaning up.\n");
        if ($ipt_done) {
                $ipt_command[1] = '-D';
                print("\tResetting iptables.\n");
                system(@ipt_command) == 0
                        or print("\t\tWarning: iptables failed: $?\n");
        }
        if (-e $pid_file) {
                print("\tRemoving pid file.\n");
                unlink $pid_file or print("\t\tWarning: Can't remove pid file $pid_file.\n\n");
        }
        print("Exiting.\n");
        exit;
}
        
$SIG{INT}=$SIG{TERM}=$SIG{HUP}=\&amp;cleanup;

$pid_file = $opts{'p'} if $opts{'p'};
@ipt_command = split " ", $opts{'i'} if $opts{'i'};

(-e $pid_file) &amp;&amp; die("Pid-File already exists. Maybe another anfd running?\n");
$opts{D} ? info("Starte anfd v".VERSION,1) : print "Starte anfd v".VERSION."\n";

readConfigFile($opts{c} || $default_config) or
                info("Empty configuration file", $opts{D} ? 0 : 4);

unless ($opts{'x'}) {
        system('modprobe', 'ip_queue');
        system(@ipt_command) == 0
                or info("iptables failed: $?",4);
        $ipt_done = 1;
}

my($ipversion, $proto,$src_ip ,$dest_ip,$dest_port, $src_port,$proc,$cmdline);
my $queue = new IPTables::IPv4::IPQueue(copy_mode =&gt; IPQ_COPY_PACKET,   copy_range =&gt; 2048)
        or info(IPTables::IPv4::IPQueue-&gt;errstr,4);

# "Daemonisieren" - vom Terminal abkoppeln
# Perl-Kochbuch: (Seite 754ff)
unless ($opts{'D'}) {
        my $pid=fork;
        exit if $pid;
        info("Error: Can't fork(): $!",4)unless defined($pid);
        writePid();
        for my $handle (*STDIN, *STDOUT, *STDERR){
                open($handle, "+&lt;", "/dev/null")
                        or info("Could not redirect $handle to /dev/null: $!",4);
        }
        POSIX::setsid()
                or info("Could not start new session: $!",4);
}  else { writePid(); }

# Endlosschleife:
while(1) { 
        # Paket aus der Queue holen
        my $msg = $queue-&gt;get_message();
        if (!defined $msg) {
                next if IPTables::IPv4::IPQueue-&gt;errstr eq 'Timeout';
                info(IPTables::IPv4::IPQueue-&gt;errstr,4);
        }
        info("Packet arrived",1);
        info("parse",1);
        ($ipversion, $proto, $src_ip, $dest_ip, $src_port, $dest_port)=ripPayload($msg-&gt;payload()) if $msg-&gt;data_len();
        $proto=$IP_PROTO[$proto] || 'Unknown';

        info("IP-Version: $ipversion");
        info("Protocol: $proto");
        info("Dest-IP: $dest_ip");
        info("Dest-Port: $dest_port");
        if ($ipversion == 4) {
                if ($proto eq 'TCP' || $proto eq 'UDP') {
                        ($proc,$cmdline)=getProcName($src_port,$proto);
                        if ($proc) {
                                info ("Path: $proc");
                                info ("cmdLine: $cmdline");
                                info ("",2);
                                info ("checking rules...",1);
                                if(canPass($proc,$cmdline,$dest_ip)){
                                        info ("can pass");
                                        $queue-&gt;set_verdict($msg-&gt;packet_id, NF_ACCEPT);
                                } else {
                                        info("can not pass");
                                        sendReject($msg-&gt;payload(),$src_ip);
                                        $queue-&gt;set_verdict($msg-&gt;packet_id, NF_DROP);
                                }
                                info("",2);
                                info("Done",2);
                                next;
                        } else {        # no process id
                                info("can not spy out the name",3);
                        }
                } else {        # no tcp/udp
                        info("$proto not supported with anfd v".VERSION,3);
                }
        } else {        # IPv6 et al.
                info("IPv$ipversion not supported with anfd v".VERSION,3);
        }
        info("",3);     # accept evt. unknown so wont break anything
        $queue-&gt;set_verdict($msg-&gt;packet_id, NF_ACCEPT);
}

#function zu einladen der conf datei
sub readConfigFile {                    # readconfigfile($configfile)
        my $file = shift;
        my $inuse;
        info("Load config file",1);
        open(CF,"$file") 
                or info("Warning: can not open $file",4);
        while(&lt;CF&gt;){
                my($proc, @ip, @allow, @forbidden);
                next if /^\s*(?:$|#)/;          # Bei leerer Zeile gar nicht erst weiter umwandeln
                s/\s*#.*//;                                                             # Löscht von # bis Zeilenende
                ($proc, @ip)=split();                   #alle wörter der Zeile durch whitespaces trennen

                info("Config error: $_", 4) if !defined($ip[0]); # fehler, wenn nicht beide argumente vorhanden sind

                $proc =~ s/^\^// &amp;&amp; ( $use_cmdline{$proc} = 1 ); # bei ^ am anfang cmdline benutzen
                for (@ip) {
                        my @ipranges; my @h;
                        if (s/^!//) {
                                info("$proc can pass to $_");
                                @ipranges = ((@h = validIPs($_)) ? range2cidr(@h) : ()) or info("Config error: $_", 4);
                                push @allow, @ipranges;
                        } elsif (/^\*$/) {
                                info("$proc can not pass by default");
                                push @forbidden, '0.0.0.0/0';
                                $inuse=1;
                        } else {
                                info("$proc can not pass to $_");
                                @ipranges = ((@h = validIPs($_)) ? range2cidr(@h) : ()) or info("Config error: $_", 4);
                                push @forbidden, @ipranges;
                                $inuse=1;
                        }
                }
                $forbidden{$proc}=\@forbidden;
                $allow{$proc}=\@allow;
        }
        info("Done",2);
        return $inuse;
}

sub validIPs {
        for (@_) {
                next if cidrvalidate($_);
                if ( /^([0-9.]+)\/([0-9]+)$/ ) {
                        next if cidrvalidate($1) &amp;&amp; $2 &lt;= 32;
                }
                if ( /^([0-9.]+)-([0-9.]+)$/ ) {
                        next if cidrvalidate($1) &amp;&amp; cidrvalidate($2);
                }
                return 0;  # wenn es in kein Schema passt, ist es falsch
        }
        return (@_);   # wenn wir hier ankommen, ist alles in Ordnung
}

#function zum Regel abgleichen
sub canPass{                            # $bool = can_pass($programmname, $cmdline, $ipadresse)
                                                                                # return 1: kann passieren
                                                                                # return 0: blockieren
        my $proc=shift;
        my $cmdline=shift;
        my $ip=shift;
        
        my(@forbidden,@allow,@cmd);
        #alle argumente überprüfen, und auch des program ohne pfad
        @cmd=split('\0',$cmdline);
        for (@cmd){
                if(defined($use_cmdline{$_})||defined($forbidden{$_})||defined($allow{$_})){
                        @forbidden=@{$forbidden{$_}};
                        @allow=@{$allow{$_}};
                }
        }
        
        @forbidden=@{$forbidden{$proc}} if(defined($forbidden{$proc}));
        @allow=@{$allow{$proc}} if(defined($allow{$proc}));

        # Regel: Verbieten, wenn in @forbidden, aber nicht in @allow
        if(@forbidden &amp;&amp; cidrlookup($ip,@forbidden)){
                if(@allow &amp;&amp; cidrlookup($ip,@allow)){
                        return 1;
                }else{
                        return 0;
                }
        }else{
                return 1;
        }
}

#nimmt einen quellport und gibt die inode zurück bzw 0 für fehler
sub srcPort2inode{                      # $inode = quellporttoinode($quellport,$protocol)
                                                                                                # Fehler: return 0;
        my $src_port=shift;
        my $protocol=lc(shift);
        open(FILE, "/proc/net/$protocol") 
                or return 0;
        while(&lt;FILE&gt;) {
                my @cline=split;
                next if ($cline[9]=~/uid/);
                my $port = hex((split(":",$cline[1]))[1]);
                if($port==$src_port){
                        close(FILE);
                        return $cline[9];
                }
        }
        close(FILE);
        return 0;
}

#nimmt eine inode und gibt eine prog nr zurück
sub inode2procNr{                               # $procnr = inodetoprocnr($inode);
                                                                                                        # bei Fehler: return 0;
        my $inode=shift;
        return 0 unless $inode;
        my($proc,$ports,$dev,$ino,$link);
        opendir (PROC, "/proc") 
                or return 0;
        for $proc (readdir(PROC)) {              # Infos zu jedem laufenden Programm liefert /proc
                                                 # Wir müssen alle testen, bis eins passt.
                next if(!($proc=~/[0-9]+/) );          # Nach PIDs suchen.
                if(!opendir(PORTS,"/proc/$proc/fd")) { # fd-Ordner öffnen
                        closedir PORTS;
                        next;                                # nächstes Programm, wenn Öffnen fehlschlägt
                }
                for $ports (readdir(PORTS)) { #in jedem laufenden program die geöffneten dateien durchsuchen
                        next if(!($ports=~/[0-9]+/)); #muss zahlen beinhalten
                        $link=readlink("/proc/$proc/fd/$ports"); #zu der datei gehn, auf welches die nummer zeigt
                        ($dev,$ino)=($link=~/^(socket|\[[0-9a-fA-F]*\]):\[?([0-9]*)\]?$/);
                        if(defined($ino)&amp;&amp; defined($dev) &amp;&amp; $ino==$inode &amp;&amp; ($dev eq "[0000]" || $dev eq "socket")){
                                closedir PORTS;
                                closedir PROC;
                                return $proc;
                        }
                }
                closedir PORTS;
        }
        closedir PROC;
        return 0;
}

#nimmt einen srcPort und gibt den programnamen und die cmdline aus
sub getProcName{                                                                        # ($pfad, $cmdline) = getprocname($quellport,$protocol);
                                                                                                                                        # Fehler: return 0;
        my $procnr=inode2procNr(srcPort2inode(@_));
        
        return 0 unless $procnr;
        my($pfad,$cmdline,@cmdline);
        $pfad=readlink("/proc/$procnr/exe");
        open(CMDLINE,"/proc/$procnr/cmdline") or return 0;
        $cmdline=&lt;CMDLINE&gt;;
        @cmdline=split(" ",$cmdline);
        $cmdline[0]=~s/^\/.*\///;
        $cmdline=join(" ",@cmdline);
        close(CMDLINE);
        return $pfad, $cmdline;
}

# Nimmt ein TCP/IP-Packet und liefert IP-Version (norm. 4), Protokoll (TCP/UDP als Nummer) IPs und Ports zurück
sub ripPayload {
   my $payload = shift;

   my ($version, $proto, $src_ip, $dest_ip, $src_port, $dest_port);
   my (@src_ip, @dest_ip);
                                         # IP-Header auseinanderpflücken:
        ($version, undef, $proto, undef, @src_ip[0..3], @dest_ip[0..3], $src_port, $dest_port) =
     unpack("C1a8C1a2C8n1n1", $payload);

        $version &gt;&gt;= 4;                             # IPv steht in linken vier Bits
   $src_ip = join ".", @src_ip;
   $dest_ip = join ".", @dest_ip;

   return ($version, $proto, $src_ip, $dest_ip, $src_port, $dest_port);
}

# IP_QUEUE kennt nur ACCEPT und DROP. Deswegen konstruieren wir unser eigenes Reject-Paket
sub sendReject {
        my $payload = unpack("a28", shift);   # Anfang des Originalpakets wird in ICMP verpackt
        my $ip = shift;
        Net::RawIP-&gt;new({ip =&gt; {saddr =&gt; $ip, daddr =&gt; $ip},
                                                                        icmp =&gt; {type =&gt; 3, code =&gt; 0, data =&gt; $payload}
                                                                        })-&gt;send();                             # network unreachable
}
INIT {
        my $ebene = 0;
        sub info {
                my $info = shift;
                my $command = shift || 0;
                unless ($opts{D}) {
                        if ($command == 4) {
                                print "$info\n";
                                cleanup();
                        }
                        return;
                }
                if ($command==1){ #neue ebene
                        print "\t" x $ebene.$info.": \n";
                        $ebene++;
                }elsif ($command==2){ #ebene runter
                        $ebene--;
                        print "\t" x $ebene  .$info."\n" if $info;
                }elsif($command==3){ #ebene runter mit fehler
                        $ebene--;
                        print "\t" x $ebene."Error".($info?": $info":"")."\n";
                }elsif($command==4){ #alle ebenen runter mit fehler und ende
                        $ebene--;
                        for(;$ebene&gt;0;$ebene--){
                                print "\t" x $ebene."Critical Error".($info?": $info":"")."\n";
                        }
                        cleanup();
                }else{
                        print "\t" x $ebene.$info."\n"
                }
        }
}

sub usage {
        my $ipt = join " ", @ipt_command;
        print &lt;&lt;EOT;
$0 - Ain't no firewall daemon.

anfd [-D] [-i 'iptables command'] [-x] [-c configfile] [-p pidfile]
anfd -k [-p pidfile]
anfd (-h|-?)

Anfd is a userspace daemon that uses the netfilter-ip_queue mechanism to hinder
specific software from "phoning home". It is not security software but privacy
software.

Options:
        -h, -?      : Print this help message.
        -D          : Debug mode - don't detach from terminal and print detailed infos
        -i 'command': Use this iptables command to insert the QUEUE rule.
                      Default: $ipt
        -x          : Dont insert any iptables rule. Admin will take care of that
                      herself.
        -c file     : Use this config file. Default: $default_config
        -p pidfile  : Use this pid file. Default: $pid_file
        -k          : Kill running anfd process.
EOT
        exit 1;
}

sub killUs {
        open PID, "&lt; $pid_file"
                or die("Can't open pid file. Either there is no running anfd process or you'll have to kill running anfd processes yourself.\n");
        my $pid = &lt;PID&gt;; close PID;
        ($pid) = split '\D+', $pid;
        $pid or die("No pid found in $pid_file. You'll have to kill running anfd processes yourself.\n");
        unless (kill 'TERM', $pid) {
                print("No process $pid.  You'll have to kill running anfd processes yourself.\n");
                unlink $pid_file or print "Can't delete $pid_file.\n";
        }
        print("Killed anfd.\n");
        exit;
}

sub writePid {
        if (-e $pid_file) {
                info("There seems to be another anfd process running. Use anfd -k to get rid of it.",4);
        } else {
                open PID, "&gt; $pid_file" or info("Can not write pid file.\n",4);
                print PID $$; close PID;
        }
}</pre></li></ul><p><a class="interwiki interwiki-attachment" href="../skripte/anfd.html">inline:anfd</a></p><p></p></div></div>
<p class="meta">
<a href="../skripte/anfd/a/revision/769673.html">Diese Revision</a> wurde am 1. Dezember 2014 18:46 von <a href="https://ubuntuusers.de/user/rsadmin/">rsadmin</a> erstellt.
    
  </p>
</div>
</div>
<div style="clear: both;"></div>
<div class="pathbar breadcrumb">
<div class="breadcrumb">
<ol>
<li><a href="../startseite.html">Wiki</a></li>
<li><a href="../skripte.html">Skripte</a></li>
<li><a href="../skripte/anfd.html">anfd</a></li>
</ol>
</div>
</div>
</div>
<div class="footer" style="clear: both;">
<ul>
<li class="poweredby"><li class="poweredby">Erstellt mit <a href="http://inyokaproject.org/">Inyoka</a></li></li>
<li class="license">

<img alt="Copyleft" src="../_/65dad5b770326dbbe1bd26ee6363e366a76bd8b7.png"/>
          2004 – 2017 ubuntuusers.de • Einige Rechte vorbehalten<br/>
<a href="../_lizenz.html" rel="cc:morePermissions">Lizenz</a> •
          <a href="http://ubuntuusers.de/kontakt/">Kontakt</a> •
          <a href="http://ubuntuusers.de/datenschutz/">Datenschutz</a> •
          <a href="http://ubuntuusers.de/impressum/">Impressum</a> •
          <a href="https://ubuntuusers.statuspage.io">Serverstatus</a>
</li>
<li class="housing">
<span title="Unterbringung und Netzanbindung eines Servers">Serverhousing</span> gespendet von<br/>
<img alt="noris network" src="../_/e7d27e9081eec23a8a5a5fe9434d7b2f1532e1d9.png"/>
<img alt="anexia" src="../_/ad1b63a3fc35749344af0a03e8c3ce05a2a3ee7e.png"/>
</li>
</ul>
</div>
<div style="clear: both;"></div>
</div>






</body>
</html>