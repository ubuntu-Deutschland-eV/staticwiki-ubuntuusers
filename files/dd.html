<!DOCTYPE html>
<html lang="">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>dd › ubuntuusers statisches Wiki</title>
<link href="./_/34e5d78db234405457773cc26741aada99f7fff2.css" rel="stylesheet" type="text/css"/>
<link href="./_/61af784fc5c93e296fec3be63b8e0bb48443727c.css" rel="stylesheet" type="text/css"/>
<link href="./_/634e8d1015b02df998cdec7cb07c5aff61d068b5.css" rel="stylesheet" type="text/css"/>
<link href="./_/b583ff7e37147497a59224ccf54cfee812a1d21b.css" rel="stylesheet" type="text/css"/>
<link href="./_/a0d5775ed6f36f8cc5b12bcf2f1c1bd98a3eb225.css" rel="stylesheet" type="text/css"/>
<link href="./_/98de73bded109a634cbd1e924abdd8c8964b8df2.css" media="print" rel="stylesheet" type="text/css"/>

<meta content="#a87300" name="theme-color"/>

</head>
<body>
<div class="wrap">
<div class="header">
<h1><a href="http://ubuntuusers.de/"><span>ubuntuusers.de</span></a></h1>
<ul class="tabbar">
<li class="portal">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://ubuntuusers.de/">Portal<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="forum">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://forum.ubuntuusers.de/">Forum<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="wiki active">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://wiki.ubuntuusers.de/">Wiki<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="ikhaya">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://ikhaya.ubuntuusers.de/">Ikhaya<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="planet">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://planet.ubuntuusers.de/">Planet<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="community">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://wiki.ubuntuusers.de/Mitmachen">Mitmachen<span></span></a></div>
<div class="tab_right"></div>
</li>
</ul>
</div>
<div class="body">
<div class="appheader">

<div class="pagetitle">
<h1 class="breadcrumb_title">
<a class="separator" href="./startseite.html">
              Wiki
            </a>
</h1>
<h2 class="breadcrumb_subtitle"><a href="./dd.html">dd</a></h2>
</div>
</div><div class="message staticwikinote"><strong>Hinweis:</strong> Dies ist ein statischer Snapshot unseres Wikis vom Jan. 17, 2018 und kann daher nicht bearbeitet werden. Der aktuelle Artikel ist unter <a href="http://wiki.ubuntuusers.de/dd">wiki.ubuntuusers.de</a> zu finden.</div>

<!--[if lt IE 8]>
      <div class="message fail">Bitte installiere den Internet Explorer 8 oder neuer.</div>
      <![endif]-->
<div class="page_content">
<div class="navi_sidebar navigation">
<div class="container">
<h3 class="navi_wiki">Wiki</h3>
<ul>
<li><a href="./wiki/index.html">Index</a></li>
<li><a href="./wiki/recentchanges.html">Letzte Änderungen</a></li>
<li><a href="./wiki/neue_artikel.html">Liste neuer Artikel</a></li>
<li><a href="./wiki.html">Übersicht</a></li>
<li><a href="./wiki/faq_-_häufig_gestellte_fragen.html">FAQ</a></li>
<li><a href="./wiki/benutzung.html">Benutzung</a></li>
<li><a href="./kategorien.html">Kategorie</a></li>
<li><a href="./wiki/tagcloud.html">Wortwolke</a></li>
</ul>
<h3 class="navi_join">Mitmachen</h3>
<ul>
<li><a href="./wikiartikel_anlegen.html">Wikiartikel anlegen</a></li>
<li><a href="./howto.html">Howto anlegen</a></li>
<li><a href="./wiki/referenz.html">Wiki-Referenz</a></li>
<li><a href="./wiki/syntax.html">Wiki-Syntax</a></li>
<li><a href="./baustelle.html">Baustellen</a></li>
<li><a href="./wiki/artikelideen.html">Artikelideen</a></li>
<li><a href="./wiki/ungetestet.html">Ungetestete Artikel</a></li>
<li><a href="./wiki/vorlagen/ausbaufähig/a/backlinks.html">Ausbaufähige Artikel</a></li>
<li><a href="./wiki/vorlagen/fehlerhaft/a/backlinks.html">Fehlerhafte Artikel</a></li>
<li><a href="https://forum.ubuntuusers.de/forum/wiki/">Rund ums Wiki</a></li>
</ul>
<h3 class="navi_config">Konfiguration</h3>
<ul>
<li><a href="./dd/a/backlinks.html">Backlinks anzeigen</a></li>
<li>
        Exportieren
        <ul>
<li><a href="./dd/a/export/meta.html" rel="nofollow">Metadaten</a></li>
<li><a href="./dd/a/export/raw.html" rel="nofollow">Rohformat</a></li>
<li><a href="./dd/a/export/html.html" rel="nofollow">HTML</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div class="content content_tabbar content_sidebar">
<h1 class="pagetitle"><a href="./dd/a/backlinks.html">dd</a></h1>
<div id="page"><p>
</p><div class="box tested_for"><h3 class="box tested_for">Dieser Artikel wurde für die folgenden
Ubuntu-Versionen getestet:</h3><div class="contents"><p> 
Dieser Artikel ist größtenteils für alle Ubuntu-Versionen gültig.
</p></div></div><p>
</p><div class="box advanced"><h3 class="box advanced">Artikel für fortgeschrittene Anwender</h3><div class="contents"><p>
Dieser Artikel erfordert mehr Erfahrung im Umgang mit
Linux und ist daher nur für fortgeschrittene Benutzer
gedacht.
</p></div></div><div class="box knowledge"><h3 class="box knowledge">Zum Verständnis dieses Artikels sind folgende Seiten hilfreich:</h3><div class="contents"><p>
</p><ol class="arabic"><li><p><a class="crosslink anchor" href="#source-1" id="source-1"></a> <a class="internal" href="./terminal.html">Ein Terminal öffnen</a></p></li><li><p><a class="crosslink anchor" href="#source-2" id="source-2"></a> <a class="internal" href="./pakete_installieren.html">Installation von Programmen</a></p></li><li><p><a class="crosslink anchor" href="#source-3" id="source-3"></a> <a class="internal" href="./paketquellen_freischalten.html">Bearbeiten von Paketquellen</a></p></li></ol></div></div><p>
</p><div class="toc toc-depth-1"><div class="head">Inhaltsverzeichnis</div><ol class="arabic"><li><a class="crosslink" href="#Installation">Installation
</a></li><li><a class="crosslink" href="#Aufruf">Aufruf
</a></li><li><a class="crosslink" href="#Optionen">Optionen
</a></li><li><a class="crosslink" href="#Anwendungen">Anwendungen
</a></li><li><a class="crosslink" href="#Links">Links
</a></li></ol></div><p><img alt="Wiki/Icons/terminal.png" class="image-left" src="./_/e81889fd6e485dd32e1cde611eabc18abced7993.png"/>
<strong>dd</strong> dient zum bit-genauen Kopieren von Festplatten, Partitionen oder Dateien. "Bit-genaues" Kopieren bedeutet, dass der Datenträger Bit-für-Bit bzw. Byte-für-Byte ausgelesen und beschrieben wird, unabhängig von dessen Inhalt und Belegung. <code class="notranslate">dd</code> funktioniert grundsätzlich mit allen Dateisystemen auf die Ubuntu / Linux zugreifen kann (z.B. ext2/3, reiserfs, vfat, ntfs etc.). Es funktioniert auch mit CD/DVD-Dateisystemen, allerdings nur für Daten-CDs/DVDs.</p><p>Dieser Artikel beschreibt die Kommandozeilenversion. Wer lieber mit einer grafischen Benutzeroberfläche arbeitet, kann <a class="interwiki interwiki-launchpad" href="https://launchpad.net/gdiskdump">gdiskdump</a> <img alt="{en}" src="./_/d5ecf89114b079f85d02099649c4ee617ffa34c7.png"/> nutzen.</p><div class="box warning"><h3 class="box warning">Achtung!</h3><div class="contents"><p>
</p><ul><li><p><code class="notranslate">dd</code> wird ohne weitere Rückfragen bzw. Sicherheitsabfragen ausgeführt. Bei unachtsamen Aufrufen könnten evtl. vorhandene Daten überschrieben werden! </p></li><li><p>Bevor man eine Partition oder komplette Platte sichert sollte diese <a class="internal" href="./datenträger.html">ausgehängt werden</a>, um sicherzustellen, dass während des Sicherungsvorgangs keine Daten auf die zu sicherende Platte geschrieben werden. </p></li><li><p>Zur Übernahme eines bestehenden Systems auf eine <a class="interwiki interwiki-wikipedia" href="https://de.wikipedia.org/wiki/Solid-State-Drive">SSD</a> (Solid-State-Drive) sollte <code class="notranslate">dd</code> nur mit äußerster Vorsicht genutzt werden. In den Standardeinstellungen verwendet <code class="notranslate">dd</code> eine Blockgröße von 512 Bytes, was bei modernen <a class="interwiki interwiki-wikipedia" href="https://de.wikipedia.org/wiki/Solid-State-Drive">SSD</a> zu unnötigen Schreibprozessen führt. Verwendet man unter Benutzung des Parameters <code class="notranslate">bs=</code> eine Blockgrößenangabe die der Blockgröße oder einem Vielfachen davon der <a class="interwiki interwiki-wikipedia" href="https://de.wikipedia.org/wiki/Solid-State-Drive">SSD</a> entspricht, besteht diese Gefahr nicht. Des Weiteren sollte man beachten, dass das <a class="interwiki interwiki-wikipedia" href="https://de.wikipedia.org/wiki/Solid-State-Drive#Ausrichtung">Alignment</a> eingehalten wird, was ohne weitere Parameter höchstwahrscheinlich nicht der Fall ist.</p></li></ul></div></div><div class="section_1"><h2 id="Installation">Installation<a class="headerlink" href="#Installation">¶</a></h2><p>
Das Programm befindet sich im Paket</p><ul><li><p><strong>coreutils</strong></p></li></ul><p>
und ist in jeder Ubuntu-Installation bereits enthalten.</p></div><div class="section_1"><h2 id="Aufruf">Aufruf<a class="headerlink" href="#Aufruf">¶</a></h2><p>
Syntaxaufruf für die Verwendung in der Shell <sup><a href="#source-1">[1]</a></sup>:</p><div class="bash"><div class="contents"><pre class="notranslate">dd if=Quelle of=Ziel &lt;Optionen&gt; </pre></div></div><p>
</p><table><tr><td><code class="notranslate">if</code></td><td> Steht für "Input File", kann ein komplettes Gerät (z.B. <strong>/dev/sda</strong>), eine Partition oder eine Datei sein. </td></tr><tr><td><code class="notranslate">of</code></td><td> Steht für "Output File", kann ein komplettes Gerät (z.B. <strong>/dev/sdb</strong>), eine Partition oder eine Datei sein. </td></tr></table><p>
<code class="notranslate">dd</code> kann ohne <a class="internal" href="./sudo.html">Root-Rechte</a> aufgerufen werden. Man benötigt nur dann Root-Rechte, wenn von einem Gerät bzw. einer Partition gelesen bzw. darauf geschrieben werden soll, auf die nur Root Zugriff hat. Beim Lesen von CD/DVDs muss dd grundsätzlich mit Root-Rechten aufgerufen werden.</p><div class="box notice"><h3 class="box notice">Hinweis:</h3><div class="contents"><p>
</p><ul><li><p>Wird <code class="notranslate">if</code> bzw. <code class="notranslate">of</code> weggelassen, so liest dd von der Standardeingabe bzw. schreibt auf die Standardausgabe. Dies ist dann nützlich, wenn dd in Kombination mit dem Pipe-Operator genutzt wird. </p></li><li><p>dd kann zwar grundsätzlich auch Dateien kopieren, allerdings ist hier in der Regel der Befehl <a class="internal" href="./cp.html">cp</a> komfortabler. </p></li></ul></div></div></div><div class="section_1"><h2 id="Optionen">Optionen<a class="headerlink" href="#Optionen">¶</a></h2><p>
Der Befehl <code class="notranslate">dd</code> kennt u.a. die folgenden Optionen:</p><table style="width: 95%"><tr><td colspan="2" style="background-color: #E2C890; text-align: center"> <strong>dd - Optionen</strong> </td></tr><tr><td><strong>Option</strong></td><td><strong>Beschreibung</strong></td></tr><tr><td><code class="notranslate">obs=BYTES</code></td><td> Es wird in Blöcken mit der Größe BYTES geschrieben. </td></tr><tr><td><code class="notranslate">ibs=BYTES</code></td><td> Es werden Blöcke der Größe BYTES gelesen.  </td></tr><tr><td><code class="notranslate">bs=BYTES</code></td><td> Es werden Blöcke mit der Größe BYTES gelesen und geschrieben. Wird bs als Option benutzt, so ist <code class="notranslate">ibs</code> = <code class="notranslate">obs</code> = <code class="notranslate">bs</code>. </td></tr><tr><td><code class="notranslate">count=BLOCKS</code></td><td> BLOCKS gibt an, wie viele Blöcke mit der durch bs / obs / ids festgelegten Größe gelesen und / oder geschrieben werden. </td></tr><tr><td><code class="notranslate">seek=BLOCKS</code></td><td> BLOCKS gibt an, wie viele Blöcke der mit <code class="notranslate">obs</code> oder <code class="notranslate">bs</code> festgelegten Größe zu Beginn des Schreibvorgangs übersprungen werden. </td></tr><tr><td><code class="notranslate">skip=BLOCKS</code></td><td> BLOCKS gibt an, wie viele Blöcke der mit <code class="notranslate">ibs</code> oder <code class="notranslate">bs</code> festgelegten Größe zu Beginn des Lesevorgangs übersprungen werden sollen. </td></tr><tr><td><code class="notranslate">status=noxfer</code></td><td> Unterdrückt die Ausgabe von Statusinformationen während des Kopiervorgangs. Durch <code class="notranslate">kill -SIGUSR1 &lt;dd-prozess-id&gt;</code> wird der laufende dd manuell dazu veranlasst, Statusinformationen auszugeben. </td></tr></table><p>
Für die Angaben <code class="notranslate">BYTES</code> und <code class="notranslate">BLOCKS</code> gilt:</p><ul><li><p><code class="notranslate">BYTES</code> muss ganzzahlig sein. Ohne weiteres Suffix wird die Größe der Zahl <code class="notranslate">BYTES</code> in Byte interpretiert. </p></li><li><p><code class="notranslate">BLOCKS</code> muss ganzzahlig sein. </p></li></ul><p>
Des Weiteren kennt <code class="notranslate">dd</code> noch verschiedene andere Optionen, insbesondere zum Konvertieren der Daten zwischen Einlesen und Ausgabe. Diese werden bei "normaler" Benutzung eher selten gebraucht, können aber in den <a class="internal" href="./man.html">Manpages</a> von <code class="notranslate">dd</code> nachgelesen werden.</p><div class="box notice"><h3 class="box notice">Hinweis:</h3><div class="contents"><p>Wenn man keine Blockgröße angibt, verwendet <code class="notranslate">dd</code> eine kleine Standardgröße, was den Datentransfer durch den Overhead sehr langsam macht. Insofern ist es empfehlenswert, z.B. <code class="notranslate">bs=1M</code> anzugeben.
</p></div></div><div class="section_2"><h3 id="Suffixe-fuer-BYTES">Suffixe für BYTES<a class="headerlink" href="#Suffixe-fuer-BYTES">¶</a></h3><p>
Wie oben bereits erwähnt wird die Größe der Zahl BYTES standardmäßig in Byte interpretiert. Diese kann durch Hinzufügen von Suffixes geändert werden.</p><table style="width: 95%"><tr><td colspan="2" style="background-color: #E2C890; text-align: center"> <strong>Suffixe für BYTES</strong> </td></tr><tr><td><strong>Suffix</strong></td><td><strong>Multiplikator</strong></td></tr><tr><td><code class="notranslate">KB</code></td><td>1000 (d.h. 1KB entspricht 1000 Byte)</td></tr><tr><td><code class="notranslate">K</code></td><td>1024 (d.h. 1K entspricht 1024 Byte)</td></tr><tr><td><code class="notranslate">MB</code></td><td>1000000 (= 1000 * 1000, d.h. 1MB entspricht 1000000 Byte)</td></tr><tr><td><code class="notranslate">M</code></td><td>1048576 (= 1024 * 1024, d.h. 1M entspricht 1048576 Byte)</td></tr><tr><td><code class="notranslate">GB</code></td><td>1000000000 (= 1000 * 1000 * 1000, d.h. 1GB entspricht 1000000000 Byte)</td></tr><tr><td><code class="notranslate">G</code></td><td>1073741824 (= 1024 * 1024 * 1024, d,h, 1G entspricht 1073741824 Byte)</td></tr></table><p>
Gemäß dem in der Tabelle aufgezeigten Schema gibt es auch die Suffixe TB, T, PB, P, EB, E, ZB, Z, YB, Y - für alle, die wirklich große Datenmengen kopieren müssen.</p><p>Die gleichen Suffixe gelten auch für BLOCKS, d.h. z.B. mit <strong>count=1K</strong> werden 1024 Blöcke gelesen/geschrieben, mit <strong>count=1MB</strong> 1000000 Blöcke, usw.</p></div></div><div class="section_1"><h2 id="Anwendungen">Anwendungen<a class="headerlink" href="#Anwendungen">¶</a></h2><p>
</p><div class="box warning"><h3 class="box warning">Achtung!</h3><div class="contents"><p>Da sich die Geräte-Bezeichnungen wie <strong>/dev/sda</strong> nach jedem Bootvorgang ändern können, sind vor der Verwendung von dd stets die aktuellen Gerätedateien zu überprüfen. Dies kann man zum Beispiel mit <a class="internal" href="./blkid.html">blkid</a> machen.
</p></div></div><div class="section_2"><h3 id="Einige-allgemeine-Beispiele">Einige allgemeine Beispiele<a class="headerlink" href="#Einige-allgemeine-Beispiele">¶</a></h3><p>
Im Folgenden ein paar allgemeine Beispiele für die Syntax und die Optionen von dd:</p><ul><li><p>Es wird die komplette fünfte Partition von <strong>/dev/sda</strong> in die erste Partition von <strong>/dev/sdb</strong> kopiert: </p><div class="bash"><div class="contents"><pre class="notranslate">dd if=/dev/sda5 of=/dev/sdb1 </pre></div></div></li><li><p>Es werden die ersten zehn 1024 Byte großen Blöcke von der erste Partition von <strong>/dev/sdb</strong> auf die zweite Partition von <strong>/dev/sdc</strong> kopiert: </p><div class="bash"><div class="contents"><pre class="notranslate">dd if=/dev/sdb1 of=/dev/sdc2 bs=1K count=10  </pre></div></div></li><li><p>Es werden 2000 Byte große Blöcke von der dritten Partition von <strong>/dev/sda</strong> auf die vierte Partition von <strong>/dev/sda</strong> kopiert, wobei beim Einlesen die ersten 50 Blöcke (in diesen Fall 50 * 2000 = 100.000 Byte) übersprungen werden, d.h. der Lesevorgang fängt bei Byte 100.001 an: </p><div class="bash"><div class="contents"><pre class="notranslate">dd if=/dev/sda3 of=/dev/sda4 ibs=2KB obs=2KB skip=50 </pre></div></div></li></ul><p>
</p></div><div class="section_2"><h3 id="Festplatte-klonen">Festplatte klonen<a class="headerlink" href="#Festplatte-klonen">¶</a></h3><p>
Der folgende Befehl klont (kopiert) die komplette Festplatte <strong>/dev/sda</strong> inklusive aller Partitionen, MBR und Partitionstabelle auf die eine zweite Festplatte <strong>/dev/sdb</strong>:</p><div class="bash"><div class="contents"><pre class="notranslate">dd if=/dev/sda of=/dev/sdb </pre></div></div><div class="box warning"><h3 class="box warning">Achtung!</h3><div class="contents"><p>Es sollte darauf geachtet werden, dass die beiden Festplatten gleich groß sind - oder zumindest das Ziel größer. Auch die Sektorengröße (512 Bytes oder Advanced Format mit 4096 Bytes) muss bei Beiden identisch sein.</p><p>Falls man plant beide Platten gleichzeitig im selben PC zu betreiben, ist darauf zu achten, dass die <a class="internal" href="./uuid.html">UUIDs</a> der geklonten Platte geändert werden, da es sonst zu Konflikten kommt. 
</p></div></div><p>Eine <strong>miserable Transfergeschwindigkeit</strong> bei großen Festplatten sollte hier mit "bs" zb "bs=1M" vermieden werden, solange die Festplatte keine defekten Blöcke hat. Standardmäßig wird mit 512 Bytes gelesen, bei defekten Blöcken wäre ein "bs=4K" zu empfehlen.</p><p>Komprimiert man ein solches Festplattenimage, wie im folgenden Absatz beschrieben, noch zusätzlich mit gzip, so sollte man vorher die Ausgabe von <code class="notranslate">fdisk -l</code> speichern und mit der gesicherten Imagedatei zusammen aufheben. Alternativ kann man die Startpositionen der Partitionen auch – sehr zeitaufwändig – <a class="crosslink topic" href="https://forum.ubuntuusers.de/topic/partitionen-aus-ge-gziptem-dd-image-auslesen-o/">aus dem gepackten Image auslesen</a>.</p></div><div class="section_2"><h3 id="Festplatte-sicher-loeschen">Festplatte (sicher) löschen<a class="headerlink" href="#Festplatte-sicher-loeschen">¶</a></h3><p>
</p><div class="box warning"><h3 class="box warning">Achtung!</h3><div class="contents"><p>Alle Daten auf der Festplatte werden unwiderruflich gelöscht!
</p></div></div><p>
Der folgende Befehl löscht die komplette Festplatte <strong>/dev/sdX</strong> durch Überschreiben mit Nullen:</p><div class="bash"><div class="contents"><pre class="notranslate">dd if=/dev/zero of=/dev/sdX </pre></div></div><p>
Der folgende Befehl löscht die komplette Festplatte <strong>/dev/sdX</strong> durch Überschreiben mit Zufallszahlen (zeitintensiv):</p><div class="bash"><div class="contents"><pre class="notranslate">dd if=/dev/urandom of=/dev/sdX </pre></div></div><div class="box experts"><h3 class="box experts">Experten-Info:</h3><div class="contents"><p>Der Löschprozess kann maßgeblich beschleunigt werden, wenn man den Buffer (internen Zwischenspeicher) der Festplatte ausnutzt. Wie groß dieser für die aktuelle Platte ist, kann mit <code class="notranslate">hdparm -I /dev/sdX</code> herausgefunden werden. Hier ist es der Wert <code class="notranslate">BufferSize=</code>, welcher exakt so (ohne kB) für den <code class="notranslate">dd</code> Parameter <code class="notranslate">bs</code> übernommen werden kann. Zudem kann der Löschprozess in den Hintergrund gelegt werden, um während der Durchführung des Löschvorgangs eine Fortschrittsanzeige auszugeben:</p><p>Für die erste Festplatte <code class="notranslate">/dev/sdX</code> mit 8 MiB Puffergröße sieht dass dann so aus:
</p><div class="bash"><div class="contents"><pre class="notranslate">dd if=/dev/zero of=/dev/sdX bs=8M &amp; pid=$! </pre></div></div><p>Um nun die Fortschrittsanzeige auszugeben, kann folgendes Kommando auf der selben Konsole eingegeben werden:
</p><div class="bash"><div class="contents"><pre class="notranslate">while true; do kill -USR1 $pid &amp;&amp; sleep 1 &amp;&amp; clear; done </pre></div></div><p>
</p></div></div></div><div class="section_2"><h3 id="Partitionen-klonen">Partitionen klonen<a class="headerlink" href="#Partitionen-klonen">¶</a></h3><p>
</p><div class="box warning"><h3 class="box warning">Achtung!</h3><div class="contents"><p>Es sollte darauf geachtet werden, dass die Ziel-Partition gleich groß oder größer als die Quelle-Partition ist. 
</p></div></div><p>Der folgende Befehl klont (kopiert) die komplette Partition <strong>/dev/sda1</strong> auf die Partition <strong>/dev/sdb1</strong>:
</p><div class="bash"><div class="contents"><pre class="notranslate">dd if=/dev/sda1 of=/dev/sdb1 </pre></div></div><p>Man soll sich im Klaren sein, dass dabei alle Partitionsattribute dupliziert werden (Größe, UUID, Label). Alle Geräte mit den dazugehörigen Informationen kann man auflisten:
</p><div class="bash"><div class="contents"><pre class="notranslate">sudo blkid </pre></div></div><p>Wenn die Ziel-Partition größer als die Quelle ist, kann man das Zielfilesystem auf die gesamte Partition ausdehnen:
</p><div class="bash"><div class="contents"><pre class="notranslate">sudo resize2fs /dev/sdb1 </pre></div></div><p><a class="internal" href="./uuid.html">UUID</a> neu setzen:
</p><div class="bash"><div class="contents"><pre class="notranslate">sudo tune2fs -U random /dev/sdb1 </pre></div></div><p><a class="internal" href="./labels.html">Labels</a> neu vergeben:
</p><div class="bash"><div class="contents"><pre class="notranslate">sudo e2label /dev/sdb1 newlabel </pre></div></div></div><div class="section_2"><h3 id="Image-einer-Partition-sichern">Image einer Partition sichern<a class="headerlink" href="#Image-einer-Partition-sichern">¶</a></h3><p>
Der folgende Befehl erstellt ein <a class="interwiki interwiki-wikipedia" href="https://de.wikipedia.org/wiki/Speicherabbild">Image</a> von <strong>/dev/sda1</strong> in die Datei <strong>image_sda1.img</strong>, welche im Heimatverzeichnis gespeichert wird:</p><div class="bash"><div class="contents"><pre class="notranslate">dd if=/dev/sda1 of=~/image_sda1.img </pre></div></div><p>
Dies ist die schnellste Methode. Oftmals lässt sich viel Speicherplatz einsparen, wenn das Image zugleich komprimiert wird. Dies bedeutet jedoch größeren Zeitaufwand, was kritisch sein kann, wenn Dateien von einem kränkelnden Datenspeicher gerettet werden sollen.</p><p>Der folgende Befehl erstellt ein komprimiertes Image der Partition <strong>/dev/sda1</strong> und speichert dieses in die Datei <strong>image-compress_sda1.img.gz</strong> im Heimatverzeichnis. Durch das Weglassen von of im Befehlsaufruf werden die Daten auf die Standardausgabe geschrieben, wo sie dann per Pipe-Operator an <strong><a class="internal" href="./gzip.html">gzip</a></strong> weitergeleitet werden:</p><div class="bash"><div class="contents"><pre class="notranslate">dd if=/dev/sda1 | gzip &gt; ~/image-compress_sda1.img.gz </pre></div></div><div class="box notice"><h3 class="box notice">Hinweis:</h3><div class="contents"><p>Im Regelfall reichen die Standardeinstellungen von gzip aus. Möchte man dennoch die beste Kompressionsstufe, so lautet der zu verwendende Befehl <code class="notranslate">gzip -9</code>. Zu beachten ist, dass bei hohen Kompressionsstufen die Dauer deutlich erhöht - teils sogar vervielfacht - wird, während der Speicherverbrauch nur gering abnimmt <sup><a href="#source-1">[1]</a></sup>.</p><p>Auch wenn das Image von gzip mit der höchsten Kompressionsstufe komprimiert wird, kann die Ausgabedatei unter Umständen trotzdem sehr groß werden. Man sollte also auf ausreichend Platz auf dem Zieldatenträger achten! 
</p></div></div><p>Sofern die zu sichernde Partition nicht verschlüsselt ist, lässt sich die Kompression oft erheblich verbessern, wenn ihr freier Speicherplatz vorab mit <a class="internal" href="./daten_sicher_löschen.html#Methode-2">Nullen überschrieben wird</a>. Bedenken sollte man, dass eine eventuelle <a class="internal" href="./datenrettung.html">Datenrettung</a> von versehentlich gelöschten Dateien danach unmöglich wird.</p><p>Um das so erzeugte komprimierte Image wieder zurückzusichern, kann man folgenden Befehl verwenden:</p><div class="bash"><div class="contents"><pre class="notranslate">gzip -cd ~/image-compress_sda1.img.gz | sudo dd of=/dev/sda1 </pre></div></div></div><div class="section_2"><h3 id="Dateigroesse-des-Images-begrenzen">Dateigröße des Images begrenzen<a class="headerlink" href="#Dateigroesse-des-Images-begrenzen">¶</a></h3><p>
Für den Fall, dass zum Beispiel das <a class="internal" href="./dateisystem.html">Dateisystem</a> des Ziellaufwerkes eine <a class="internal" href="./dateisystem.html#Weitere-Merkmale">Dateigrößenbeschränkung</a> hat, besteht die Möglichkeit zum Splitten der Imagedatei. Auf einem FAT32-Laufwerk beispielsweise ist die Dateigröße auf 4 GiB (1 GiB = 1024 * 1024 * 1024 Byte) beschränkt.</p><p>In folgendem Beispiel wird das Image an <a class="internal" href="./split.html">split</a> übergeben und in Teile von je 3500 MiB (1 MiB = 1024 * 1024 Byte) gespeichert. Hierbei werden die jeweiligen Teile nummerisch beschriftet.</p><div class="bash"><div class="contents"><pre class="notranslate">dd if=/dev/sda1 | split -d -b 3500M - ~/image_sda1.img. </pre></div></div><div class="box notice"><h3 class="box notice">Hinweis:</h3><div class="contents"><p>Nicht den Punkt (<strong>.</strong>) hinter <strong>sda1.img</strong> vergessen! Dahinter steht dann die Folgenummer der Datei. Das Ergebnis sieht dann in diesem Fall so aus:</p><ul><li><p>image_sda1.img.00</p></li><li><p>image_sda1.img.01</p></li><li><p>image_sda1.img.02</p></li><li><p>image_sda1.img.03</p></li></ul></div></div><p>
Zurückgespielt wird dann, indem das Image durch <a class="internal" href="./cat.html">cat</a> automatisch wieder zusammengefügt und an dd übergeben wird.</p><div class="bash"><div class="contents"><pre class="notranslate">cat ~/image_sda1.img.* | dd of=/dev/sda1 </pre></div></div><p><a class="crosslink anchor" href="#mbr_sichern" id="mbr_sichern"></a>
</p></div><div class="section_2"><h3 id="MBR-Boot-Loader-und-Partitionstabelle-sichern">MBR: Boot-Loader und Partitionstabelle sichern<a class="headerlink" href="#MBR-Boot-Loader-und-Partitionstabelle-sichern">¶</a></h3><p>
Der MasterBootRecord (MBR) beherbergt den Boot-Loader, die Partitionstabelle und die MBR-Signatur. Der MBR ist exakt 512 Bytes lang und liegt am Beginn der Festplatte. Der Boot-Loader belegt die ersten 446 Bytes des MBR, dann folgen die Partitionstabelle (64 Bytes) und die MBR-Signatur, und, Achtung, zumindest <a class="internal" href="./grub.html">GRUB</a>(<a class="internal" href="./grub_2.html">2</a>) nutzt je nach Konfiguration meist noch einige weitere Sektoren im sog. verborgenen Bereich vor der ersten Partition.</p><p>Zur Sicherung ist ein geeignetes Medium notwendig. Nutzer einer LiveCD (z. B. Ubuntu Installations-CD) müssen zunächst ein Medium verfügbar machen:</p><div class="bash"><div class="contents"><pre class="notranslate">sudo fdisk -l </pre></div></div><p>
zeigt die Bezeichnungen der eigenen Festplatten an und dient als Orientierunghilfe für folgende Kommandos.</p><p>Nun erstellt man einen Ordner im Dateisystem der Live-CD und hängt dort eine Partition ein, auf welcher die Sicherung des MBR erstellt wird.</p><div class="bash"><div class="contents"><pre class="notranslate">sudo mkdir ~/sda3
sudo mount /dev/sda3 ~/sda3
cd ~/sda3 </pre></div></div><p>
Es kann sich hierbei auch um einen USB-Stick, eine Netzwerkfreigabe oder ein anderes Medium handeln, auf welches man jederzeit Zugriff hat. Jetzt kann mit dem eigentlichen Sichern begonnen werden.</p><div class="box warning"><h3 class="box warning">Achtung!</h3><div class="contents"><p>Die Sicherung der Partitionstabelle mittels dd ist mit Vorsicht anzuwenden, da:
</p><ol class="arabic"><li><p>mit dem MBR nur die primären Einträge der Partitionstabelle (Bytes 446..509) gesichert werden. Die Einträge zu den logischen Partitionen stehen in den kaskadierten BRs (BootRecords) der erweiterten Partition, und fehlen damit hier komplett.</p></li><li><p>beim Einsatz einer <a class="internal" href="./partitionierung/grundlagen.html#GUID-Partition-Table">GPT</a> (<a class="interwiki interwiki-wikipedia" href="https://de.wikipedia.org/wiki/GUID_Partition_Table">GPT</a>) überhaupt keine Sicherung der Partitionstabelle erfolgt. Außerdem wird der <a class="internal" href="./grub_2/grundlagen.html#MBR-mit-GUID-Partitionstabelle-GPT">Bootloader in eine eigene Boot-Partitionen</a> installiert.</p></li></ol><p>Um immer auf der sicheren Seite zu sein, empfiehlt es sich nach jeder Partitionsänderung die entsprechenden Tabellen neu zu sichern. Bei der MBR-Partitionstabelle kann man dazu das Programm <a class="internal" href="./fdisk.html#%23Partitionstabelle-sichern">sfdisk</a> und bei der GUID-Partitionstabelle das Programm <a class="internal" href="./gdisk.html#%23Partitionstabelle-sichern">sgdisk</a> nutzen. Wer es noch einfacher möchte, der kann das Skript <a class="internal" href="./skripte/partitionstabellen_sichern.html">Partitionstabellen sichern</a> dazu nutzen. Spielt man eine alte MBR-Sicherung (mit alter und somit falscher Partitionstabelle) zurück, kann man auf die komplette Platte höchst wahrscheinlich nicht mehr zugreifen.
</p></div></div><div class="box notice"><h3 class="box notice">Hinweis:</h3><div class="contents"><p>Die folgenden Anweisungen zum Sichern des MBR sollten nur als Muster der Möglichkeiten von dd verstanden werden.
</p></div></div><p>Mit dem folgenden Befehlsaufruf würde der Boot-Loader der Festplatte <strong>/dev/sda</strong> als Datei <strong>bootloader_sicherung</strong> im aktuellen Verzeichnis gesichert. Die Partitionstabelle (Bytes 446..509) und die MBR-Signatur sind in dieser Sicherung nicht enthalten:</p><div class="bash"><div class="contents"><pre class="notranslate">sudo dd if=/dev/sda of=bootloader_sicherung bs=446 count=1 </pre></div></div><p>
Der folgende Befehl sichert den gesamten MBR (inklusive Partitionstabelle) der Festplatte <strong>/dev/sda</strong> als Datei <strong>mbr_sicherung</strong> im aktuellen Verzeichnis:</p><div class="bash"><div class="contents"><pre class="notranslate">sudo dd if=/dev/sda of=mbr_sicherung bs=512 count=1  </pre></div></div><p>
Bei installiertem <a class="internal" href="./dualboot.html">Boot-Manager</a>, z.B. <a class="internal" href="./grub_2.html">GRUB 2</a>, sollte man ggf. auch den sog. verborgenen Bereich hinter dem MBR, falls dieser (Regelfall) <a class="internal" href="./grub-umgebung_analysieren.html">dafür verwendet wird</a>, mitsichern und vorher schauen, wie viele Sektoren vor der ersten Partition frei sind:</p><div class="bash"><div class="contents"><pre class="notranslate">sudo fdisk -lu </pre></div></div><p>
Die erste Zahl in der Spalte Anfang zeigt den Startsektor der ersten Partition. Bei heutigen Festplatten beginnt die erste Partition meist bei Sektor 63. Dann schaut man noch wie viele Bytes ein Sektor hat – meist 512 – und passt den Befehl entsprechend an:</p><div class="bash"><div class="contents"><pre class="notranslate">sudo dd if=/dev/sda of=mbr+grub_sicherung bs=512 count=63  </pre></div></div><p>Die Partitionen von <a class="internal" href="./ssd.html">SSDs</a> sollten an ganzen Megabytes <a class="internal" href="./ssd/alignment.html">ausgerichtet</a> sein. Also sollte die erste Partition einer SSD bei 1 MiB (meist 2048 Sektoren ⋅ 512 Bytes) beginnen und der Befehl lautet
</p><div class="bash"><div class="contents"><pre class="notranslate">sudo dd if=/dev/sda of=mbr+grub_sicherung bs=1M count=1 </pre></div></div><p>Eine Sicherung des Boot-Loaders wird mit</p><div class="bash"><div class="contents"><pre class="notranslate">dd if=bootloader_sicherung of=/dev/sda bs=446 count=1 </pre></div></div><p>
zurückgespielt. Dieses Kommando kann auch unter Verwendung einer kompletten Sicherung des MBR bzw. obiger <strong>mbr+grub_sicherung</strong> verwendet werden: Es wird nur der Boot-Loader (Bytes 0..445) wiederhergestellt, die momentane Partitionstabelle (Bytes 446..509) und die MBR-Signatur bleiben dann in jedem Fall erhalten.</p><p>Will man den kompletten MBR (also inklusive Partitionstabelle) zurücksichern, so lautet der Befehl wie folgt:</p><div class="bash"><div class="contents"><pre class="notranslate">dd if=mbr_sicherung of=/dev/sda bs=512 count=1 </pre></div></div><p>Will man im Fall eines installierten <a class="internal" href="./dualboot.html">Boot-Managers</a> zusätzlich auch diesen (falls im sog. verborgenen Bereich hinter dem MBR abgelegt) zurücksichern (unter Erhalt des zuvor rückgesicherten Boot-Loaders und der Partitionstabelle), so lautet der Befehl wie folgt (falls die erste Partition bei Sektor 63 beginnt, siehe detaillierteren Hinweis weiter oben):</p><div class="bash"><div class="contents"><pre class="notranslate">dd if=mbr+grub_sicherung of=/dev/sda bs=512 skip=1 seek=1 count=62 </pre></div></div><p><a class="crosslink anchor" href="#mount_bsp" id="mount_bsp"></a></p></div><div class="section_2"><h3 id="Mit-dd-erstellte-Images-einbinden">Mit dd erstellte Images einbinden<a class="headerlink" href="#Mit-dd-erstellte-Images-einbinden">¶</a></h3><p>
</p><div class="section_3"><h4 id="Image-einer-Partition-einbinden">Image einer Partition einbinden<a class="headerlink" href="#Image-einer-Partition-einbinden">¶</a></h4><p>
Ein mit dd erstelltes Image lässt sich als Loop-Device mit dem Befehl <a class="internal" href="./mount.html">mount</a> einbinden. So kann auf das Image wie auf ein normales Laufwerk zugegriffen werden. Dazu erstellt man als erstes ein Image, hier z.B. vom Device <strong>/dev/sda1</strong>, gespeichert in der Datei <strong>loop_image.img</strong> im Heimatverzeichnis:</p><div class="bash"><div class="contents"><pre class="notranslate">dd if=/dev/sda1 of=~/loop_image.img </pre></div></div><p>
Dann erzeugt man einen Einhängpunkt, z.B. <strong>/media/loop_mount</strong>:</p><div class="bash"><div class="contents"><pre class="notranslate">sudo mkdir /media/loop_mount </pre></div></div><p>
Jetzt kann man das mit dd erzeugte Image mit <strong>mount</strong> einbinden:</p><div class="bash"><div class="contents"><pre class="notranslate">sudo mount -o loop ~/loop_image.img /media/loop_mount </pre></div></div><p>
Nun kann man auf alle Dateien, Verzeichnisse etc. des Images wie auf ein reguläres Laufwerk zugreifen. Nach der Benutzung muss man das Image dann wieder mit <strong>umount</strong> aushängen:</p><div class="bash"><div class="contents"><pre class="notranslate">sudo umount /media/loop_mount </pre></div></div><p>
Bei Bedarf kann das (bearbeitete) Image jetzt auch wieder zurück gesichert werden.</p></div><div class="section_3"><h4 id="Partition-aus-einem-Image-der-gesamten-Platte-einbinden">Partition aus einem Image der gesamten Platte einbinden<a class="headerlink" href="#Partition-aus-einem-Image-der-gesamten-Platte-einbinden">¶</a></h4><p>
Hat man nicht nur eine Partition, sondern die gesamte Festplatte inclusive MBR gesichert, braucht man den Offset der jeweiligen Partition. Diesen kann man mit dem Befehl</p><div class="bash"><div class="contents"><pre class="notranslate">sudo fdisk -l /Pfad/zum/Image.img </pre></div></div><p>
herausfinden. Die Ausgabe sieht bei 3 primären Partitionen ungefähr so aus:</p><pre class="notranslate">Platte /Pfad/zum/Image.img: 0 MByte, 0 Byte
255 Köpfe, 63 Sektoren/Spuren, 0 Zylinder, zusammen 0 Sektoren
Einheiten = Sektoren von 1 × 512 = 512 Bytes
Disk identifier: 0xd53d826f

    Gerät            boot. Anfang      Ende         Blöcke     Id  System
/Pfad/zum/Image.img1   *          63   104872319    52436128+   7  HPFS/NTFS
Partition 1 hat unterschiedliche phys./log. Enden:
     phys=(1023, 254, 63) logisch=(6527, 254, 63)
/Pfad/zum/Image.img2       104872320   109065284    2096482+   82  Linux Swap / Solaris
Partition 2 hat unterschiedliche phys./log. Anfänge (nicht-Linux?):
     phys=(1023, 0, 1) logisch=(6528, 0, 1)
Partition 2 hat unterschiedliche phys./log. Enden:
     phys=(1023, 254, 63) logisch=(6788, 254, 63)
/Pfad/zum/Image.img3       109065285   156296384    23615550   83  Linux
Partition 3 hat unterschiedliche phys./log. Anfänge (nicht-Linux?):
     phys=(1023, 0, 1) logisch=(6789, 0, 1)
Partition 3 hat unterschiedliche phys./log. Enden:
     phys=(1023, 254, 63) logisch=(9728, 254, 63)</pre><p>Der Wert hinter der entsprechende Partition unter Anfang, ist der Offset, dieser muss jedoch noch mit der weiter oben angegebenen Sektorgröße multipliziert werden (hier 512). Der Offset für die 3. Partition wäre also 109065285 * 512 = 55841425920. Nun Folgt der Mountbefehl mit dem entsprechenden Offset (hier wieder am Beispiel der 3. Partition):</p><div class="bash"><div class="contents"><pre class="notranslate">sudo mkdir /media/loop_mount # Verzeichniss anlegen
sudo mount -o loop,offset=55841425920 /Pfad/zum/Image.img /media/loop_mount </pre></div></div><p>
Zum Schluss wird das Image wieder freigegeben mit:</p><div class="bash"><div class="contents"><pre class="notranslate">sudo umount /media/loop_mount </pre></div></div><p>
Des Weiteren gibt es ein <a class="internal" href="./mount.html#Festplatten-Image">fertiges Skript</a>, mit dem mit dd erstellte Image-Dateien komfortable eingebunden werden können.</p></div></div><div class="section_2"><h3 id="Image-im-Netzwerk-speichern">Image im Netzwerk speichern<a class="headerlink" href="#Image-im-Netzwerk-speichern">¶</a></h3><p>
Ein mit dd erstelltes Image muss nicht zwangsläufig lokal gespeichert werden, sondern kann auch auf einen anderen Rechner im Netzwerk gesichert werden. Im folgenden Beispiel wird mit dd ein Image von <strong>/dev/sda1</strong> erstellt, welches dann <a class="internal" href="./ssh.html">ssh-verschlüsselt</a> auf den Rechner mit der IP-Adresse <code class="notranslate">192.168.0.100</code> übertragen und dort im Verzeichnis <strong>/home/BENUTZER</strong> in  der Datei <strong>image_sda1.img</strong> gespeichert wird. Damit dies funktioniert, muss "BENUTZER" ein Benutzerkonto auf dem entsprechenden Rechner haben und man selbst die notwendigen <a class="internal" href="./rechte.html">Rechte</a>, um dort zu schreiben. Der Befehlsaufruf lautet:</p><div class="section_3"><h4 id="gzip-komprimiert-und-ssh-verschluesselt">gzip-komprimiert und ssh-verschlüsselt<a class="headerlink" href="#gzip-komprimiert-und-ssh-verschluesselt">¶</a></h4><p>
</p><div class="bash"><div class="contents"><pre class="notranslate">dd if=/dev/sda1 | gzip -9 - | ssh user@192.168.0.100 "cat &gt; /home/BENUTZER/image_sda1.img.gz" </pre></div></div><p>
Um das Image zurückzusichern (z.B. auf den Rechner mit der IP-Adresse <code class="notranslate">192.168.0.50</code>), gibt man folgenden Befehl ein:</p><div class="bash"><div class="contents"><pre class="notranslate">ssh user@192.168.0.50 "cat /home/user/image_sda1.img.gz" | gunzip -c - | dd of=/dev/sda1 </pre></div></div></div><div class="section_3"><h4 id="bzip2-komprimiert-und-nicht-verschluesselt">bzip2-komprimiert und nicht verschlüsselt<a class="headerlink" href="#bzip2-komprimiert-und-nicht-verschluesselt">¶</a></h4><p>
Alternativ mit bzip komprimiert, aber im Transfer nicht:</p><ul><li><p>Auf dem Zielrechner: </p><div class="bash"><div class="contents"><pre class="notranslate">netcat -l -p 5555 | dd of=/home/user/image_sda1.img bs=16065b </pre></div></div></li><li><p>Auf dem Quellrechner: </p><div class="bash"><div class="contents"><pre class="notranslate">dd if=/dev/sda1 bs=16065b | pv | bzip2 -1 | netcat ZielIP 5555 </pre></div></div><p> Zur Verwendung des Befehls <strong>pv</strong> siehe <a class="crosslink" href="#Fortschrittsanzeige">Fortschrittsanzeige</a>.</p></li></ul></div><div class="section_3"><h4 id="FTP-mit-gzip-Komprimierung-und-nicht-verschluesselt">FTP mit gzip Komprimierung und nicht verschlüsselt<a class="headerlink" href="#FTP-mit-gzip-Komprimierung-und-nicht-verschluesselt">¶</a></h4><p>
Erstellen eines Images über FTP:</p><div class="bash"><div class="contents"><pre class="notranslate">dd if=/dev/sda bs=4k | gzip -9 - | ncftpput -c -V -u FTPUSER -p FTPPASSWORT FTPSERVER /FTPPATH/NAME.img.gz  </pre></div></div><p>
Und zum Einspielen vom erstellten Images:</p><div class="bash"><div class="contents"><pre class="notranslate">ncftpget -c -V -u FTPUSER -p FTPPASSWORT FTPSERVER /FTPPATH/NAME.img.gz | gunzip -c - | dd of=/dev/sda bs=4k </pre></div></div></div></div><div class="section_2"><h3 id="Fortschrittsanzeige">Fortschrittsanzeige<a class="headerlink" href="#Fortschrittsanzeige">¶</a></h3><p>
Sehr häufig wird eine Fortschrittsanzeige gewünscht, um den Status und die verbleibende Restdauer einer Aktion mit dd nachvollziehen zu können.</p><div class="section_3"><h4 id="Seit-Version-8-24">Seit Version 8.24<a class="headerlink" href="#Seit-Version-8-24">¶</a></h4><p>
In Ubuntu 16.04 ist dd in der Version 8.25 enthalten. Seit Version 8.24 ist es mit dem Parameter <strong>status</strong> möglich den Fortschritt anzuzeigen.
Der Befehl dazu könnte so aussehen:
</p><div class="bash"><div class="contents"><pre class="notranslate">dd if=/dev/XXX of=/dev/XXX status=progress </pre></div></div></div><div class="section_3"><h4 id="Einmalige-oder-regelmaessige-Abfrage-mittels-Senden-des-Signals-USR1">Einmalige oder regelmäßige Abfrage mittels Senden des Signals -USR1<a class="headerlink" href="#Einmalige-oder-regelmaessige-Abfrage-mittels-Senden-des-Signals-USR1">¶</a></h4><p>
Informationen zum ermitteln von Prozessen siehe <a class="internal" href="./shell/ps.html">ps</a>, <a class="internal" href="./pgrep.html">pgrep</a> oder <a class="internal" href="./shell/pidof.html">pidof</a>  und zum senden von Signalen <a class="internal" href="./shell/kill.html">kill</a>, <a class="internal" href="./pkill.html">pkill</a> oder <a class="internal" href="./shell/killall.html">killall</a>.</p><p>Wenn das dd-Kommando einmal abgesetzt wurde, wünscht man sich bei größeren Kopiervorgängen eine Kontrollmöglichkeit über den Fortschritt. Dies erreicht man indem man dem <code class="notranslate">dd</code>-Prozess das Signal <code class="notranslate">-USR1</code> sendet.</p><div class="section_4"><h5 id="ps-und-kill">ps und kill<a class="headerlink" href="#ps-und-kill">¶</a></h5><p>
In einem zweiten Terminal, ermittelt man die Prozessnummer, z.B. mit</p><div class="bash"><div class="contents"><pre class="notranslate">ps -a </pre></div></div><p> 
und setzt ein Signal <code class="notranslate">-USR1</code> ab.  (bei Lucid Lynx mit <em>sudo</em>).</p><div class="bash"><div class="contents"><pre class="notranslate">kill -USR1 &lt;prozessnummer&gt; </pre></div></div><p>
Die bisher kopierte Datenmenge wird dann in dem Terminal angezeigt, in dem <code class="notranslate">dd</code> gestartet wurde. Mit einer Kombination aus <code class="notranslate">dd</code> und einer Schleife kann man dies auch automatisieren.</p><div class="bash"><div class="contents"><pre class="notranslate">dd if=/dev/XXX of=/dev/XXX &amp; ddpid=$! ; while [ $(ps -ao pid | grep $ddpid) ]; do kill -SIGUSR1 $ddpid; sleep 10; done </pre></div></div></div><div class="section_4"><h5 id="pkill">pkill<a class="headerlink" href="#pkill">¶</a></h5><p>
Sofern nur ein Prozess mit dem Namen <code class="notranslate">dd</code> läuft kann man dies auch über den Prozessnamen.</p><div class="bash"><div class="contents"><pre class="notranslate">pkill -USR1 -x dd </pre></div></div><p>
In einer Schleife kann das so aussehen:</p><div class="bash"><div class="contents"><pre class="notranslate">dd if=/dev/XXX of=/dev/XXX &amp; while [ ! $(pkill -USR1 -x dd) ]; do sleep 10 ; : ; done </pre></div></div><p>
oder alternativ:
</p><div class="bash"><div class="contents"><pre class="notranslate">watch -n10 pkill -USR1 -x dd </pre></div></div></div><div class="section_4"><h5 id="pv">pv<a class="headerlink" href="#pv">¶</a></h5><p>
Als Alternative zur oben beschriebenen Vorgehensweise kann man auch den Befehl <a class="internal" href="./pv.html">pv</a> verwenden, um sich den Fortschritt anzeigen zu lassen. Dabei wird pv mittels einer Pipe dazwischengeschaltet. Um sich anzeigen zu lassen, wie weit der Vorgang fortgeschritten ist und wann er voraussichtlich beendet sein wird, muss man allerdings die Größe der Partition bzw. der Festplatte kennen.</p></div></div></div><div class="section_2"><h3 id="Live-USB-Stick-erstellen">Live USB-Stick erstellen<a class="headerlink" href="#Live-USB-Stick-erstellen">¶</a></h3><p>
Mit <code class="notranslate">dd</code> lässt sich auch auf einfachste Art und Weise ein Live USB-Stick (als Ersatz für eine Live-CD) erstellen.</p><p>Im folgenden Beispiel wird davon ausgegangen, dass der USB-Stick als <code class="notranslate">/dev/sdx</code> erkannt wurde und nicht <a class="internal" href="./mount.html#Dateisysteme-aushaengen">eingebunden</a> ist (aber bitte nicht auswerfen bzw. <em>"sicher entfernen"</em>):</p><div class="bash"><div class="contents"><pre class="notranslate">sudo dd if=hybrid_iso_image.iso of=/dev/sdx bs=1M &amp;&amp; sync </pre></div></div><p>
Dabei beachten, dass der Pfad zum USB-Stick angegeben wird (z.B. sdx) und nicht der zu einer Partition (z.B. sdx1).
Den Parameter <code class="notranslate">bs=1M</code> kann man auch weglassen, aber er beschleunigt den Kopiervorgang. Weitere Tipps zu bootbaren USB-Medien findet man im Artikel <a class="internal" href="./live-usb.html">Live-USB</a>.</p></div></div><div class="section_1"><h2 id="Links">Links<a class="headerlink" href="#Links">¶</a></h2><p>
</p><ul><li><p><a class="external" href="http://compressionratings.com/i_gzip.html" rel="nofollow">gzip compression rates</a> <img alt="{en}" src="./_/d5ecf89114b079f85d02099649c4ee617ffa34c7.png"/></p></li><li><p><a class="external" href="http://gamblisfx.com/gdiskdump-powerful-hard-disk-cloning-tool/" rel="nofollow">Gdiskdump – powerful hard disk cloning tool</a> <img alt="{en}" src="./_/d5ecf89114b079f85d02099649c4ee617ffa34c7.png"/> - GUI für dd. Blogbeitrag, 04/2014</p></li><li><p><a class="interwiki interwiki-heise" href="https://www.heise.de/-198816">Sicheres Löschen: Einmal überschreiben genügt</a> <img alt="{de}" src="./_/ffd333e1d59794eac31aea8b3e984e1b88473c33.png"/> - heise News, 01/2009</p></li><li><p><a class="external" href="http://o-o-s.de/dd-mit-statusanzeige/79" rel="nofollow">dd mit Statusanzeige</a> <img alt="{de}" src="./_/ffd333e1d59794eac31aea8b3e984e1b88473c33.png"/> - Blogbeitrag, 01/2007</p></li></ul><p>
</p></div></div>
<p class="meta">
<a href="./dd/a/revision/945803.html">Diese Revision</a> wurde am 28. Dezember 2017 21:25 von <a href="https://ubuntuusers.de/user/BillMaier/">BillMaier</a> erstellt.
    
  </p>
</div>
</div>
<div style="clear: both;"></div>
<div class="pathbar breadcrumb">
<div class="breadcrumb">
<ol>
<li><a href="./startseite.html">Wiki</a></li>
<li><a href="./dd.html">dd</a></li>
</ol>
</div>
</div>
</div>
<div class="footer" style="clear: both;">
<ul>
<li class="poweredby"><li class="poweredby">Erstellt mit <a href="http://inyokaproject.org/">Inyoka</a></li></li>
<li class="license">

<img alt="Copyleft" src="./_/65dad5b770326dbbe1bd26ee6363e366a76bd8b7.png"/>
          2004 – 2017 ubuntuusers.de • Einige Rechte vorbehalten<br/>
<a href="./_lizenz.html" rel="cc:morePermissions">Lizenz</a> •
          <a href="http://ubuntuusers.de/kontakt/">Kontakt</a> •
          <a href="http://ubuntuusers.de/datenschutz/">Datenschutz</a> •
          <a href="http://ubuntuusers.de/impressum/">Impressum</a> •
          <a href="https://ubuntuusers.statuspage.io">Serverstatus</a>
</li>
<li class="housing">
<span title="Unterbringung und Netzanbindung eines Servers">Serverhousing</span> gespendet von<br/>
<img alt="noris network" src="./_/e7d27e9081eec23a8a5a5fe9434d7b2f1532e1d9.png"/>
<img alt="anexia" src="./_/ad1b63a3fc35749344af0a03e8c3ce05a2a3ee7e.png"/>
</li>
</ul>
</div>
<div style="clear: both;"></div>
</div>






</body>
</html>