<!DOCTYPE html>
<html lang="">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>Shell/Tipps_und_Tricks › ubuntuusers statisches Wiki</title>
<link href="../_/34e5d78db234405457773cc26741aada99f7fff2.css" rel="stylesheet" type="text/css"/>
<link href="../_/61af784fc5c93e296fec3be63b8e0bb48443727c.css" rel="stylesheet" type="text/css"/>
<link href="../_/634e8d1015b02df998cdec7cb07c5aff61d068b5.css" rel="stylesheet" type="text/css"/>
<link href="../_/b583ff7e37147497a59224ccf54cfee812a1d21b.css" rel="stylesheet" type="text/css"/>
<link href="../_/a0d5775ed6f36f8cc5b12bcf2f1c1bd98a3eb225.css" rel="stylesheet" type="text/css"/>
<link href="../_/98de73bded109a634cbd1e924abdd8c8964b8df2.css" media="print" rel="stylesheet" type="text/css"/>

<meta content="#a87300" name="theme-color"/>

</head>
<body>
<div class="wrap">
<div class="header">
<h1><a href="http://ubuntuusers.de/"><span>ubuntuusers.de</span></a></h1>
<ul class="tabbar">
<li class="portal">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://ubuntuusers.de/">Portal<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="forum">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://forum.ubuntuusers.de/">Forum<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="wiki active">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://wiki.ubuntuusers.de/">Wiki<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="ikhaya">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://ikhaya.ubuntuusers.de/">Ikhaya<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="planet">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://planet.ubuntuusers.de/">Planet<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="community">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://wiki.ubuntuusers.de/Mitmachen">Mitmachen<span></span></a></div>
<div class="tab_right"></div>
</li>
</ul>
</div>
<div class="body">
<div class="appheader">

<div class="pagetitle">
<h1 class="breadcrumb_title">
<a class="separator" href="../startseite.html">
              Wiki
            </a>
</h1>
<h2 class="breadcrumb_subtitle"><a href="../shell/tipps_und_tricks.html">Tipps und Tricks</a></h2>
</div>
</div><div class="message staticwikinote"><strong>Hinweis:</strong> Dies ist ein statischer Snapshot unseres Wikis vom Jan. 17, 2018 und kann daher nicht bearbeitet werden. Der aktuelle Artikel ist unter <a href="http://wiki.ubuntuusers.de/Shell/Tipps_und_Tricks">wiki.ubuntuusers.de</a> zu finden.</div>

<!--[if lt IE 8]>
      <div class="message fail">Bitte installiere den Internet Explorer 8 oder neuer.</div>
      <![endif]-->
<div class="page_content">
<div class="navi_sidebar navigation">
<div class="container">
<h3 class="navi_wiki">Wiki</h3>
<ul>
<li><a href="../wiki/index.html">Index</a></li>
<li><a href="../wiki/recentchanges.html">Letzte Änderungen</a></li>
<li><a href="../wiki/neue_artikel.html">Liste neuer Artikel</a></li>
<li><a href="../wiki.html">Übersicht</a></li>
<li><a href="../wiki/faq_-_häufig_gestellte_fragen.html">FAQ</a></li>
<li><a href="../wiki/benutzung.html">Benutzung</a></li>
<li><a href="../kategorien.html">Kategorie</a></li>
<li><a href="../wiki/tagcloud.html">Wortwolke</a></li>
</ul>
<h3 class="navi_join">Mitmachen</h3>
<ul>
<li><a href="../wikiartikel_anlegen.html">Wikiartikel anlegen</a></li>
<li><a href="../howto.html">Howto anlegen</a></li>
<li><a href="../wiki/referenz.html">Wiki-Referenz</a></li>
<li><a href="../wiki/syntax.html">Wiki-Syntax</a></li>
<li><a href="../baustelle.html">Baustellen</a></li>
<li><a href="../wiki/artikelideen.html">Artikelideen</a></li>
<li><a href="../wiki/ungetestet.html">Ungetestete Artikel</a></li>
<li><a href="../wiki/vorlagen/ausbaufähig/a/backlinks.html">Ausbaufähige Artikel</a></li>
<li><a href="../wiki/vorlagen/fehlerhaft/a/backlinks.html">Fehlerhafte Artikel</a></li>
<li><a href="https://forum.ubuntuusers.de/forum/wiki/">Rund ums Wiki</a></li>
</ul>
<h3 class="navi_config">Konfiguration</h3>
<ul>
<li><a href="../shell/tipps_und_tricks/a/backlinks.html">Backlinks anzeigen</a></li>
<li>
        Exportieren
        <ul>
<li><a href="../shell/tipps_und_tricks/a/export/meta.html" rel="nofollow">Metadaten</a></li>
<li><a href="../shell/tipps_und_tricks/a/export/raw.html" rel="nofollow">Rohformat</a></li>
<li><a href="../shell/tipps_und_tricks/a/export/html.html" rel="nofollow">HTML</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div class="content content_tabbar content_sidebar">
<h1 class="pagetitle"><a href="../shell/tipps_und_tricks/a/backlinks.html">Tipps und Tricks</a></h1>
<div id="page"><div class="box advanced"><h3 class="box advanced">Artikel für fortgeschrittene Anwender</h3><div class="contents"><p>
Dieser Artikel erfordert mehr Erfahrung im Umgang mit
Linux und ist daher nur für fortgeschrittene Benutzer
gedacht.
</p></div></div><div class="box knowledge"><h3 class="box knowledge">Zum Verständnis dieses Artikels sind folgende Seiten hilfreich:</h3><div class="contents"><p>
</p><ol class="arabic"><li><p><a class="crosslink anchor" href="#source-1" id="source-1"></a> <a class="internal" href="../terminal.html">Ein Terminal öffnen</a> </p></li><li><p><a class="crosslink anchor" href="#source-2" id="source-2"></a> <a class="internal" href="../editor.html">Einen Editor öffnen</a> </p></li></ol></div></div><p>
</p><div class="toc toc-depth-2"><div class="head">Inhaltsverzeichnis</div><ol class="arabic"><li><a class="crosslink" href="#Tipps">Tipps
</a><ol class="arabic"><li><a class="crosslink" href="#Sinnloses-cat">Sinnloses cat
</a></li><li><a class="crosslink" href="#Sinnloses-kill-9">Sinnloses kill -9
</a></li><li><a class="crosslink" href="#Sinnloses-echo">Sinnloses echo
</a></li><li><a class="crosslink" href="#Sinnloses-ls">Sinnloses ls
</a></li><li><a class="crosslink" href="#Sinnloses-grep-wc-l">Sinnloses grep | wc -l
</a></li><li><a class="crosslink" href="#Sinnloses-grep-awk">Sinnloses grep | awk
</a></li><li><a class="crosslink" href="#Sinnloses-grep-sed">Sinnloses grep | sed
</a></li><li><a class="crosslink" href="#Sinnloses-ps-grep">Sinnloses ps | grep
</a></li><li><a class="crosslink" href="#Sinnlose-Kommandosubstitution">Sinnlose Kommandosubstitution
</a></li><li><a class="crosslink" href="#Sinnloses-test">Sinnloses test
</a></li><li><a class="crosslink" href="#Regulaerer-Ausdruck-und">Regulärer Ausdruck und .*
</a></li><li><a class="crosslink" href="#Sinnloses-dd-hexdump">Sinnloses dd | hexdump
</a></li></ol></li><li><a class="crosslink" href="#Tricks">Tricks
</a><ol class="arabic"><li><a class="crosslink" href="#Leeren-einer-Datei">Leeren einer Datei
</a></li><li><a class="crosslink" href="#Vermeidung-von-read-und-Pipe">Vermeidung von read und Pipe
</a></li><li><a class="crosslink" href="#Kopieren-mit-tar-und-ssh">Kopieren mit tar und ssh
</a></li><li><a class="crosslink" href="#Speichern-von-Befehlen">Speichern von Befehlen
</a></li><li><a class="crosslink" href="#Befehle-wiederholen-Stapelverarbeitung-Batch-Processing">Befehle wiederholen: Stapelverarbeitung ...</a></li><li><a class="crosslink" href="#Tabellen-zur-Weiterverarbeitung-umwandeln">Tabellen zur Weiterverarbeitung umwandel...</a></li></ol></li><li><a class="crosslink" href="#Links">Links
</a></li></ol></div><p><img alt="Wiki/Icons/terminal.png" class="image-left" src="../_/e81889fd6e485dd32e1cde611eabc18abced7993.png"/>
Dieser Artikel soll ein wenig Hilfe geben, "besser" mit der <a class="internal" href="../shell.html">Shell</a> umzugehen. Insbesondere wird ein Augenmerk darauf gelegt, übersichtlich zu bleiben und dabei möglichst wenige Prozesse zu verwenden. In Zeiten von Gigahertz-Prozessoren wirkt das vielleicht ein wenig anachronistisch, wenn allerdings ein "schlechtes" Konstrukt in einem Skript einige tausend oder gar Millionen Male ausgeführt wird, können nicht unerhebliche Laufzeiten entstehen.</p><p>Weiterhin soll hier der eine oder andere nicht offensichtliche Trick zu finden sein.</p><p>Die Shell und die Standard-Unix-Hilfsprogramme wie beispielsweise <a class="internal" href="../grep.html">grep</a>, <a class="internal" href="../sed.html">sed</a> und <a class="internal" href="../awk.html">awk</a> sind eine mächtige Kombination, die das Computer-Leben erleichtern kann.</p><div class="section_1"><h2 id="Tipps">Tipps<a class="headerlink" href="#Tipps">¶</a></h2><p>
</p><div class="section_2"><h3 id="Sinnloses-cat">Sinnloses cat<a class="headerlink" href="#Sinnloses-cat">¶</a></h3><p>
<a class="internal" href="../cat.html">cat</a> wird häufig verwendet, um den Inhalt einer Datei an ein Programm zu übergeben. Das ist aber überflüssig, da man das auch mit einem Kleiner-Als-Zeichen machen kann.</p><p>Schlecht:</p><div class="bash"><div class="contents"><pre class="notranslate">cat dateiname | grep "suchbegriff" </pre></div></div><p>Schon besser:</p><div class="bash"><div class="contents"><pre class="notranslate">grep "suchbegriff" &lt;dateiname </pre></div></div><p>Vielen Befehlen kann man die Datei aber auch direkt übergeben, darunter auch grep:</p><div class="bash"><div class="contents"><pre class="notranslate">grep "suchbegriff" dateiname </pre></div></div></div><div class="section_2"><h3 id="Sinnloses-kill-9">Sinnloses kill -9<a class="headerlink" href="#Sinnloses-kill-9">¶</a></h3><p>
<code class="notranslate">kill -9</code> bricht einen Prozess ohne Rücksicht auf Tochterprozesse ab. Das sollte nur dann in Erwägung gezogen werden, wenn ein <code class="notranslate">kill PID</code> nicht mehr funktioniert.</p><p><a class="internal" href="../kill.html">kill</a> <code class="notranslate">PID</code> sendet eine "Beenden-Aufforderung (<code class="notranslate">-15</code>/<code class="notranslate">-TERM</code>)" an den Prozess mit der Nummer <code class="notranslate">PID</code>, damit bekommt er die Gelegenheit, offene Dateien zu schließen, die Tochterprozesse sauber zu beenden, Socket-Verbindungen zu beenden, temporäre Dateien zu löschen, ... <br/><a class="internal" href="../pkill.html">pkill</a> <code class="notranslate">NAME</code> sendet ebenfalls eine "Beenden-Aufforderung (<code class="notranslate">-15</code>/<code class="notranslate">-TERM</code>)" an den Prozess, nur dass man hier den Prozessnamen bzw. einen regulären Ausdruck anstatt der PID benutzt. Siehe auch <a class="internal" href="../shell/pidof.html">pidof</a> mit dem korrekten Programmnamen.</p><p>Erst wenn das nicht funktioniert, weil der Prozess hängt, ist ein <code class="notranslate">kill -9</code> angebracht.</p></div><div class="section_2"><h3 id="Sinnloses-echo">Sinnloses echo<a class="headerlink" href="#Sinnloses-echo">¶</a></h3><p>
Das ist ein Spezialfall der sinnlosen Verwendung von Kommandosubstitution:</p><p>Häufig ist folgende (falsche) Verwendung zu sehen:</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span>Kommando <span class="k">$(</span><span class="nb">echo</span> <span class="nv">$variable</span><span class="k">)</span>
</pre></div>
</td></tr></table></div><p>Eine Shell interpretiert jede Kommandozeile zweistufig. In der ersten Stufe werden alle Variablen durch ihre Inhalte ersetzt, es wird eine Dateinamenersetzung und eine Kommandoersetzung durchgeführt. In der zweiten Stufe wird die daraus entstandene Kommandozeile ausgeführt.</p><p>Damit ist Folgendes der richtige Weg:</p><div class="bash"><div class="contents"><pre class="notranslate">Kommando $variable </pre></div></div><p>In der ersten Stufe wird $variable durch dessen Inhalt ersetzt. In der zweiten Stufe wird die daraus entstandene Zeile ausgeführt.</p></div><div class="section_2"><h3 id="Sinnloses-ls">Sinnloses ls<a class="headerlink" href="#Sinnloses-ls">¶</a></h3><p>
Ein weiterer Spezialfall der sinnlosen Verwendung von Befehlssubstitution ist der Einsatz von <code class="notranslate">ls</code>.</p><p>Falsch: 
</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="k">for</span> i in <span class="k">$(</span>ls *<span class="k">)</span>
<span class="k">do</span>
  cat <span class="nv">$i</span>
<span class="k">done</span>
</pre></div>
</td></tr></table></div><p>Wie im vorigen Abschnitt beschrieben, durchläuft jedes Shellkommando einen zweistufigen Interpretationsprozess. In der ersten Stufe wird eine Dateinamenersetzung durchgeführt, so dass man gerne das Folgende macht:</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="k">for</span> i in *
<span class="k">do</span>
  cat <span class="nv">$i</span>
<span class="k">done</span>
</pre></div>
</td></tr></table></div><p>Jedes Vorkommen von <code class="notranslate">*</code> wird durch die Dateien ersetzt, die auf <code class="notranslate">*</code> passen. Beinhalten die Dateien jedoch Leerzeichen, dann werden auch die Dateinamen einzeln interpretiert und das Leerzeichen wirkt wie ein Trenner, sie werden aufgesplittet. Um dies zu vermeiden sollte man die zu bearbeitende Variable immer in <strong>""</strong> setzen oder eine <a class="crosslink" href="#read-Variable"><code class="notranslate">read</code>-Schleife</a> benutzen.</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="k">for</span> i in *
<span class="k">do</span>
    <span class="nb">echo</span> <span class="s2">"</span><span class="nv">$i</span><span class="s2">"</span>  <span class="c1"># Variable in " "</span>
<span class="k">done</span>
</pre></div>
</td></tr></table></div><p>Es tritt noch ein weiteres Problem auf, bei <code class="notranslate">ls *</code> werden auch evtl. vorhandene Unterverzeichnisse durchsucht und das Ergebnis wird verfälscht.</p><p>Um das Beispiel mit <code class="notranslate">cat</code> zu vervollständigen: <code class="notranslate">cat</code> erlaubt auch die Angabe mehrerer Dateien, also ist das folgende die beste Lösung um Dateiinhalte aufzulisten:</p><div class="bash"><div class="contents"><pre class="notranslate">cat * </pre></div></div></div><div class="section_2"><h3 id="Sinnloses-grep-wc-l">Sinnloses grep | wc -l<a class="headerlink" href="#Sinnloses-grep-wc-l">¶</a></h3><p>
Sehr häufig sind Konstrukte anzutreffen, in denen etwas gesucht und die Anzahl der Zeilen mit Treffern ausgegeben wird.</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span>grep <span class="s2">"suchbegriff"</span> dateiname <span class="p">|</span> wc -l
</pre></div>
</td></tr></table></div><p>Das Programm <a class="internal" href="../shell/grep.html">grep</a> selber hat allerdings die Option die Anzahl der Trefferzeilen auszugeben.</p><p>Daher ist</p><div class="bash"><div class="contents"><pre class="notranslate">grep -c "suchbegriff" dateiname </pre></div></div><p>die bessere Lösung. Ausnahme:</p><div class="bash"><div class="contents"><pre class="notranslate">grep -o "suchbegriff" dateiname | wc -l </pre></div></div><p>Der Befehl</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span>grep -oc <span class="s2">"suchbegriff"</span> dateiname
</pre></div>
</td></tr></table></div><p>würde hier zu einem falschen Ergebnis führen. Überhaupt lohnt sich ein Blick in die Kommandozeilenoptionen von grep.</p></div><div class="section_2"><h3 id="Sinnloses-grep-awk">Sinnloses grep | awk<a class="headerlink" href="#Sinnloses-grep-awk">¶</a></h3><p>
<a class="internal" href="../awk.html">awk</a> wird von vielen überwiegend dazu verwendet, Spalten einer Logdatei (oder einer anderen Ausgabe) auszugeben.</p><p>Um die Zeilen zu finden, aus denen awk die Spalten ausgeben soll, wird meistens grep vorgeschaltet, so dass ein solches Konstrukt dabei entsteht:</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span>grep <span class="s2">"suchbegriff"</span> dateiname <span class="p">|</span> awk <span class="s1">'{ print $2 }'</span>
</pre></div>
</td></tr></table></div><p>Das gibt die zweite Spalte von Zeilen aus, die den Suchbegriff enthalten.</p><p>Da awk auch suchen kann, ist es aber sinnvoller</p><div class="bash"><div class="contents"><pre class="notranslate">awk '/suchbegriff/ { print $2 }' dateiname </pre></div></div><p>zu verwenden.</p></div><div class="section_2"><h3 id="Sinnloses-grep-sed">Sinnloses grep | sed<a class="headerlink" href="#Sinnloses-grep-sed">¶</a></h3><p>
Häufig werden aus Dateien mit grep die Zeilen gesucht, in denen man etwas mit <a class="internal" href="../sed.html">sed</a> suchen und ersetzen möchte.</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span>grep <span class="s2">"suchbegriff"</span> dateiname <span class="p">|</span> sed <span class="s1">'s/anderesuche/ersetzungstext/'</span>
</pre></div>
</td></tr></table></div><p>Da sed auch suchen kann, ist es aber sinnvoller</p><div class="bash"><div class="contents"><pre class="notranslate">sed '/suchbegriff/s/anderesuche/ersetzungstext/' dateiname </pre></div></div><p>
zu verwenden.</p></div><div class="section_2"><h3 id="Sinnloses-ps-grep">Sinnloses ps | grep<a class="headerlink" href="#Sinnloses-ps-grep">¶</a></h3><p>
Gerne wird der Aufruf 
</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span>ps aux <span class="p">|</span> grep ssh    <span class="c1"># als Beispiel wird das Programm ssh genutzt</span>
</pre></div>
</td></tr></table></div><p>
ausgeführt, um festzustellen ob ein Programm läuft bzw. welche PID es hat. Dieser Aufruf ist aus 2 Gründen nicht zu empfehlen: 1. Es werden zwei Programme für die Ergebnisaufstellung genutzt und 2. <code class="notranslate">grep</code> findet sich selbst ebenfalls in der Prozessliste und zeigt dies auch an. <br/><code class="notranslate">grep</code>-Kenner  wenden darum einen weiteren Trick an und es entstehen folgende Aufrufe
</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span>ps aux <span class="p">|</span> grep -v <span class="s2">"grep"</span> <span class="p">|</span>grep ssh  <span class="c1"># als Beispiel wird das Programm ssh genutzt</span>
<span class="c1"># oder mit der Kraft der regulären Ausdrücke</span>
ps aux <span class="p">|</span> grep <span class="o">[</span>s<span class="o">]</span>sh
</pre></div>
</td></tr></table></div><p>
um das <code class="notranslate">grep</code> wieder auszublenden.</p><p>All diese Eingaben sind nicht notwendig, denn unter Ubuntu gibt es das Programm <a class="internal" href="../pgrep.html">pgrep</a>, welches das viel kürzer kann:
</p><div class="bash"><div class="contents"><pre class="notranslate">pgrep -fl ssh </pre></div></div><p>bzw. um nur die PID zu ermitteln: 
</p><div class="bash"><div class="contents"><pre class="notranslate">pidof ssh </pre></div></div><p>oder mit <code class="notranslate">ps</code>-eigenen Mitteln: 
</p><div class="bash"><div class="contents"><pre class="notranslate">ps -C ssh </pre></div></div></div><div class="section_2"><h3 id="Sinnlose-Kommandosubstitution">Sinnlose Kommandosubstitution<a class="headerlink" href="#Sinnlose-Kommandosubstitution">¶</a></h3><p>
Ein Skript, in dem <code class="notranslate">$( ... )</code> vorkommt, oder die veralteten Backticks, kann man sehr häufig optimieren.</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="k">for</span> i in <span class="k">$(</span>cat dateiname<span class="k">)</span> <span class="p">;</span> <span class="k">do</span>
  ...
<span class="k">done</span>
</pre></div>
</td></tr></table></div><p>Lässt sich optimieren nach</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="k">while</span> <span class="nb">read</span> i <span class="p">;</span> <span class="k">do</span>
  ...
<span class="k">done</span> &lt; dateiname
</pre></div>
</td></tr></table></div><p>Wenn statt <code class="notranslate">cat dateiname</code> ein komplexerer Befehl benutzt wird, ist es besser statt</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="k">for</span> i in <span class="k">$(</span>komplexerer Befehl<span class="k">)</span> <span class="p">;</span> <span class="k">do</span>
  ...
<span class="k">done</span>
</pre></div>
</td></tr></table></div><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="k">while</span> <span class="nb">read</span> i <span class="p">;</span> <span class="k">do</span>
  ...
<span class="k">done</span>&lt; &lt;<span class="o">(</span>komplexer Befehl<span class="o">)</span>
</pre></div>
</td></tr></table></div><p>
zu schreiben.</p></div><div class="section_2"><h3 id="Sinnloses-test">Sinnloses test<a class="headerlink" href="#Sinnloses-test">¶</a></h3><p>
Es ist überflüssig</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span>kommando
<span class="k">if</span> <span class="o">[</span> <span class="nv">$?</span> -ne <span class="m">0</span> <span class="o">]</span> <span class="p">;</span> <span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">"fehler"</span>
  <span class="nb">exit</span> <span class="m">255</span>
<span class="k">fi</span>
</pre></div>
</td></tr></table></div><p>zu schreiben, wenn doch auch</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="k">if</span> ! kommando <span class="p">;</span> <span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">"fehler"</span>
  <span class="nb">exit</span> <span class="m">255</span>
<span class="k">fi</span>
</pre></div>
</td></tr></table></div><p>funktioniert.</p><p>In dem Zusammenhang noch ein gerne gemachter "Fehler" mit grep.</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span>grep <span class="s2">"suchbegriff"</span> datei &gt; /dev/null
<span class="k">if</span> <span class="o">[</span> <span class="nv">$?</span> -ne <span class="m">0</span> <span class="o">]</span> <span class="p">;</span> <span class="k">then</span>
</pre></div>
</td></tr></table></div><p>ist genauso wenig optimal wie</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="k">if</span> grep <span class="s2">"suchbegriff"</span> datei &gt; /dev/null <span class="p">;</span> <span class="k">then</span>
</pre></div>
</td></tr></table></div><p>weil es dafür "-q" gibt, welches die Suche beim ersten Treffer abbricht.</p><div class="bash"><div class="contents"><pre class="notranslate">if grep -q "suchbegriff" datei ; then </pre></div></div></div><div class="section_2"><h3 id="Regulaerer-Ausdruck-und">Regulärer Ausdruck und .*<a class="headerlink" href="#Regulaerer-Ausdruck-und">¶</a></h3><p>
(weitergehende Informationen gibt es unter <a class="internal" href="../grep.html">grep</a>)
</p><ul><li><p><code class="notranslate">.*</code> könnte man auch umschreiben mit "alles oder nichts". Das ist der reguläre Ausdruck, der immer wahr ist. </p></li><li><p><code class="notranslate">.</code> ist das Jokerzeichen, steht also für irgendein Zeichen. </p></li><li><p><code class="notranslate">*</code> steht für kein Mal oder beliebig oft. </p></li></ul><p>
Ein beliebiges Zeichen, kein Mal oder beliebig oft, trifft auf alles zu. Wenn statt des Sterns <code class="notranslate">*</code> ein Pluszeichen <code class="notranslate">+</code> verwendet wird, ergibt es Sinn. Das <code class="notranslate">+</code> steht für wenigstens ein Mal. Wird grep verwendet, muss noch ein Schrägstrich vor das Pluszeichen gesetzt werden: <code class="notranslate">\+</code>, und der gesamte reguläre Ausdruck muss auch dann gequotet werden, wenn er mit dem Stern nicht gequotet werden müsste. Bei egrep mit erweiterten regulären Ausdrücken ist dieses Escapen des Metazeichens nicht nötig.</p></div><div class="section_2"><h3 id="Sinnloses-dd-hexdump">Sinnloses dd | hexdump<a class="headerlink" href="#Sinnloses-dd-hexdump">¶</a></h3><p>
Häufig will man sich den MBR-Inhalt mittels <strong>hexdump</strong> ansehen, dabei werden dann Kombinationen mit <a class="internal" href="../shell/dd.html">dd</a> und einer Pipe gebaut, das ist nicht nötig: hexdump kann man einen Startwert und ein Anzahl der auszuwerteten Bytes mitgeben. Sollte die Platte mit logischen Sektoren ungleich 512 Bytes eingerichtet sein, dann müssen die Werte natürlich auf diese abgestellt werden. </p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span>sudo dd <span class="k">if</span>/dev/sda <span class="nv">count</span><span class="o">=</span><span class="m">1</span><span class="p">|</span> hexdump -C
</pre></div>
</td></tr></table></div><p>Beispiele:</p><p>Andruck des MBR der Festplatte <strong>/dev/sda</strong>:
</p><div class="bash"><div class="contents"><pre class="notranslate">sudo hexdump -s0 -n512 -C /dev/sda </pre></div></div><p> Dabei beschreibt <em>s</em> den Start (0 Byte) und <em>n</em> die Anzahl der zu druckenden Bytes (512 = MBR). Mit <em>-C</em> wird der Canonical-Modus eingeschlatet (Hex und mögliche Klarschrift).</p><p>Hier wird der GPT-Header (LBA 1) angedruckt:
</p><div class="bash"><div class="contents"><pre class="notranslate">sudo hexdump -s512 -n512 -C /dev/sda </pre></div></div></div></div><div class="section_1"><h2 id="Tricks">Tricks<a class="headerlink" href="#Tricks">¶</a></h2><p>
</p><div class="section_2"><h3 id="Leeren-einer-Datei">Leeren einer Datei<a class="headerlink" href="#Leeren-einer-Datei">¶</a></h3><p>
Man kann eine Datei namens <strong>dateiname</strong> mittels</p><div class="bash"><div class="contents"><pre class="notranslate">&gt; dateiname </pre></div></div><p>leeren.</p><p>Vorteil: Der Dateihandle ändert sich nicht. Was bedeutet, dass ein Programm, das die Datei als Logdatei benutzt, dort weiterhin hineinschreiben kann, ohne neu gestartet werden zu müssen (Beispiel Serverdienste und deren Logdateien).</p></div><div class="section_2"><h3 id="Vermeidung-von-read-und-Pipe">Vermeidung von <code class="notranslate">read</code> und Pipe<a class="headerlink" href="#Vermeidung-von-read-und-Pipe">¶</a></h3><p>
In den meisten Shells wird jedes Kommando einer Pipe in einer separaten Shell (Sub-Shell) ausgeführt, dadurch stehen die bearbeiteten Variablen anschließend im Eltern-Prozess nicht mehr zur Verfügung. Das folgende Beispiel veranschaulicht dies:</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="c1"># printf übergibt 2 Zeilen die mittels read gezählt werden</span>
<span class="nv">Zaehler</span><span class="o">=</span><span class="m">0</span>
<span class="nb">printf</span> <span class="s2">"%s\n"</span> foo bar  <span class="p">|</span> <span class="k">while</span> <span class="nb">read</span> -r line
<span class="k">do</span>
    <span class="nv">Zaehler</span><span class="o">=</span><span class="k">$((</span>Zaehler+1<span class="k">))</span>
    <span class="nb">echo</span> <span class="s2">"Zaehler in der Schleife: </span><span class="nv">$Zaehler</span><span class="s2">"</span>  <span class="c1"># Ausgabe 2</span>
<span class="k">done</span>
<span class="nb">echo</span> <span class="s2">"Zaehler nach der Schleife: </span><span class="nv">$Zaehler</span><span class="s2">"</span>    <span class="c1"># Ausgabe 0</span>
</pre></div>
</td></tr></table></div><p>Das gleiche Problem tritt auch ohne Schleife auf</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="nv">Zaehler</span><span class="o">=</span><span class="m">0</span>
<span class="nb">echo</span> <span class="m">2</span> <span class="p">|</span> <span class="nb">read</span> -r Zaehler
<span class="nb">echo</span> <span class="s2">"echo übergab 2, aber jetzt beinhaltet der Zaehler: </span><span class="nv">$Zaehler</span><span class="s2">, also 0"</span> 
</pre></div>
</td></tr></table></div><p>Um dieses Verhalten zu umgehen, sollte man read mittels Prozess-Substitution aufrufen.</p><p>
</p><table><tr class="titel"><td colspan="2"> Dabei kommt dem <code class="notranslate">&lt;</code> eine besondere Bedeutung zu: </td></tr><tr><td> <code class="notranslate">&lt;</code> <strong>irgendeineDatei</strong> </td><td> lesen der Daten aus der Datei <strong>irgendeineDatei</strong> </td></tr><tr><td> <code class="notranslate">&lt; &lt;(Kommando/Kommandokette)</code> </td><td> lesen der Daten aus der Ausgabe eines Kommandos oder einer Kommandokette </td></tr><tr><td> <code class="notranslate">&lt;&lt;&lt;"$Variable"</code> </td><td> lesen der Daten aus einer vorher befüllten Variable </td></tr></table><p>Hier nun die korrekten Beispiele:
</p><div class="section_3"><h4 id="read-liest-die-Zeilen-aus-einer-Datei"><code class="notranslate">read</code> liest die Zeilen aus einer Datei<a class="headerlink" href="#read-liest-die-Zeilen-aus-einer-Datei">¶</a></h4><p>
</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="nv">Zaehler</span><span class="o">=</span><span class="m">0</span>
<span class="k">while</span> <span class="nb">read</span> -r line
<span class="k">do</span>
    <span class="nv">Zaehler</span><span class="o">=</span><span class="k">$((</span>Zaehler+1<span class="k">))</span>
    <span class="nb">echo</span> <span class="s2">"Zaehler in der Schleife: </span><span class="nv">$Zaehler</span><span class="s2">"</span>
<span class="k">done</span> &lt; irgendeineDatei
<span class="nb">echo</span> <span class="s2">"Zaehler nach der Schleife: </span><span class="nv">$Zaehler</span><span class="s2">"</span> 
</pre></div>
</td></tr></table></div></div><div class="section_3"><h4 id="read-liest-die-Zeilen-aus-einem-Kommando-bzw-Kommandokette"><code class="notranslate">read</code> liest die Zeilen aus einem Kommando bzw. Kommandokette<a class="headerlink" href="#read-liest-die-Zeilen-aus-einem-Kommando-bzw-Kommandokette">¶</a></h4><p>
</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="nv">Zaehler</span><span class="o">=</span><span class="m">0</span>
<span class="k">while</span> <span class="nb">read</span> -r line
<span class="k">do</span>
    <span class="nv">Zaehler</span><span class="o">=</span><span class="k">$((</span>Zaehler+1<span class="k">))</span>
    <span class="nb">echo</span> <span class="s2">"Zaehler in der Schleife: </span><span class="nv">$Zaehler</span><span class="s2">"</span>
<span class="k">done</span> &lt; &lt;<span class="o">(</span>cat Datei1 Datei2<span class="o">)</span>
<span class="nb">echo</span> <span class="s2">"Zaehler nach der Schleife: </span><span class="nv">$Zaehler</span><span class="s2">"</span> 
</pre></div>
</td></tr></table></div><p><a class="crosslink anchor" href="#read-Variable" id="read-Variable"></a>
</p></div><div class="section_3"><h4 id="read-liest-die-Zeilen-aus-einer-vorher-befuellten-Variable"><code class="notranslate">read</code> liest die Zeilen aus einer vorher befüllten Variable<a class="headerlink" href="#read-liest-die-Zeilen-aus-einer-vorher-befuellten-Variable">¶</a></h4><p>
</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="nv">Variable</span><span class="o">=</span><span class="k">$(</span><span class="nb">printf</span> <span class="s2">"%s\n"</span> foo bar usw ...<span class="k">)</span>
<span class="nv">Zaehler</span><span class="o">=</span><span class="m">0</span>
<span class="k">while</span> <span class="nb">read</span> -r line
<span class="k">do</span>
    <span class="nv">Zaehler</span><span class="o">=</span><span class="k">$((</span>Zaehler+1<span class="k">))</span>
    <span class="nb">echo</span> <span class="s2">"Zaehler in der Schleife: </span><span class="nv">$Zaehler</span><span class="s2">"</span>
<span class="k">done</span> <span class="o">&lt;&lt;&lt;</span><span class="s2">"</span><span class="nv">$Variable</span><span class="s2">"</span>
<span class="nb">echo</span> <span class="s2">"Zaehler nach der Schleife: </span><span class="nv">$Zaehler</span><span class="s2">"</span> 
</pre></div>
</td></tr></table></div><p>multiple Aufrufe von "&lt;()" können dabei so aussehen:
</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span>diff &lt;<span class="o">(</span><span class="nb">echo</span> <span class="s2">"foo"</span><span class="o">)</span> &lt;<span class="o">(</span><span class="nb">echo</span> <span class="s2">"fool"</span><span class="o">)</span>
</pre></div>
</td></tr></table></div><p>Noch ein Hinweis zum Schluss: <code class="notranslate">read</code> liest standardmäßig Zeilen ein, reagiert also auf ein <code class="notranslate">\n</code> (newline). Will man dies beeinflussen,  kann man das mit der Option <code class="notranslate">-d delim</code> bewirken. Mehr dazu unter <a class="internal" href="../man.html">man</a> <strong>bash-builtins read</strong></p></div></div><div class="section_2"><h3 id="Kopieren-mit-tar-und-ssh">Kopieren mit tar und ssh<a class="headerlink" href="#Kopieren-mit-tar-und-ssh">¶</a></h3><p>
Wenig bekannt ist, dass <a class="internal" href="../ssh.html">SSH</a> auch Standardeingabe und Standardausgabe verwenden kann. Damit ist es möglich via</p><div class="bash"><div class="contents"><pre class="notranslate">tar cf - &lt;dateien oder verzeichnisse&gt; | ssh &lt;user&gt;@&lt;zielhost&gt; "cd &lt;zielverzeichnis&gt; &amp;&amp; tar xf -" </pre></div></div><p><code class="notranslate">&lt;dateien oder verzeichnisse&gt;</code> vom aktuellen Rechner ins <code class="notranslate">&lt;zielverzeichnis&gt;</code> auf dem <code class="notranslate">&lt;zielhost&gt;</code> als <code class="notranslate">&lt;user&gt;</code> zu kopieren. Das "-"-Zeichen bei <code class="notranslate">tar cf</code> sorgt dafür, dass <a class="internal" href="../tar.html">tar</a> seinen Datenstrom in Richtung Standardausgabe schickt, die wird mittels "<code class="notranslate">|</code>" umgelenkt auf den ssh-Befehl, in dem wiederum <code class="notranslate">tar xf -</code> die Daten von der Standardeingabe liest.</p><p>Das ist noch nichts spektakuläres. Das kann <code class="notranslate">scp</code> auch. Allerdings überträgt <code class="notranslate">scp</code> - auch mit der Option <code class="notranslate">-p</code> - keine Dateieigentümerschaften und löst symbolische Links auf, anstatt sie 1:1 zu übertragen. Deswegen ist <code class="notranslate">scp</code> für das exakte Klonen eines Verzeichnisbaums ungeeignet.</p><p>Zusammen mit dem Paket <strong>buffer</strong> (aus <em>universe</em>) kann man den Datentransfer außerdem gerade bei sehr vielen kleinen Dateien beschleunigen.</p><div class="bash"><div class="contents"><pre class="notranslate">tar cf - &lt;dateien oder verzeichnisse&gt; | buffer -m 10m | ssh &lt;user&gt;@&lt;zielhost&gt; "cd &lt;zielverzeichnis&gt; &amp;&amp; tar xf -" </pre></div></div><p>Das <code class="notranslate">buffer -m 10m</code> sorgt dafür, dass ein Puffer von 10 Megabytes eingerichtet wird.</p></div><div class="section_2"><h3 id="Speichern-von-Befehlen">Speichern von Befehlen<a class="headerlink" href="#Speichern-von-Befehlen">¶</a></h3><p>
Manchmal speichert man einen Befehl in einer Variablen, um ihn später an
mehreren Stellen aufzurufen:
</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="ch">#!/bin/bash</span>

<span class="nv">cmd</span><span class="o">=</span><span class="s2">"vim"</span>

<span class="c1"># ...</span>

<span class="nv">$cmd</span> foo
<span class="nv">$cmd</span> bar
</pre></div>
</td></tr></table></div><p>Das hat den Vorteil, dass man den Befehl bei Bedarf nur an einer Stelle
ändern muss. Möchte man den Befehl nun um Parameter erweitern, dann geht
das im einfachsten Fall gerade noch:
</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="nv">cmd</span><span class="o">=</span><span class="s2">"vim -p"</span>
</pre></div>
</td></tr></table></div><p>Gemäß den Regeln des „word splitting“ werden hieraus die beiden
Argumente „<code class="notranslate">vim</code>“ und „<code class="notranslate">-p</code>“.</p><p>Was aber, wenn man den Befehl so erweitern möchte, dass er eigentlich
Anführungszeichen benötigen würde? Folgendes Beispiel funktioniert
<em>nicht</em>:
</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="c1"># Falsch!</span>
<span class="nv">cmd</span><span class="o">=</span><span class="s2">"vim -c \"set number\""</span>
</pre></div>
</td></tr></table></div><p>Der Knackpunkt ist, dass die inneren Anführungszeichen hier nicht wie
vielleicht erwartet ausgewertet werden. Es entsteht folgende Liste an
Argumenten:
</p><pre class="notranslate">vim
-c
"set
number"</pre><p>Auch der Aufruf mit äußeren Anführungszeichen über
</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="s2">"</span><span class="nv">$cmd</span><span class="s2">"</span> foo
</pre></div>
</td></tr></table></div><p>schlägt fehl – in diesem Fall wird versucht, „<code class="notranslate">vim -c "set number"</code>“
aufzurufen und zwar als ein einziges Argument gesehen. Eine Datei mit
dem Namen „<code class="notranslate">vim -c "set number"</code>“ gibt es natürlich nicht.</p><p>Man müsste den String eigentlich zweimal auswerten, um die inneren
Anführungszeichen zu berücksichtigen (das ginge mit „<code class="notranslate">eval</code>“), was aber
fehleranfällig ist und <a class="external" href="http://mywiki.wooledge.org/BashFAQ/048" rel="nofollow">aus guten
Gründen</a> <img alt="{en}" src="../_/d5ecf89114b079f85d02099649c4ee617ffa34c7.png"/> vermieden werden muss.</p><p>Der bevorzugte Weg, das Problem zu lösen, ist, eine Funktion zu
definieren und diese statt des eigentlichen Befehls aufzurufen:
</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="ch">#!/bin/bash</span>

cmd<span class="o">()</span>
<span class="o">{</span>
	vim -c <span class="s2">"set number"</span> <span class="s2">"</span><span class="nv">$@</span><span class="s2">"</span>
<span class="o">}</span>

<span class="c1"># ...</span>

cmd foo
</pre></div>
</td></tr></table></div><p>Funktionen sind dafür gedacht, Code zu enthalten – Variablen sollen
Daten enthalten. Darüberhinaus ermöglicht dieser Ansatz auch komplexere
Befehle, die Pipes oder Umleitungen enthalten:
</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="ch">#!/bin/bash</span>

cmd<span class="o">()</span>
<span class="o">{</span>
	du <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="p">|</span> sort -n &gt; /tmp/verzeichnisgroessen
<span class="o">}</span>

<span class="c1"># ...</span>

cmd foo
</pre></div>
</td></tr></table></div><p>Lesenswertes dazu:
</p><ul><li><p><a class="external" href="http://mywiki.wooledge.org/BashFAQ/050" rel="nofollow">Eintrag in Greg's Wiki zu dem Thema</a> <img alt="{en}" src="../_/d5ecf89114b079f85d02099649c4ee617ffa34c7.png"/></p></li><li><p><a class="external" href="http://www.gnu.org/software/bash/manual/bashref.html#Shell-Functions" rel="nofollow">Funktionen im Bash-Handbuch</a> <img alt="{en}" src="../_/d5ecf89114b079f85d02099649c4ee617ffa34c7.png"/></p></li></ul><p>
</p></div><div class="section_2"><h3 id="Befehle-wiederholen-Stapelverarbeitung-Batch-Processing">Befehle wiederholen: Stapelverarbeitung (Batch Processing)<a class="headerlink" href="#Befehle-wiederholen-Stapelverarbeitung-Batch-Processing">¶</a></h3><p>
Das Ausführen derselben Operation auf verschiedene Dateien ist generell nützlich, wenn das jeweilige Programm dies von Haus aus nicht beherrscht. Allgemeines Schema:</p><div class="bash"><div class="contents"><pre class="notranslate">for i in *.ALT; do PROGRAMM "$i" -o "`basename "$i" .ALT` .NEU"; done </pre></div></div><p>Hier findet vor dem ersten Semikolon die Auswahl der Dateien (<code class="notranslate">*.ALT</code>) im Arbeitsverzeichnis der Shell statt. Alles nach dem "<code class="notranslate">do</code>" und bis zum zweiten Semikolon ist die spezifische Anwendung eines Programms (<code class="notranslate">PROGRAMM</code>) mit dessen jeweiliger Befehlssyntax. "<code class="notranslate">$i</code>" (oder "<code class="notranslate">$f</code>", siehe unten) stellen die zu verwendeten Dateien dar. Beispiele:</p><ul><li><p>Entpacken aller <strong>.zip</strong>-Dateien im aktuellen Verzeichnis: </p><div class="bash"><div class="contents"><pre class="notranslate">for f in *.ZIP; do unzip “$f”; done </pre></div></div></li><li><p>Konvertieren aller <strong>.jpg</strong>-Bilder  im aktuellen Verzeichnis: </p><div class="bash"><div class="contents"><pre class="notranslate">for f in *.jpg; do convert "$f" -background white -chop 100x0+1320+0 -splice 100x0+1320+0  "${f%}_sauber.jpg"; done </pre></div></div></li></ul><p>Für eine Lösung in Kombination mit <a class="internal" href="../find.html">find</a> siehe <a class="internal" href="../audiodateien_umwandeln.html#Mehrere-Dateien-auf-einmal-umwandeln-mit-Unterverzeichnissen">Audiodateien umwandeln</a>.</p></div><div class="section_2"><h3 id="Tabellen-zur-Weiterverarbeitung-umwandeln">Tabellen zur Weiterverarbeitung umwandeln<a class="headerlink" href="#Tabellen-zur-Weiterverarbeitung-umwandeln">¶</a></h3><p>
Nicht selten kommt es vor, dass Tabellen zur bündigen Darstellung keine Tabulatorzeichen verwenden, sondern der Zwischenraum mit unterschiedlich vielen Leerzeichen aufgefüllt wird (Beispiel: die Ausgabe von <code class="notranslate">ls -l</code>). Um diese beispielsweise mit <code class="notranslate">cut</code> weiterverarbeiten zu können, benötigt man ein Format, das zwischen den Feldern je genau einen Feldtrenner enthält. Abhilfe schafft hier der folgende Befehl:
</p><div class="bash"><div class="contents"><pre class="notranslate">tr -s "[:space:]" </pre></div></div><p>Beispiel, mit dem man auswerten kann, an welchen Tagen in einem Verzeichnis Änderungen vorgenommen wurden:
</p><div class="bash"><div class="contents"><pre class="notranslate">ls -l --time-style=long-iso | tr -s "[:space:]" | cut -f6 -d" " | sort -u </pre></div></div></div></div><div class="section_1"><h2 id="Links">Links<a class="headerlink" href="#Links">¶</a></h2><p>
</p><ul><li><p><a class="internal" href="../shellcheck.html">ShellCheck</a> - Befehlszeilenwerkzeug zur Analyse von Shell- und Bash-Skripten</p></li><li><p><a class="external" href="http://mywiki.wooledge.org/BashPitfalls" rel="nofollow">Pitfalls</a> <img alt="{en}" src="../_/d5ecf89114b079f85d02099649c4ee617ffa34c7.png"/> - Fallstricke auf Greg's Wiki</p></li><li><p><a class="external" href="http://web.archive.org/web/20140415205935/http://partmaps.org/era/unix/award.html" rel="nofollow">Useless Use of Cat Award</a> <img alt="{en}" src="../_/d5ecf89114b079f85d02099649c4ee617ffa34c7.png"/> (Original existiert nicht mehr, deshalb hier die letzte Version von 2014 bei archive.org)</p></li></ul><p>
</p></div></div>
<p class="meta">
<a href="../shell/tipps_und_tricks/a/revision/908678.html">Diese Revision</a> wurde am 19. September 2016 11:17 von <a href="https://ubuntuusers.de/user/BillMaier/">BillMaier</a> erstellt.
    
  </p>
</div>
</div>
<div style="clear: both;"></div>
<div class="pathbar breadcrumb">
<div class="breadcrumb">
<ol>
<li><a href="../startseite.html">Wiki</a></li>
<li><a href="../shell.html">Shell</a></li>
<li><a href="../shell/tipps_und_tricks.html">Tipps und Tricks</a></li>
</ol>
</div>
</div>
</div>
<div class="footer" style="clear: both;">
<ul>
<li class="poweredby"><li class="poweredby">Erstellt mit <a href="http://inyokaproject.org/">Inyoka</a></li></li>
<li class="license">

<img alt="Copyleft" src="../_/65dad5b770326dbbe1bd26ee6363e366a76bd8b7.png"/>
          2004 – 2017 ubuntuusers.de • Einige Rechte vorbehalten<br/>
<a href="../_lizenz.html" rel="cc:morePermissions">Lizenz</a> •
          <a href="http://ubuntuusers.de/kontakt/">Kontakt</a> •
          <a href="http://ubuntuusers.de/datenschutz/">Datenschutz</a> •
          <a href="http://ubuntuusers.de/impressum/">Impressum</a> •
          <a href="https://ubuntuusers.statuspage.io">Serverstatus</a>
</li>
<li class="housing">
<span title="Unterbringung und Netzanbindung eines Servers">Serverhousing</span> gespendet von<br/>
<img alt="noris network" src="../_/e7d27e9081eec23a8a5a5fe9434d7b2f1532e1d9.png"/>
<img alt="anexia" src="../_/ad1b63a3fc35749344af0a03e8c3ce05a2a3ee7e.png"/>
</li>
</ul>
</div>
<div style="clear: both;"></div>
</div>






</body>
</html>