<!DOCTYPE html>
<html lang="">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>AVR › ubuntuusers statisches Wiki</title>
<link href="./_/34e5d78db234405457773cc26741aada99f7fff2.css" rel="stylesheet" type="text/css"/>
<link href="./_/61af784fc5c93e296fec3be63b8e0bb48443727c.css" rel="stylesheet" type="text/css"/>
<link href="./_/634e8d1015b02df998cdec7cb07c5aff61d068b5.css" rel="stylesheet" type="text/css"/>
<link href="./_/b583ff7e37147497a59224ccf54cfee812a1d21b.css" rel="stylesheet" type="text/css"/>
<link href="./_/a0d5775ed6f36f8cc5b12bcf2f1c1bd98a3eb225.css" rel="stylesheet" type="text/css"/>
<link href="./_/98de73bded109a634cbd1e924abdd8c8964b8df2.css" media="print" rel="stylesheet" type="text/css"/>

<meta content="#a87300" name="theme-color"/>

</head>
<body>
<div class="wrap">
<div class="header">
<h1><a href="http://ubuntuusers.de/"><span>ubuntuusers.de</span></a></h1>
<ul class="tabbar">
<li class="portal">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://ubuntuusers.de/">Portal<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="forum">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://forum.ubuntuusers.de/">Forum<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="wiki active">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://wiki.ubuntuusers.de/">Wiki<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="ikhaya">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://ikhaya.ubuntuusers.de/">Ikhaya<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="planet">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://planet.ubuntuusers.de/">Planet<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="community">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://wiki.ubuntuusers.de/Mitmachen">Mitmachen<span></span></a></div>
<div class="tab_right"></div>
</li>
</ul>
</div>
<div class="body">
<div class="appheader">

<div class="pagetitle">
<h1 class="breadcrumb_title">
<a class="separator" href="./startseite.html">
              Wiki
            </a>
</h1>
<h2 class="breadcrumb_subtitle"><a href="./avr.html">AVR</a></h2>
</div>
</div><div class="message staticwikinote"><strong>Hinweis:</strong> Dies ist ein statischer Snapshot unseres Wikis vom Jan. 17, 2018 und kann daher nicht bearbeitet werden. Der aktuelle Artikel ist unter <a href="http://wiki.ubuntuusers.de/AVR">wiki.ubuntuusers.de</a> zu finden.</div>

<!--[if lt IE 8]>
      <div class="message fail">Bitte installiere den Internet Explorer 8 oder neuer.</div>
      <![endif]-->
<div class="page_content">
<div class="navi_sidebar navigation">
<div class="container">
<h3 class="navi_wiki">Wiki</h3>
<ul>
<li><a href="./wiki/index.html">Index</a></li>
<li><a href="./wiki/recentchanges.html">Letzte Änderungen</a></li>
<li><a href="./wiki/neue_artikel.html">Liste neuer Artikel</a></li>
<li><a href="./wiki.html">Übersicht</a></li>
<li><a href="./wiki/faq_-_häufig_gestellte_fragen.html">FAQ</a></li>
<li><a href="./wiki/benutzung.html">Benutzung</a></li>
<li><a href="./kategorien.html">Kategorie</a></li>
<li><a href="./wiki/tagcloud.html">Wortwolke</a></li>
</ul>
<h3 class="navi_join">Mitmachen</h3>
<ul>
<li><a href="./wikiartikel_anlegen.html">Wikiartikel anlegen</a></li>
<li><a href="./howto.html">Howto anlegen</a></li>
<li><a href="./wiki/referenz.html">Wiki-Referenz</a></li>
<li><a href="./wiki/syntax.html">Wiki-Syntax</a></li>
<li><a href="./baustelle.html">Baustellen</a></li>
<li><a href="./wiki/artikelideen.html">Artikelideen</a></li>
<li><a href="./wiki/ungetestet.html">Ungetestete Artikel</a></li>
<li><a href="./wiki/vorlagen/ausbaufähig/a/backlinks.html">Ausbaufähige Artikel</a></li>
<li><a href="./wiki/vorlagen/fehlerhaft/a/backlinks.html">Fehlerhafte Artikel</a></li>
<li><a href="https://forum.ubuntuusers.de/forum/wiki/">Rund ums Wiki</a></li>
</ul>
<h3 class="navi_config">Konfiguration</h3>
<ul>
<li><a href="./avr/a/backlinks.html">Backlinks anzeigen</a></li>
<li>
        Exportieren
        <ul>
<li><a href="./avr/a/export/meta.html" rel="nofollow">Metadaten</a></li>
<li><a href="./avr/a/export/raw.html" rel="nofollow">Rohformat</a></li>
<li><a href="./avr/a/export/html.html" rel="nofollow">HTML</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div class="content content_tabbar content_sidebar">
<h1 class="pagetitle"><a href="./avr/a/backlinks.html">AVR</a></h1>
<div id="page"><p>
</p><div class="box tested_for"><h3 class="box tested_for">Dieser Artikel wurde für die folgenden
Ubuntu-Versionen getestet:</h3><div class="contents"><p>
</p><ul><li><p><a class="internal" href="./xenial_xerus.html">Ubuntu 16.04</a> Xenial Xerus</p></li></ul></div></div><p>
</p><p>
</p><div class="box knowledge"><h3 class="box knowledge">Zum Verständnis dieses Artikels sind folgende Seiten hilfreich:</h3><div class="contents"><p>
</p><ol class="arabic"><li><p><a class="crosslink anchor" href="#source-1" id="source-1"></a> <a class="internal" href="./pakete_installieren.html">Installation von Programmen</a></p></li><li><p><a class="crosslink anchor" href="#source-2" id="source-2"></a> <a class="internal" href="./terminal.html">Ein Terminal öffnen</a></p></li><li><p><a class="crosslink anchor" href="#source-3" id="source-3"></a> <a class="internal" href="./sudo.html">Root-Rechte</a></p></li></ol></div></div><p>
</p><div class="toc toc-depth-1"><div class="head">Inhaltsverzeichnis</div><ol class="arabic"><li><a class="crosslink" href="#Praktischer-Aufbau">Praktischer Aufbau
</a></li><li><a class="crosslink" href="#Programmierung-in-Assembler">Programmierung in Assembler
</a></li><li><a class="crosslink" href="#Programmierung-in-C">Programmierung in C
</a></li><li><a class="crosslink" href="#Debugmoeglichkeiten">Debugmöglichkeiten
</a></li><li><a class="crosslink" href="#Fehlerbehandlung">Fehlerbehandlung
</a></li><li><a class="crosslink" href="#Links">Links
</a></li></ol></div><p><a class="interwiki interwiki-wikipedia" href="https://de.wikipedia.org/wiki/Atmel_AVR">AVR</a> sind Mikrocontroller der Firma <a class="external" href="http://www.atmel.com/products/microcontrollers/avr/default.aspx" rel="nofollow">Atmel</a> <img alt="{en}" src="./_/d5ecf89114b079f85d02099649c4ee617ffa34c7.png"/>, die sich vor allem im Hobbybereich großer Beliebtheit erfreuen. AVR sind 8 Bit <a class="interwiki interwiki-wikipedia" href="https://de.wikipedia.org/wiki/RISC">RISC</a> Mikrocontroller. Weiterhin gibt es noch die <a class="external" href="http://www.atmel.com/products/microcontrollers/avr/32-bitavruc3.aspx" rel="nofollow">AVR32</a> <img alt="{en}" src="./_/d5ecf89114b079f85d02099649c4ee617ffa34c7.png"/> mit 32 Bit Datenbreite, welche aber bis auf die Bezeichnung nichts mit den AVRs gemeinsam haben.</p><p>Die Typen <a class="external" href="http://www.atmel.com/products/microcontrollers/avr/tinyavr.aspx" rel="nofollow">ATtiny</a> <img alt="{en}" src="./_/d5ecf89114b079f85d02099649c4ee617ffa34c7.png"/>, <a class="external" href="http://www.atmel.com/products/microcontrollers/avr/megaavr.aspx" rel="nofollow">ATmega</a> <img alt="{en}" src="./_/d5ecf89114b079f85d02099649c4ee617ffa34c7.png"/> und AT90 unterscheiden sich in Gehäusegröße und Peripherieausstattung. Der neueste Typ ist die Familie <a class="external" href="http://www.atmel.com/products/microcontrollers/avr/avr_xmega.aspx" rel="nofollow">Xmega</a> <img alt="{en}" src="./_/d5ecf89114b079f85d02099649c4ee617ffa34c7.png"/>, welche mehr Rechenleistung und komplett überarbeitete Peripheriemodule bietet.</p><div class="section_1"><h2 id="Praktischer-Aufbau">Praktischer Aufbau<a class="headerlink" href="#Praktischer-Aufbau">¶</a></h2><p>
Ein kompletter Aufbau zum Programmieren und Testen von AVR-Mikrocontrollern könnte folgendermaßen aussehen:</p><p><img alt="AVR_Grundschaltung_Schema.png" class="image-default" src="./_/dd417b35cbfd19b4eb6a79ae9c9762865d1e0287.png"/></p><p>Wie auf dem Bild zu sehen, werden die folgenden Komponenten benötigt:</p><ul><li><p>Ein Computer, auf dem das Programm geschrieben wird (siehe <a class="crosslink" href="#Programmierung-in-Assembler">Programmierung in Assembler</a> und <a class="crosslink" href="#Programmierung-in-C">Programmierung in C</a>)</p></li><li><p>Ein Programmer, der den Adapter zwischen Mikrocontroller und Computer bildet (siehe <a class="crosslink" href="#Programmierwerkzeug">Programmierwerkzeug</a>)</p></li><li><p>Eine Platine mit dem Mikrocontroller und Peripherie darauf (siehe <a class="crosslink" href="#Grundschaltungen">Grundschaltungen</a>)</p></li><li><p>Ein Netzteil – sofern die Schaltung nicht per USB-Anschluss mit Strom versorgt wird</p></li></ul><p>
Diese Komponenten werden nachfolgend einzeln erklärt.</p><div class="section_2"><h3 id="Grundschaltungen">Grundschaltungen<a class="headerlink" href="#Grundschaltungen">¶</a></h3><p>
</p><p>
</p><table style="float: right; clear: left; margin-top: 0px; border: none"><tr class="titel"><td> <img alt="avr_beispiel_Steckplatine.png" class="image-default" src="./_/2674499cced6f3181122220f7792dcee558035b4.png"/></td></tr><tr class="normal"><td style="text-align: center; width: 200px"> Beispielaufbau auf einer Steckplatine</td></tr></table><p>
</p><p>
</p><table style="float: right; clear: left; margin-top: 0px; border: none"><tr class="titel"><td> <img alt="avr_beispiel_Schaltplan.png" class="image-default" src="./_/3278b21e41b2b7e168517f9a1a614365f3a7414d.png"/></td></tr><tr class="normal"><td style="text-align: center; width: 200px"> Minimalbeschaltung eines ATtiny13A mit LED</td></tr></table><p>
Empfohlene Mindestanforderungen, um einen AVR-Controller zu betreiben, sind:</p><ul><li><p>5V Betriebsspannung (viele AVR erlauben auch andere Spannungen: z.B. 3.3V. Am besten das Datenblatt konsultieren)</p></li><li><p>ein 100-nF-Kondensator möglichst direkt an den Versorgungspins (VCC und GND) des Controllers</p></li></ul><p>Da solch eine Schaltung noch nicht sehr viel Interessantes bietet, sollten folgende Komponenten hinzugefügt werden:</p><ul><li><p>Eine Buchse zum Aufspielen des Programms auf den Mikrocontroller (üblich ist hier ein 6- oder 10-poliger Wannenstecker)</p></li><li><p>Pull-up-Widerstand (z.B. 10 kOhm) und Taster für den Reset</p></li><li><p>Etwas Peripherie, z.B.:</p><ul><li><p>Leuchtdioden (Widerstand in Reihe schalten, z.B. 470 Ohm)</p></li><li><p>Taster</p></li><li><p>Potenziometer</p></li></ul></li></ul><p>
Die Schaltung kann auf einer Lochrasterplatine oder auf einem Steckbrett aufgebaut werden. Alternativ kann man auch fertige Experimentierboards verwenden.</p></div><div class="section_2"><h3 id="Programmierwerkzeug">Programmierwerkzeug<a class="headerlink" href="#Programmierwerkzeug">¶</a></h3><p>
Um das Programm auf den Mikrocontroller zu übertragen, muss der Computer mit jenem verbunden werden. Vor ein paar Jahren war es noch aktuell, die Controller direkt mit der seriellen oder parallelen Schnittstelle des Computers zu programmieren. Da es kaum noch Computer mit "echter" serieller oder Paralleler Schnittstelle gibt und sich die meisten USB-Seriell-Adapter bzw. USB-Parallel-Adapter für diesen Zweck als ungeeignet erwiesen, ist es meist besser, nur noch auf die neueren Programmer mit eigenem USB-Anschluss zu setzen.</p><p>Solche Programmer für die USB-Schnittstelle sind als Original-Atmel-Zubehör erhältlich, man findet sich aber auch sehr preisgünstig über Internet-Auktionen. Außerdem gibt es sehr viele Anleitungen für den Eigenbau. Ein sehr populäres Beispiel ist der "USBasp" von <a class="external" href="http://www.fischl.de/usbasp/" rel="nofollow">fischl.de</a> <img alt="{en}" src="./_/d5ecf89114b079f85d02099649c4ee617ffa34c7.png"/>, der ebenfalls als Bausatz erhältlich ist. Hier als Originalschaltung mit Gehäuse und als Minimal-Aufbau auf einer Steckplatine:</p><p><img alt="UsbAsp" class="image-default" src="./_/82e1fd2652e2acf822e2b4d7bbd62137db729074.png"/> <img alt="USBasp_t85_aufbau.jpg" class="image-default" src="./_/5809667c802cfffdf8836fa9bf35309010627051.png"/></p><p>Die zweite Variante ist eine Weiterentwicklung des originalen USBasp und sowohl als Platinenversion als auch als Breadboardversion unter dem Namen "guloprog" bekannt. Da für den Minimalaufbau nur sechs Bauteile benötigt werden, ist der Nachbau sehr einfach. Die Firmware ist quelloffen und kann über die URL <a class="external" href="https://guloshop.de/f/sources/" rel="nofollow" title="https://guloshop.de/f/sources/">https://guloshop.de/f/sources/</a> <img alt="{dl}" src="./_/8e630211d0f5f5cb7c6424055f9c9aa15a420fab.png"/> heruntergeladen werden.</p><p>Wer trotzdem einen fertigen Programmer verwenden möchte, findet neben den Geräten von Atmel ein vielfältiges und preiswertes Angebot vor. Ein Beispiel wäre "mySmartUSB light", der bei fast allen Elektronikversandhändlern erhältlich ist. Es gibt auch Boards, die sowohl eine Grundschaltung mit viel Peripherie zum experimentieren, als auch einen Programmer beinhalten. Das hat den Vorteil, dass man nur ein Board mit dem Computer verbinden muss und die Fehlerquellen minimiert werden. Ein Beispiel für solch ein Board ist der "EasyAVR6":</p></div></div><div class="section_1"><h2 id="Programmierung-in-Assembler">Programmierung in Assembler<a class="headerlink" href="#Programmierung-in-Assembler">¶</a></h2><p>
Die meisten Programme für Mikrocontroller werden heutzutage in C geschrieben. Assembler verwendet man dann, wenn es um besonders zeitkritische Anwendungen geht oder wenn es innerhalb von C-Programmen besonders zeitkritische Abschnitte gibt. Kaum jemand würde auf die Idee kommen, eine komplexe Anwendung komplett in Assembler zu schreiben. Gerade längere Assembler-Programme sind deutlich schwerer les- und wartbar als vergleichbare C-Programme.</p><p>Trotzdem sind Assembler und C für den Einstieg in die Mikrocontroller-Programmierung grundsätzlich gleichermaßen geeignet. Für viele Einsteiger hat C den Vorteil, dass sie die Sprache schon kennen und daher mit den wichtigsten Sprachelementen gut zurecht kommen. Dazu gehört insbesondere die Bitmanipulation (bitweises Und, Oder, Exklusiv-Oder, Shiften usw.). Assembler hingegen bietet den Vorteil, dass man die Funktionsweise des Mikrocontrollers wirklich auf der untersten Ebene kennen lernt. Man kann selbst entscheiden, welches Byte man in welchem Register ablegt. Bei einem späteren Umstieg auf C hat man dadurch einen nützlichen Wissensvorsprung, der klassische Fehler vermeiden hilft und es einem ermöglicht, C-Programme zu schreiben, die für den Einsatz auf Mikrocontrollern optimiert sind.</p><p>Assembler bietet einen weiteren – kleinen – Vorteil: der Weg bis zum ersten lauffähigen Programm ist kürzer als bei C. Das liegt aber <em>nicht</em> an der Programmiersprache, sondern lediglich daran, dass bei C zuerst eine komplexere (und leistungsfähigere) Programmierumgebung eingerichtet werden muss als bei Assembler.</p><p>Unabhängig von der Entscheidung für Assembler oder C läuft der Programmiervorgang immer nach dem gleichen Schema ab:</p><ul><li><p>Es wird  mit einem <a class="internal" href="./editoren.html">Editor</a> ein Programm-Text geschrieben.</p></li><li><p>Das Programm – genauer: die Programm-Text-Datei – wird übersetzt (Assemblierer oder C-Compiler).</p></li><li><p>Die Ausgabedatei der Übersetzung (Endung ".hex") wird in binärer Form an den Mikrocontroller gesendet.</p></li></ul><p>
</p><div class="section_2"><h3 id="Einrichten-einer-Entwicklungsumgebung">Einrichten einer Entwicklungsumgebung<a class="headerlink" href="#Einrichten-einer-Entwicklungsumgebung">¶</a></h3><p>
Das Installieren und Einrichten der benötigen Software ist ausgesprochen einfach. Der Assemblierer AVRA ist gut geeignet, da er ohne Makefiles auskommt und von seiner Syntax her dem Original-Assembler von Atmel weitgehend entspricht. Außerdem benötigt werden ein <a class="internal" href="./editoren.html">Texteditor</a>, sowie das Programm avrdude, mit dem später das assemblierte Programm auf den Mikrocontroller übertragen wird. Die Installation beschränkt sich also auf zwei relativ kleine Pakete:</p><ul><li><p><strong>avra</strong> (<em>universe</em>)</p></li><li><p><strong>avrdude</strong> (<em>universe</em>)</p></li></ul><p><img alt="Wiki/Vorlagen/Installbutton/button.png" class="image-default" src="./_/fd60ccb86c4d96df2f4518df2936cc7d038467aa.png"/>
mit <a class="internal" href="./apturl.html">apturl</a>
</p><div class="package-list"><div class="contents"><p>
Paketliste zum Kopieren:
</p><div class="bash"><div class="contents"><pre class="notranslate">sudo apt-get install avra avrdude </pre></div></div><p>
</p><div class="bash"><div class="contents"><pre class="notranslate">sudo aptitude install avra avrdude </pre></div></div><p>
</p></div></div><p>An Stelle von AVRA kann natürlich auch der Assemblierer aus dem Paket <strong>gcc-avr</strong> verwendet werden. Damit wäre allerdings der Installationsvorgang komplizierter; auch die Syntax wiche dann in Teilen vom Atmel-Assembler ab, was die Nutzung der in der Original-Dokumentation veröffentlichten Beispiele erschwert. Wer jedoch bereits mit dem GNU-Assembler vertraut ist, kann diesen als Alternative zu AVRA verwenden.</p><p>Anhand eines Beispiels für den kleinen 8-Pin-Mikrocontroller ATtiny13A soll gezeigt werden, wie ein Assembler-Programm erstellt, übersetzt und auf den Controller übertragen wird. Dazu wird ein eigenes Verzeichnis eingerichtet, z.B. einen neuen Ordner <strong>avr</strong> im persönlichen Ordner:</p><div class="bash"><div class="contents"><pre class="notranslate">mkdir ~/avr
cd ~/avr </pre></div></div><p>
Jetzt fehlt nur noch die "Include-Datei" für diese Mikrocontroller. Leider ist diese Datei von Atmel nicht einzeln herunterladbar. Man müsste ein riesiges Softwarepaket, das sogenannte <a class="external" href="http://www.atmel.com/tools/ATMELSTUDIO.aspx" rel="nofollow">Atmel Studio</a> <img alt="{en}" src="./_/d5ecf89114b079f85d02099649c4ee617ffa34c7.png"/> herunterladen, unter Windows installieren, und diese Datei dann aus einem der Verzeichnisse kopieren. Einfacher ist es, die benötigte Include-Datei im Internet ausfindig zu machen. Am besten sucht man nach den Begriffen "tn13Adef.inc" und "AVR000". Man benötigt eine Datei, die so beginnt:</p><pre class="notranslate">;***** THIS IS A MACHINE GENERATED FILE - DO NOT EDIT ********************
;***** Created: 2011-02-09 12:03 ******* Source: ATtiny13A.xml ***********
;*************************************************************************
;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y</pre><p>
Diese Datei kann man nun per <a class="internal" href="./wget.html">wget</a> herunterladen und gleichzeitig umformen:</p><div class="bash"><div class="contents"><pre class="notranslate">wget "http://hier_die_Fundstelle_eintragen/tn13Adef.inc" -O - | sed "s/#/;/" | sed "s/.device ATtiny13A/.device ATtiny13/" &gt;~/avr/tn13Adef.inc </pre></div></div><p>
Am besten, man besorgt sich gleich die beiden wichtigsten Nachschlagewerke für die AVR-Programmierung, das AVR-Instructionset und das Datenblatt des verwendeten Mikrocontrollertyps:</p><div class="bash"><div class="contents"><pre class="notranslate">wget http://www.atmel.com/Images/doc0856.pdf -O ~/avr/instructionset.pdf
wget http://www.atmel.com/Images/doc8126.pdf -O ~/avr/datenblatt_attiny13a.pdf </pre></div></div></div><div class="section_2"><h3 id="Register-des-Mikrocontrollers">Register des Mikrocontrollers<a class="headerlink" href="#Register-des-Mikrocontrollers">¶</a></h3><p>
Der ATtiny13A besitzt eine Reihe von Speicherregistern, die für Rechenoperatoren direkt verwendet werden können. Dabei unterscheidet sich der kleine ATtiny13A kaum von den größeren AVR-8-Bit-Mikrocontrollern wie z.B. dem ATtiny861A, ATmega8A, ATmega328 usw. Die wichtigsten dieser Register sind hier beschrieben.</p><div class="section_3"><h4 id="Arbeitsregister-r16-bis-r31">Arbeitsregister r16 bis r31<a class="headerlink" href="#Arbeitsregister-r16-bis-r31">¶</a></h4><p>
Der ATtiny13A besitzt wie fast alle Typen der 8-Bit-AVR-Familie 32 Arbeitsregister: r0 bis r31. Manche Assembler-Befehle funktionieren nur mit den Registern aus der oberen Hälfte, nämlich r16 bis r31. Aus Gründen der Einfachheit werden im Beispiel nur diese Register benutzt.
Mit einem Arbeitsregister kann man beispielsweise Daten lesen, schreiben, bitweise nach links oder rechts schieben, addieren, subtrahieren, vergleichen und bitweise verknüpfen.</p></div><div class="section_3"><h4 id="Datenrichtungsregister-DDRB-Data-Direction-Register-of-Port-B">Datenrichtungsregister DDRB (Data Direction Register of Port B)<a class="headerlink" href="#Datenrichtungsregister-DDRB-Data-Direction-Register-of-Port-B">¶</a></h4><p>
Dieses Register bestimmt, welcher Mikrocontroller-Anschluss als Eingang und welcher als Ausgang verwendet wird: eine 0 im entsprechenden Bit bedeutet Eingang, eine 1 bedeutet Ausgang. Der ATtiny13A besitzt nur einen "Port", nämlich den Port B. Ein solcher Port umfasst
maximal 8 Ein- und Ausgänge, beim ATtiny13A sind es 5 (in Sonderfällen 6).</p></div><div class="section_3"><h4 id="Datenausgaberegister-PORTB-Port-Output-B">Datenausgaberegister PORTB (Port Output B)<a class="headerlink" href="#Datenausgaberegister-PORTB-Port-Output-B">¶</a></h4><p>
Für Ausgänge wird hier festgelegt, ob sie niedriges oder hohes Spannungsniveau erhalten sollen. Eine 0 im entsprechenden Bit bedeutet "low" (0 Volt), eine 1 bedeutet "high" (normalerweise 5 Volt). Für Eingänge legen die jeweiligen Bits dieses Registers fest, ob ein Mikrocontroller-interner Pullup-Widerstand aktiviert werden soll.</p></div><div class="section_3"><h4 id="Dateneingaberegister-PINB-Port-Input-B">Dateneingaberegister PINB (Port Input B)<a class="headerlink" href="#Dateneingaberegister-PINB-Port-Input-B">¶</a></h4><p>
Für jeden als Eingang definierten Anschluss enthält dieses Register ein Bit, das das Spannungsniveau repräsentiert: 0 für "low" (unter ca. 2,5 Volt), 1 für "high" (ca. 2,5 Volt oder mehr). Die Abkürzung "PIN" im Registernamen sollte nicht mit "Pin" ("Anschluss") verwechselt werden, sie steht hier für "Port Input".</p></div><div class="section_3"><h4 id="Spezialregister">Spezialregister<a class="headerlink" href="#Spezialregister">¶</a></h4><p>
Neben den oben vorgestellten Datenregistern gibt es noch eine Reihe von Spezialregistern, die in unserem einfachen Beispiel nicht verwendet werden. Hier die wichtigsten:</p><ul><li><p>Register ADMUX, Bit ADLAR: aktiviert 8 Bit Auflösung für den AD-Wandler</p></li><li><p>Register ADMUX, Bits MUX1 und MUX0: bestimmt den Pin für die AD-Wandlung</p></li><li><p>Register ADCSRA, Bit ADEN: aktiviert den AD-Wandler</p></li><li><p>Register TCCR0B, Bits CS00 bis CS02: bestimmt den Wert des Timer-Vorteilers</p></li><li><p>Register TIMSK0, Bit TOIE0: aktiviert den Überlauf-Interrupt für den Timer</p></li></ul><p>
</p></div></div><div class="section_2"><h3 id="Assembler-Befehle">Assembler-Befehle<a class="headerlink" href="#Assembler-Befehle">¶</a></h3><p>
Hier ein kurzer Überblick über die wichtigsten Assembler-Befehle. In dem einfachen Beispielprogramm werden nur wenige davon gebraucht.</p><p>
</p><table><tr class="kopf"><td>Beispielbefehl </td><td> Erklärung </td></tr><tr><td> <code class="notranslate">ldi r16,123</code> </td><td> schreibe die konstante Zahl 123 ins Register R16 (Load Immediate) </td></tr><tr class="highlight"><td><code class="notranslate">inc r16</code> </td><td> erhöhe den Inhalt des Registers r16 um eins (Increment) </td></tr><tr><td> <code class="notranslate">dec r16</code> </td><td> veringere den Inhalt des Registers r16 um eins (Decrement) </td></tr><tr class="highlight"><td><code class="notranslate">add r16,r17</code> </td><td> addiere den Inhalt von r17 zum Register r16 (Add) </td></tr><tr><td> <code class="notranslate">sub r16,r17</code> </td><td> subtrahiere den Inhalt von r17 von Register r16 (Subtract) </td></tr><tr class="highlight"><td><code class="notranslate">subi r16,3</code> </td><td> subtrahiere die Konstante 3 von Register r16 (Subtract Immediate) </td></tr><tr><td> <code class="notranslate">subi r16,-5</code> </td><td> addiere die Konstante 5 zum Register r16 (Subtract Immediate) </td></tr><tr class="highlight"><td><code class="notranslate">lsl r16</code> </td><td> verschiebe den Inhalt von r16 um eine Binärstelle nach links (Logical Shift Left) </td></tr><tr><td> <code class="notranslate">lsr r16</code> </td><td> verschiebe den Inhalt von r16 um eine Binärstelle nach rechts (Logical Shift Right) </td></tr><tr class="highlight"><td><code class="notranslate">in r16,ADCH</code> </td><td> übertrage den Inhalt von Datenregister ADCH ins Arbeitsregister r16 (Load an I/O Location to Register) </td></tr><tr><td> <code class="notranslate">out DDRB,r16</code> </td><td> übertrage den Inhalt von Arbeitsregister r16 ins Datenregister DDRB (Store Register to I/O Location) </td></tr><tr class="highlight"><td><code class="notranslate">cbi PORTB,0</code> </td><td> setze das Bit Nummer 0 im Datenregister PORTB auf 0 (Clear Bit in I/O Register) </td></tr><tr><td> <code class="notranslate">sbi PORTB,0</code> </td><td> setze das Bit Nummer 0 im Datenregister PORTB auf 1 (Set Bit in I/O Register) </td></tr><tr class="highlight"><td><code class="notranslate">sbic PINB,4</code> </td><td> überspringe nächsten Befehl, falls Bit 4 im Register PINB auf "low" liegt (Skip if Bit in I/O Register is Cleared) </td></tr><tr><td> <code class="notranslate">sbis PINB,4</code> </td><td> überspringe nächsten Befehl, falls Bit 4 im Register PINB auf "high" liegt (Skip if Bit in I/O Register is Set) </td></tr><tr class="highlight"><td><code class="notranslate">sei</code> </td><td> Freigabe aller aktivierten Interrupts (Set Global Interrupt Flag) </td></tr><tr><td> <code class="notranslate">eine_position:</code> </td><td> Sprungmarke – hierher kann mit rjmp oder rcall gesprungen werden (Label) </td></tr><tr class="highlight"><td><code class="notranslate">rjmp eine_position</code> </td><td> springe zur entsprechend markierten Stelle (Relative Jump) </td></tr><tr><td> <code class="notranslate">rjmp PC-1</code> </td><td> springe zum vorherigen Befehl (Relative Jump) </td></tr><tr class="highlight"><td><code class="notranslate">breq eine_position</code> </td><td> springe, falls das letzte Ergebnis 0 war (Branch if Equal) </td></tr><tr><td> <code class="notranslate">brne eine_position</code> </td><td> springe, falls das letzte Ergebnis nicht 0 war (Branch if Not Equal) </td></tr><tr class="highlight"><td><code class="notranslate">rcall ein_unterprogramm</code> </td><td> springe zum entsprechend markierten Unterprogramm(Relative Call to Subroutine) </td></tr><tr><td> <code class="notranslate">ret</code> </td><td> beende das Unterprogramm und springe zurück zum Hauptprogramm (Return from Subroutine) </td></tr><tr class="highlight"><td><code class="notranslate">reti</code> </td><td> beende das Interrupt-Unterprogramm und setze das normale Programm fort (Return from Interrupt) </td></tr></table></div><div class="section_2"><h3 id="Schreiben-eines-Programms">Schreiben eines Programms<a class="headerlink" href="#Schreiben-eines-Programms">¶</a></h3><p>
Das Beispielprogramm soll einen Anschluss des Mikrocontrollers, nämlich PB0 – das ist beim ATtiny13A der Pin 5 – ständig zwischen Low und High umschalten. Dazu wird im vorhin angelegten Verzeichnis <strong>avr/</strong> eine neue Datei mit dem Namen <strong>beispiel.asm</strong> erstellt. Die Endung <strong>.asm</strong> deutet darauf hin, dass es sich um den Assembler-Quelltext handelt. Der Inhalt dieser Beispieldatei:</p><pre class="notranslate">; Beispiel-Projekt beispiel.asm
.include "tn13Adef.inc" ; Definitionen für unseren Mikrocontrollertyp
  ldi r16,0b00001 ; schreibe den Zahlenwert 1 ins Register Nummer 16
  out DDRB,r16 ; Inhalt des Registers 16 ins Datenrichtungsregister
  ldi r16,0b11110 ; binären Zahlenwert 11110 ins Register Nummer 16
  out PORTB,r16 ; Inhalt des Registers 16 ins Ausgaberegister
loop: ; ab hier der Teil des Programms, der ständig wiederholt wird
  sbi PORTB,0 ; schalte die Leuchtdiode ein
   rcall warten ; Aufruf des Warte-Unterprogramms
  cbi PORTB,0 ; schalte die Leuchtdiode aus
   rcall warten ; Aufruf des Warte-Unterprogramms
  rjmp loop ; springe zum Label 'loop'

warten: ; ca. 1/6 Sekunde verzögern
  inc r21
  brne PC-1
  inc r22
  brne PC-3
  ret ; Rücksprung ins Hauptprogramm</pre></div><div class="section_2"><h3 id="bersetzen-des-Programms">Übersetzen des Programms<a class="headerlink" href="#bersetzen-des-Programms">¶</a></h3><p>
Das Übersetzen eines Assembler-Programmtexts wird meist als "Assemblieren" bezeichnet. Beim Assemblieren wird jede Befehlszeile in den zugehörigen Maschinencode umgewandelt. Erst dieser Maschinencode kann vom Mikrocontroller direkt gelesen und "verstanden" werden. AVRA speichert den Maschinencode in eine neue Datei und gibt dieser die Endung <strong>.hex</strong>. In dieser Datei befindet sich nicht direkt binärer Code, vielmehr wurde der binäre Code in menschenlesbarer Form, also in Form von druckbaren Zeichen gespeichert. Erst beim Übertragen zum Mikrocontroller wird dieser lesbare Code wieder in seine ursprüngliche binäre Form zurückverwandelt. Aber dazu später. Zunächst muss das kleine Assemblerprogramm übersetzt werden. Dazu reicht eine einzige Befehlszeile:</p><div class="bash"><div class="contents"><pre class="notranslate">avra beispiel.asm </pre></div></div><p>
Falls der Programmtext ohne Fehler war, hat der Assemblierer jetzt die Datei <strong>beispiel.hex</strong> erstellt.</p></div><div class="section_2"><h3 id="Programm-aufspielen">Programm aufspielen<a class="headerlink" href="#Programm-aufspielen">¶</a></h3><p>
<img alt="avr_beispiel_steckplatine.png" class="image-right" src="./_/2674499cced6f3181122220f7792dcee558035b4.png"/>
</p><p>
</p><table style="float: right; clear: left; margin-top: 0px; border: none"><tr class="titel"><td> <img alt="atmel_AVR_ATtiny13.png" class="image-default" src="./_/e5e390c8477402d05dbd86be972c94266c2f08b6.png"/></td></tr><tr class="normal"><td style="text-align: center; width: 200px"> Anschlussbelegung des ATtiny13</td></tr></table><p>
Vor dem Übertragen des Programms auf den Mikrocontroller muss dieser korrekt an den verwendeten Programmer angeschlossen werden. Zu verbinden sind die Leitungen VCC, GND, MOSI, MISO, SCK und RESET, auf nebenstehendem Bild in den Farben Rot, Schwarz, Grün, Weiß, Blau und Gelb dargestellt.</p><p>Die Datei <strong>beispiel.hex</strong> muss nun in binärer Form übertragen werden. Dazu wird das Programm <strong>avrdude</strong> verwendet. Es ist zweckmäßig, vor der Übertragung zu prüfen, ob der Programmer korrekt an den Computer und der Mikrocontroller korrekt an den Programmer angeschlossen ist. Dazu eignet sich ein harmloser Befehl, der nur das so genannte Fuse Low Byte aus dem Mikrocontroller ausliest:</p><div class="bash"><div class="contents"><pre class="notranslate">avrdude -c usbasp -p t13 -B 60 -P usb -U lfuse:r:/dev/stdout:b </pre></div></div><p>
Falls ein anderer Programmer als USBasp verwendet wird, muss der Parameter <code class="notranslate">-c</code> entsprechend angepasst werden. Je nach Berechtigungen des Benutzers kann es erforderlich sein, vor den Befehl ein "sudo" zu setzen. Die Ausgabe sollte so aussehen:</p><pre class="notranslate">avrdude: set SCK frequency to 16000 Hz
avrdude: AVR device initialized and ready to accept instructions
Reading | ################################################## | 100% 0.02s
avrdude: Device signature = 0x1e9007
avrdude: reading lfuse memory:
Reading | ################################################## | 100% 0.01s
avrdude: writing output file "/dev/stdout"
0b1101010
avrdude: safemode: Fuses OK
avrdude done.  Thank you.</pre><p>Die Ausgabe "0b1101010" zeigt das Low Fuse Byte in Fabrikeinstellung. Falls bei diesem Test Fehler angezeigt wurden, sollte zuerst den Hinweisen von avrdude nachgegangen werden. Einzige Ausnahme ist der möglicherweise angezeigte Vorschlag "Override with -F". Genau das sollte man bei gängigen Controllertypen wie dem ATtiny13A nicht tun, weil der betreffende Fehler dann zwar ignoriert wird, aber trotzdem noch vorhanden ist.</p><p>Lief der Test fehlerfrei, kann nun das Programm übertragen werden:</p><div class="bash"><div class="contents"><pre class="notranslate">avrdude -c usbasp -p t13 -B 60 -P usb -U flash:w:beispiel.hex:i </pre></div></div><p>
Im Fall des USBasp wird das Programm sofort nach der Übertragung starten und die LED blinkt in schneller Folge (ca. 3 Hz). Bei anderen Programmern kann es notwendig sein, die Schaltung von den sechs Programmierleitungen zu trennen und eigens per VCC und GND mit einer Spannung zu versorgen (z.B. 5 Volt).</p><p>Und – hat etwas nicht geklappt? Dann hilft vielleicht der Abschnitt <a class="crosslink" href="#Fehlerbehandlung">Fehlerbehandlung</a> weiter.</p></div></div><div class="section_1"><h2 id="Programmierung-in-C">Programmierung in C<a class="headerlink" href="#Programmierung-in-C">¶</a></h2><p>
Vorab sollte erwähnt werden, dass der Begriff "programmieren" im Bereich Mikrocontroller zweideutig sein kann. Mit "C programmieren" ist das Schreiben eines Programms für den Mikrocontroller in der Sprache C gemeint. Das "Programmieren eines Mikrocontrollers" ist der Prozess des Übertragens des geschriebenen Programms mit einem Programmieradapter auf den Mikrocontroller.</p><p>Die Programmierung von AVRs wird hier für C gezeigt, da C eine weit verbreitete Programmiersprache im Mikrocontrollerbereich ist. Dies hängt damit zusammen, dass aktuelle Compiler den Code so effizient und optimiert in Assembler übersetzen können, dass der Geschwindigkeitsnachteil gegenüber handgeschriebenem Assemblercode für die meisten Anwendungen nur noch klein ist und die Vorteile dieser Hochsprache überwiegen. Bei besonders zeitkritischen Steuerungen oder in Fällen, in denen mit minimaler Hardware maximale Rechenleistung erzielt werden soll (Kostenoptimierung bei sehr großen Stückzahlen) wird trotzdem in der Regel auch auf Assembler zurückgegriffen.</p><div class="section_2"><h3 id="Einrichten-einer-Entwicklungsumgebung-2">Einrichten einer Entwicklungsumgebung<a class="headerlink" href="#Einrichten-einer-Entwicklungsumgebung-2">¶</a></h3><p>
Das Schreiben des Programms erfolgt oft in einer <a class="interwiki interwiki-wikipedia" href="https://de.wikipedia.org/wiki/Integrierte_Entwicklungsumgebung">IDE</a>. Dies ist ein Editor, der mit Zusatzfunktionen ausgestattet ist, die das Schreiben und Testen eines Programms erleichtern. Die offizielle IDE für AVRs ist das <a class="external" href="http://www.atmel.com/tools/ATMELSTUDIO.aspx" rel="nofollow">Atmel Studio</a> <img alt="{en}" src="./_/d5ecf89114b079f85d02099649c4ee617ffa34c7.png"/>, welches allerdings nur für Windows erhältlich ist. Als Alternative stehen unter Linux von je her sehr viele sehr gute <a class="internal" href="./editoren.html">Editoren</a> zur Verfügung. Diese bieten meist eine Möglichkeit Tastenkürzel und Schaltflächen nach eigenen Wünschen zu konfigurieren und können so einfach mit Hilfe von Skripten zu einer IDE erweitert werden.</p><p>Wie dies funktioniert, soll hier am Beispiel des Editors <a class="internal" href="./geany.html">Geany</a> erläutert werden. Des Weiteren benötigt man einige Werkzeuge, um den Quellcode in Maschinensprache zu übersetzen und diesen auf den AVR übertragen zu können. Die nachfolgenden Pakete ermöglichen die Programmierung eines AVR in C und C++.</p><ul><li><p><strong>avr-libc</strong> (<em>universe</em>)</p></li><li><p><strong>binutils-avr</strong> (<em>universe</em>)</p></li><li><p><strong>gcc-avr</strong> (<em>universe</em>)</p></li><li><p><strong>avrdude</strong> (<em>universe</em>)</p></li></ul><p><img alt="Wiki/Vorlagen/Installbutton/button.png" class="image-default" src="./_/fd60ccb86c4d96df2f4518df2936cc7d038467aa.png"/>
mit <a class="internal" href="./apturl.html">apturl</a>
</p><div class="package-list"><div class="contents"><p>
Paketliste zum Kopieren:
</p><div class="bash"><div class="contents"><pre class="notranslate">sudo apt-get install avr-libc binutils-avr gcc-avr avrdude </pre></div></div><p>
</p><div class="bash"><div class="contents"><pre class="notranslate">sudo aptitude install avr-libc binutils-avr gcc-avr avrdude </pre></div></div><p>
</p></div></div><div class="box experts"><h3 class="box experts">Experten-Info:</h3><div class="contents"><p>Genau genommen kann man mit Hilfe dieser Pakete den AVR ebenfalls in Assembler programmieren, dies ist aber etwas umständlich. Unter Ubuntu verfügbare AVR-Assembler lassen sich leicht mit</p><div class="bash"><div class="contents"><pre class="notranslate">apt-cache search avr  </pre></div></div><p>auffinden.
</p></div></div><p>Nach der Installation startet man Geany und speichert eine leere Datei. Dazu erstellt man einen Projektordner und speichert darin die Datei als <strong>main.c</strong>. Der Pfad zur Datei könnte dann beispielsweise so lauten: <strong>~/Programmierung/AVRs/AVRTutorial/main.c</strong></p><p><img alt="Geany_Einstellungen.png" class="image-right" src="./_/e42561845c0b2062cd84a255570718040a58a6c6.png"/></p><p>Jetzt müssen mikrocontrollerspezifische Skripte eingebunden werden. Dazu geht man im Menü auf <em>"Erstellen -&gt; Kommandos zu erstellen Konfigurieren"</em>. Jetzt kann man die Kommandos für eine C-Datei (desshalb wurde im ersten Schritt die Datei mit der Endung <strong>.c</strong> gespeichert) anpassen. Die bisherigen Einstellungen werden durch folgende ersetzt:</p><ul><li><p><em>"Kompilieren"</em>: <code class="notranslate">make all</code>.  <em>"Arbeitsverzeichnis"</em>: <code class="notranslate">%d</code></p></li><li><p>"<em>Erstellen"</em>: <code class="notranslate">make program</code>, <em>"Arbeitsverzeichnis"</em>: <code class="notranslate">%d</code></p></li></ul><p>
Anschließend muss man in Geany eine weitere Datei erstellen, die das mikrocontrollerspezifische Skript darstellt. Es heißt <strong>makefile</strong> (siehe auch <a class="internal" href="./makefile.html">Makefile</a>) und wird im selben Ordner wie <strong>main.c</strong> gespeichert. Inhalt ist folgender (Kopie aus WinAVR-IDE von 2004):</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="c"># Hey Emacs, this is a -*- makefile -*-</span>
<span class="c">#</span>
<span class="c"># WinAVR makefile written by Eric B. Weddington, Jörg Wunsch, et al.</span>
<span class="c"># Released to the Public Domain</span>
<span class="c"># Please read the make user manual!</span>
<span class="c">#</span>
<span class="c"># Additional material for this makefile was submitted by:</span>
<span class="c">#  Tim Henigan</span>
<span class="c">#  Peter Fleury</span>
<span class="c">#  Reiner Patommel</span>
<span class="c">#  Sander Pool</span>
<span class="c">#  Frederik Rouleau</span>
<span class="c">#  Markus Pfaff</span>
<span class="c">#</span>
<span class="c"># On command line:</span>
<span class="c">#</span>
<span class="c"># make all = Make software.</span>
<span class="c">#</span>
<span class="c"># make clean = Clean out built project files.</span>
<span class="c">#</span>
<span class="c"># make coff = Convert ELF to AVR COFF (for use with AVR Studio 3.x or VMLAB).</span>
<span class="c">#</span>
<span class="c"># make extcoff = Convert ELF to AVR Extended COFF (for use with AVR Studio</span>
<span class="c">#                4.07 or greater).</span>
<span class="c">#</span>
<span class="c"># make program = Download the hex file to the device, using avrdude.  Please</span>
<span class="c">#                customize the avrdude settings below first!</span>
<span class="c">#</span>
<span class="c"># make filename.s = Just compile filename.c into the assembler code only</span>
<span class="c">#</span>
<span class="c"># To rebuild project do "make clean" then "make all".</span>
<span class="c">#</span>

<span class="c"># mth 2004/09 </span>
<span class="c"># Differences from WinAVR 20040720 sample:</span>
<span class="c"># - DEPFLAGS according to Eric Weddingtion's fix (avrfreaks/gcc-forum)</span>
<span class="c"># - F_OSC Define in CFLAGS and AFLAGS</span>


<span class="c"># MCU name</span>
<span class="nv">MCU</span> <span class="o">=</span> atmega16

<span class="c"># Main Oscillator Frequency</span>
<span class="c"># This is only used to define F_OSC in all assembler and c-sources.</span>
<span class="nv">F_OSC</span> <span class="o">=</span> <span class="m">3686400</span>

<span class="c"># Output format. (can be srec, ihex, binary)</span>
<span class="nv">FORMAT</span> <span class="o">=</span> ihex

<span class="c"># Target file name (without extension).</span>
<span class="nv">TARGET</span> <span class="o">=</span> main


<span class="c"># List C source files here. (C dependencies are automatically generated.)</span>
<span class="nv">SRC</span> <span class="o">=</span> <span class="k">$(</span>TARGET<span class="k">)</span>.c


<span class="c"># List Assembler source files here.</span>
<span class="c"># Make them always end in a capital .S.  Files ending in a lowercase .s</span>
<span class="c"># will not be considered source files but generated files (assembler</span>
<span class="c"># output from the compiler), and will be deleted upon "make clean"!</span>
<span class="c"># Even though the DOS/Win* filesystem matches both .s and .S the same,</span>
<span class="c"># it will preserve the spelling of the filenames, and gcc itself does</span>
<span class="c"># care about how the name is spelled on its command-line.</span>
<span class="nv">ASRC</span> <span class="o">=</span> 



<span class="c"># Optimization level, can be [0, 1, 2, 3, s]. </span>
<span class="c"># 0 = turn off optimization. s = optimize for size.</span>
<span class="c"># (Note: 3 is not always the best optimization level. See avr-libc FAQ.)</span>
<span class="nv">OPT</span> <span class="o">=</span> s

<span class="c"># Debugging format.</span>
<span class="c"># Native formats for AVR-GCC's -g are stabs [default], or dwarf-2.</span>
<span class="c"># AVR (extended) COFF requires stabs, plus an avr-objcopy run.</span>
<span class="c">#DEBUG = stabs</span>
<span class="nv">DEBUG</span> <span class="o">=</span> dwarf-2

<span class="c"># List any extra directories to look for include files here.</span>
<span class="c">#     Each directory must be seperated by a space.</span>
<span class="nv">EXTRAINCDIRS</span> <span class="o">=</span> 


<span class="c"># Compiler flag to set the C Standard level.</span>
<span class="c"># c89   - "ANSI" C</span>
<span class="c"># gnu89 - c89 plus GCC extensions</span>
<span class="c"># c99   - ISO C99 standard (not yet fully implemented)</span>
<span class="c"># gnu99 - c99 plus GCC extensions</span>
<span class="nv">CSTANDARD</span> <span class="o">=</span> -std<span class="o">=</span>gnu99

<span class="c"># Place -D or -U options here</span>
<span class="nv">CDEFS</span> <span class="o">=</span>

<span class="c"># Place -I options here</span>
<span class="nv">CINCS</span> <span class="o">=</span>


<span class="c"># Compiler flags.</span>
<span class="c">#  -g*:          generate debugging information</span>
<span class="c">#  -O*:          optimization level</span>
<span class="c">#  -f...:        tuning, see GCC manual and avr-libc documentation</span>
<span class="c">#  -Wall...:     warning level</span>
<span class="c">#  -Wa,...:      tell GCC to pass this to the assembler.</span>
<span class="c">#    -adhlns...: create assembler listing</span>
<span class="nv">CFLAGS</span> <span class="o">=</span> -g<span class="k">$(</span>DEBUG<span class="k">)</span>
<span class="nv">CFLAGS</span> <span class="o">+=</span> <span class="k">$(</span>CDEFS<span class="k">)</span> <span class="k">$(</span>CINCS<span class="k">)</span>
<span class="nv">CFLAGS</span> <span class="o">+=</span> -O<span class="k">$(</span>OPT<span class="k">)</span>
<span class="nv">CFLAGS</span> <span class="o">+=</span> -funsigned-char -funsigned-bitfields -fpack-struct -fshort-enums
<span class="nv">CFLAGS</span> <span class="o">+=</span> -Wall -Wstrict-prototypes
<span class="nv">CFLAGS</span> <span class="o">+=</span> -Wa,-adhlns<span class="o">=</span><span class="k">$(</span>&lt;:.c<span class="o">=</span>.lst<span class="k">)</span>
<span class="nv">CFLAGS</span> <span class="o">+=</span> <span class="k">$(</span>patsubst %,-I%,<span class="k">$(</span>EXTRAINCDIRS<span class="k">))</span>
<span class="nv">CFLAGS</span> <span class="o">+=</span> <span class="k">$(</span>CSTANDARD<span class="k">)</span>
<span class="nv">CFLAGS</span> <span class="o">+=</span> -DF_OSC<span class="o">=</span><span class="k">$(</span>F_OSC<span class="k">)</span>



<span class="c"># Assembler flags.</span>
<span class="c">#  -Wa,...:   tell GCC to pass this to the assembler.</span>
<span class="c">#  -ahlms:    create listing</span>
<span class="c">#  -gstabs:   have the assembler create line number information; note that</span>
<span class="c">#             for use in COFF files, additional information about filenames</span>
<span class="c">#             and function names needs to be present in the assembler source</span>
<span class="c">#             files -- see avr-libc docs [FIXME: not yet described there]</span>
<span class="nv">ASFLAGS</span> <span class="o">=</span> -Wa,-adhlns<span class="o">=</span><span class="k">$(</span>&lt;:.S<span class="o">=</span>.lst<span class="k">)</span>,-gstabs 
<span class="nv">ASFLAGS</span> <span class="o">+=</span> -DF_OSC<span class="o">=</span><span class="k">$(</span>F_OSC<span class="k">)</span>


<span class="c">#Additional libraries.</span>

<span class="c"># Minimalistic printf version</span>
<span class="nv">PRINTF_LIB_MIN</span> <span class="o">=</span> -Wl,-u,vfprintf -lprintf_min

<span class="c"># Floating point printf version (requires MATH_LIB = -lm below)</span>
<span class="nv">PRINTF_LIB_FLOAT</span> <span class="o">=</span> -Wl,-u,vfprintf -lprintf_flt

<span class="nv">PRINTF_LIB</span> <span class="o">=</span> 

<span class="c"># Minimalistic scanf version</span>
<span class="nv">SCANF_LIB_MIN</span> <span class="o">=</span> -Wl,-u,vfscanf -lscanf_min

<span class="c"># Floating point + %[ scanf version (requires MATH_LIB = -lm below)</span>
<span class="nv">SCANF_LIB_FLOAT</span> <span class="o">=</span> -Wl,-u,vfscanf -lscanf_flt

<span class="nv">SCANF_LIB</span> <span class="o">=</span> 

<span class="nv">MATH_LIB</span> <span class="o">=</span> -lm

<span class="c"># External memory options</span>

<span class="c"># 64 KB of external RAM, starting after internal RAM (ATmega128!),</span>
<span class="c"># used for variables (.data/.bss) and heap (malloc()).</span>
<span class="c">#EXTMEMOPTS = -Wl,-Tdata=0x801100,--defsym=__heap_end=0x80ffff</span>

<span class="c"># 64 KB of external RAM, starting after internal RAM (ATmega128!),</span>
<span class="c"># only used for heap (malloc()).</span>
<span class="c">#EXTMEMOPTS = -Wl,--defsym=__heap_start=0x801100,--defsym=__heap_end=0x80ffff</span>

<span class="nv">EXTMEMOPTS</span> <span class="o">=</span>

<span class="c"># Linker flags.</span>
<span class="c">#  -Wl,...:     tell GCC to pass this to linker.</span>
<span class="c">#    -Map:      create map file</span>
<span class="c">#    --cref:    add cross reference to  map file</span>
<span class="nv">LDFLAGS</span> <span class="o">=</span> -Wl,-Map<span class="o">=</span><span class="k">$(</span>TARGET<span class="k">)</span>.map,--cref
<span class="nv">LDFLAGS</span> <span class="o">+=</span> <span class="k">$(</span>EXTMEMOPTS<span class="k">)</span>
<span class="nv">LDFLAGS</span> <span class="o">+=</span> <span class="k">$(</span>PRINTF_LIB<span class="k">)</span> <span class="k">$(</span>SCANF_LIB<span class="k">)</span> <span class="k">$(</span>MATH_LIB<span class="k">)</span>




<span class="c"># Programming support using avrdude. Settings and variables.</span>

<span class="c"># Programming hardware: alf avr910 avrisp bascom bsd </span>
<span class="c"># dt006 pavr picoweb pony-stk200 sp12 stk200 stk500</span>
<span class="c">#</span>
<span class="c"># Type: avrdude -c ?</span>
<span class="c"># to get a full listing.</span>
<span class="c">#</span>
<span class="nv">AVRDUDE_PROGRAMMER</span> <span class="o">=</span> stk500

<span class="c"># com1 = serial port. Use lpt1 to connect to parallel port.</span>
<span class="nv">AVRDUDE_PORT</span> <span class="o">=</span> usb    <span class="c1"># programmer connected to serial device</span>

<span class="nv">AVRDUDE_WRITE_FLASH</span> <span class="o">=</span> -U flash:w:<span class="k">$(</span>TARGET<span class="k">)</span>.hex
<span class="c">#AVRDUDE_WRITE_EEPROM = -U eeprom:w:$(TARGET).eep</span>


<span class="c"># Uncomment the following if you want avrdude's erase cycle counter.</span>
<span class="c"># Note that this counter needs to be initialized first using -Yn,</span>
<span class="c"># see avrdude manual.</span>
<span class="c">#AVRDUDE_ERASE_COUNTER = -y</span>

<span class="c"># Uncomment the following if you do /not/ wish a verification to be</span>
<span class="c"># performed after programming the device.</span>
<span class="c">#AVRDUDE_NO_VERIFY = -V</span>

<span class="c"># Increase verbosity level.  Please use this when submitting bug</span>
<span class="c"># reports about avrdude. See &lt;http://savannah.nongnu.org/projects/avrdude&gt; </span>
<span class="c"># to submit bug reports.</span>
<span class="c">#AVRDUDE_VERBOSE = -v -v</span>

<span class="nv">AVRDUDE_FLAGS</span> <span class="o">=</span> -p <span class="k">$(</span>MCU<span class="k">)</span> -P <span class="k">$(</span>AVRDUDE_PORT<span class="k">)</span> -c <span class="k">$(</span>AVRDUDE_PROGRAMMER<span class="k">)</span>
<span class="nv">AVRDUDE_FLAGS</span> <span class="o">+=</span> <span class="k">$(</span>AVRDUDE_NO_VERIFY<span class="k">)</span>
<span class="nv">AVRDUDE_FLAGS</span> <span class="o">+=</span> <span class="k">$(</span>AVRDUDE_VERBOSE<span class="k">)</span>
<span class="nv">AVRDUDE_FLAGS</span> <span class="o">+=</span> <span class="k">$(</span>AVRDUDE_ERASE_COUNTER<span class="k">)</span>



<span class="c"># ---------------------------------------------------------------------------</span>

<span class="c"># Define directories, if needed.</span>
<span class="nv">DIRAVR</span> <span class="o">=</span> c:/winavr
<span class="nv">DIRAVRBIN</span> <span class="o">=</span> <span class="k">$(</span>DIRAVR<span class="k">)</span>/bin
<span class="nv">DIRAVRUTILS</span> <span class="o">=</span> <span class="k">$(</span>DIRAVR<span class="k">)</span>/utils/bin
<span class="nv">DIRINC</span> <span class="o">=</span> .
<span class="nv">DIRLIB</span> <span class="o">=</span> <span class="k">$(</span>DIRAVR<span class="k">)</span>/avr/lib


<span class="c"># Define programs and commands.</span>
<span class="nv">SHELL</span> <span class="o">=</span> sh
<span class="nv">CC</span> <span class="o">=</span> avr-gcc
<span class="nv">OBJCOPY</span> <span class="o">=</span> avr-objcopy
<span class="nv">OBJDUMP</span> <span class="o">=</span> avr-objdump
<span class="nv">SIZE</span> <span class="o">=</span> avr-size
<span class="nv">NM</span> <span class="o">=</span> avr-nm
<span class="nv">AVRDUDE</span> <span class="o">=</span> avrdude
<span class="nv">REMOVE</span> <span class="o">=</span> rm -f
<span class="nv">COPY</span> <span class="o">=</span> cp




<span class="c"># Define Messages</span>
<span class="c"># English</span>
<span class="nv">MSG_ERRORS_NONE</span> <span class="o">=</span> Errors: none
<span class="nv">MSG_BEGIN</span> <span class="o">=</span> -------- begin --------
<span class="nv">MSG_END</span> <span class="o">=</span> --------  end  --------
<span class="nv">MSG_SIZE_BEFORE</span> <span class="o">=</span> Size before: 
<span class="nv">MSG_SIZE_AFTER</span> <span class="o">=</span> Size after:
<span class="nv">MSG_COFF</span> <span class="o">=</span> Converting to AVR COFF:
<span class="nv">MSG_EXTENDED_COFF</span> <span class="o">=</span> Converting to AVR Extended COFF:
<span class="nv">MSG_FLASH</span> <span class="o">=</span> Creating load file <span class="k">for</span> Flash:
<span class="nv">MSG_EEPROM</span> <span class="o">=</span> Creating load file <span class="k">for</span> EEPROM:
<span class="nv">MSG_EXTENDED_LISTING</span> <span class="o">=</span> Creating Extended Listing:
<span class="nv">MSG_SYMBOL_TABLE</span> <span class="o">=</span> Creating Symbol Table:
<span class="nv">MSG_LINKING</span> <span class="o">=</span> Linking:
<span class="nv">MSG_COMPILING</span> <span class="o">=</span> Compiling:
<span class="nv">MSG_ASSEMBLING</span> <span class="o">=</span> Assembling:
<span class="nv">MSG_CLEANING</span> <span class="o">=</span> Cleaning project:




<span class="c"># Define all object files.</span>
<span class="nv">OBJ</span> <span class="o">=</span> <span class="k">$(</span>SRC:.c<span class="o">=</span>.o<span class="k">)</span> <span class="k">$(</span>ASRC:.S<span class="o">=</span>.o<span class="k">)</span> 

<span class="c"># Define all listing files.</span>
<span class="nv">LST</span> <span class="o">=</span> <span class="k">$(</span>ASRC:.S<span class="o">=</span>.lst<span class="k">)</span> <span class="k">$(</span>SRC:.c<span class="o">=</span>.lst<span class="k">)</span>


<span class="c"># Compiler flags to generate dependency files.</span>
<span class="c">### GENDEPFLAGS = -Wp,-M,-MP,-MT,$(*F).o,-MF,.dep/$(@F).d</span>
<span class="nv">GENDEPFLAGS</span> <span class="o">=</span> -MD -MP -MF .dep/<span class="k">$(</span>@F<span class="k">)</span>.d

<span class="c"># Combine all necessary flags and optional flags.</span>
<span class="c"># Add target processor to flags.</span>
<span class="nv">ALL_CFLAGS</span> <span class="o">=</span> -mmcu<span class="o">=</span><span class="k">$(</span>MCU<span class="k">)</span> -I. <span class="k">$(</span>CFLAGS<span class="k">)</span> <span class="k">$(</span>GENDEPFLAGS<span class="k">)</span>
<span class="nv">ALL_ASFLAGS</span> <span class="o">=</span> -mmcu<span class="o">=</span><span class="k">$(</span>MCU<span class="k">)</span> -I. -x assembler-with-cpp <span class="k">$(</span>ASFLAGS<span class="k">)</span>





<span class="c"># Default target.</span>
<span class="nf">all</span><span class="o">:</span> <span class="n">begin</span> <span class="n">gccversion</span> <span class="n">sizebefore</span> <span class="n">build</span> <span class="n">sizeafter</span> <span class="n">finished</span> <span class="n">end</span>

<span class="nf">build</span><span class="o">:</span> <span class="n">elf</span> <span class="n">hex</span> <span class="n">eep</span> <span class="n">lss</span> <span class="n">sym</span>

<span class="nf">elf</span><span class="o">:</span> <span class="k">$(</span><span class="nv">TARGET</span><span class="k">)</span>.<span class="n">elf</span>
<span class="nf">hex</span><span class="o">:</span> <span class="k">$(</span><span class="nv">TARGET</span><span class="k">)</span>.<span class="n">hex</span>
<span class="nf">eep</span><span class="o">:</span> <span class="k">$(</span><span class="nv">TARGET</span><span class="k">)</span>.<span class="n">eep</span>
<span class="nf">lss</span><span class="o">:</span> <span class="k">$(</span><span class="nv">TARGET</span><span class="k">)</span>.<span class="n">lss</span> 
<span class="nf">sym</span><span class="o">:</span> <span class="k">$(</span><span class="nv">TARGET</span><span class="k">)</span>.<span class="n">sym</span>



<span class="c"># Eye candy.</span>
<span class="c"># AVR Studio 3.x does not check make's exit code but relies on</span>
<span class="c"># the following magic strings to be generated by the compile job.</span>
<span class="nf">begin</span><span class="o">:</span>
	@echo
	@echo <span class="k">$(</span>MSG_BEGIN<span class="k">)</span>

<span class="nf">finished</span><span class="o">:</span>
	@echo <span class="k">$(</span>MSG_ERRORS_NONE<span class="k">)</span>

<span class="nf">end</span><span class="o">:</span>
	@echo <span class="k">$(</span>MSG_END<span class="k">)</span>
	@echo


<span class="c"># Display size of file.</span>
<span class="nv">HEXSIZE</span> <span class="o">=</span> <span class="k">$(</span>SIZE<span class="k">)</span> --target<span class="o">=</span><span class="k">$(</span>FORMAT<span class="k">)</span> <span class="k">$(</span>TARGET<span class="k">)</span>.hex
<span class="nv">ELFSIZE</span> <span class="o">=</span> <span class="k">$(</span>SIZE<span class="k">)</span> -A <span class="k">$(</span>TARGET<span class="k">)</span>.elf
<span class="nf">sizebefore</span><span class="o">:</span>
	@if <span class="o">[</span> -f <span class="k">$(</span>TARGET<span class="k">)</span>.elf <span class="o">]</span><span class="p">;</span> <span class="k">then</span> echo<span class="p">;</span> <span class="nb">echo</span> <span class="k">$(</span>MSG_SIZE_BEFORE<span class="k">)</span><span class="p">;</span> <span class="k">$(</span>ELFSIZE<span class="k">)</span><span class="p">;</span> echo<span class="p">;</span> <span class="k">fi</span>

<span class="nf">sizeafter</span><span class="o">:</span>
	@if <span class="o">[</span> -f <span class="k">$(</span>TARGET<span class="k">)</span>.elf <span class="o">]</span><span class="p">;</span> <span class="k">then</span> echo<span class="p">;</span> <span class="nb">echo</span> <span class="k">$(</span>MSG_SIZE_AFTER<span class="k">)</span><span class="p">;</span> <span class="k">$(</span>ELFSIZE<span class="k">)</span><span class="p">;</span> echo<span class="p">;</span> <span class="k">fi</span>



<span class="c"># Display compiler version information.</span>
<span class="nf">gccversion </span><span class="o">:</span> 
	@<span class="k">$(</span>CC<span class="k">)</span> --version



<span class="c"># Program the device.  </span>
<span class="nf">program</span><span class="o">:</span> <span class="k">$(</span><span class="nv">TARGET</span><span class="k">)</span>.<span class="n">hex</span> <span class="k">$(</span><span class="nv">TARGET</span><span class="k">)</span>.<span class="n">eep</span>
	<span class="k">$(</span>AVRDUDE<span class="k">)</span> <span class="k">$(</span>AVRDUDE_FLAGS<span class="k">)</span> <span class="k">$(</span>AVRDUDE_WRITE_FLASH<span class="k">)</span> <span class="k">$(</span>AVRDUDE_WRITE_EEPROM<span class="k">)</span>




<span class="c"># Convert ELF to COFF for use in debugging / simulating in AVR Studio or VMLAB.</span>
<span class="nv">COFFCONVERT</span><span class="o">=</span><span class="k">$(</span>OBJCOPY<span class="k">)</span> --debugging <span class="se">\</span>
--change-section-address .data-0x800000 <span class="se">\</span>
--change-section-address .bss-0x800000 <span class="se">\</span>
--change-section-address .noinit-0x800000 <span class="se">\</span>
<span class="err">--change-section-address</span> <span class="err">.eeprom-0x810000</span> 


<span class="nf">coff</span><span class="o">:</span> <span class="k">$(</span><span class="nv">TARGET</span><span class="k">)</span>.<span class="n">elf</span>
	@echo
	@echo <span class="k">$(</span>MSG_COFF<span class="k">)</span> <span class="k">$(</span>TARGET<span class="k">)</span>.cof
	<span class="k">$(</span>COFFCONVERT<span class="k">)</span> -O coff-avr $&lt; <span class="k">$(</span>TARGET<span class="k">)</span>.cof


<span class="nf">extcoff</span><span class="o">:</span> <span class="k">$(</span><span class="nv">TARGET</span><span class="k">)</span>.<span class="n">elf</span>
	@echo
	@echo <span class="k">$(</span>MSG_EXTENDED_COFF<span class="k">)</span> <span class="k">$(</span>TARGET<span class="k">)</span>.cof
	<span class="k">$(</span>COFFCONVERT<span class="k">)</span> -O coff-ext-avr $&lt; <span class="k">$(</span>TARGET<span class="k">)</span>.cof



<span class="c"># Create final output files (.hex, .eep) from ELF output file.</span>
<span class="nf">%.hex</span><span class="o">:</span> %.<span class="n">elf</span>
	@echo
	@echo <span class="k">$(</span>MSG_FLASH<span class="k">)</span> <span class="nv">$@</span>
	<span class="k">$(</span>OBJCOPY<span class="k">)</span> -O <span class="k">$(</span>FORMAT<span class="k">)</span> -R .eeprom $&lt; <span class="nv">$@</span>

<span class="nf">%.eep</span><span class="o">:</span> %.<span class="n">elf</span>
	@echo
	@echo <span class="k">$(</span>MSG_EEPROM<span class="k">)</span> <span class="nv">$@</span>
	-<span class="k">$(</span>OBJCOPY<span class="k">)</span> -j .eeprom --set-section-flags<span class="o">=</span>.eeprom<span class="o">=</span><span class="s2">"alloc,load"</span> <span class="se">\</span>
	--change-section-lma .eeprom<span class="o">=</span><span class="m">0</span> -O <span class="k">$(</span>FORMAT<span class="k">)</span> $&lt; <span class="nv">$@</span>

<span class="c"># Create extended listing file from ELF output file.</span>
<span class="nf">%.lss</span><span class="o">:</span> %.<span class="n">elf</span>
	@echo
	@echo <span class="k">$(</span>MSG_EXTENDED_LISTING<span class="k">)</span> <span class="nv">$@</span>
	<span class="k">$(</span>OBJDUMP<span class="k">)</span> -h -S $&lt; &gt; <span class="nv">$@</span>

<span class="c"># Create a symbol table from ELF output file.</span>
<span class="nf">%.sym</span><span class="o">:</span> %.<span class="n">elf</span>
	@echo
	@echo <span class="k">$(</span>MSG_SYMBOL_TABLE<span class="k">)</span> <span class="nv">$@</span>
	<span class="k">$(</span>NM<span class="k">)</span> -n $&lt; &gt; <span class="nv">$@</span>



<span class="c"># Link: create ELF output file from object files.</span>
<span class="nf">.SECONDARY </span><span class="o">:</span> <span class="k">$(</span><span class="nv">TARGET</span><span class="k">)</span>.<span class="n">elf</span>
<span class="nf">.PRECIOUS </span><span class="o">:</span> <span class="k">$(</span><span class="nv">OBJ</span><span class="k">)</span>
<span class="nf">%.elf</span><span class="o">:</span> <span class="k">$(</span><span class="nv">OBJ</span><span class="k">)</span>
	@echo
	@echo <span class="k">$(</span>MSG_LINKING<span class="k">)</span> <span class="nv">$@</span>
	<span class="k">$(</span>CC<span class="k">)</span> <span class="k">$(</span>ALL_CFLAGS<span class="k">)</span> <span class="k">$(</span>OBJ<span class="k">)</span> --output <span class="nv">$@</span> <span class="k">$(</span>LDFLAGS<span class="k">)</span>


<span class="c"># Compile: create object files from C source files.</span>
<span class="nf">%.o </span><span class="o">:</span> %.<span class="n">c</span>
	@echo
	@echo <span class="k">$(</span>MSG_COMPILING<span class="k">)</span> $&lt;
	<span class="k">$(</span>CC<span class="k">)</span> -c <span class="k">$(</span>ALL_CFLAGS<span class="k">)</span> $&lt; -o <span class="nv">$@</span> 


<span class="c"># Compile: create assembler files from C source files.</span>
<span class="nf">%.s </span><span class="o">:</span> %.<span class="n">c</span>
	<span class="k">$(</span>CC<span class="k">)</span> -S <span class="k">$(</span>ALL_CFLAGS<span class="k">)</span> $&lt; -o <span class="nv">$@</span>


<span class="c"># Assemble: create object files from assembler source files.</span>
<span class="nf">%.o </span><span class="o">:</span> %.<span class="n">S</span>
	@echo
	@echo <span class="k">$(</span>MSG_ASSEMBLING<span class="k">)</span> $&lt;
	<span class="k">$(</span>CC<span class="k">)</span> -c <span class="k">$(</span>ALL_ASFLAGS<span class="k">)</span> $&lt; -o <span class="nv">$@</span>



<span class="c"># Target: clean project.</span>
<span class="nf">clean</span><span class="o">:</span> <span class="n">begin</span> <span class="n">clean_list</span> <span class="n">finished</span> <span class="n">end</span>

<span class="nf">clean_list </span><span class="o">:</span>
	@echo
	@echo <span class="k">$(</span>MSG_CLEANING<span class="k">)</span>
	<span class="k">$(</span>REMOVE<span class="k">)</span> <span class="k">$(</span>TARGET<span class="k">)</span>.hex
	<span class="k">$(</span>REMOVE<span class="k">)</span> <span class="k">$(</span>TARGET<span class="k">)</span>.eep
	<span class="k">$(</span>REMOVE<span class="k">)</span> <span class="k">$(</span>TARGET<span class="k">)</span>.obj
	<span class="k">$(</span>REMOVE<span class="k">)</span> <span class="k">$(</span>TARGET<span class="k">)</span>.cof
	<span class="k">$(</span>REMOVE<span class="k">)</span> <span class="k">$(</span>TARGET<span class="k">)</span>.elf
	<span class="k">$(</span>REMOVE<span class="k">)</span> <span class="k">$(</span>TARGET<span class="k">)</span>.map
	<span class="k">$(</span>REMOVE<span class="k">)</span> <span class="k">$(</span>TARGET<span class="k">)</span>.obj
	<span class="k">$(</span>REMOVE<span class="k">)</span> <span class="k">$(</span>TARGET<span class="k">)</span>.a90
	<span class="k">$(</span>REMOVE<span class="k">)</span> <span class="k">$(</span>TARGET<span class="k">)</span>.sym
	<span class="k">$(</span>REMOVE<span class="k">)</span> <span class="k">$(</span>TARGET<span class="k">)</span>.lnk
	<span class="k">$(</span>REMOVE<span class="k">)</span> <span class="k">$(</span>TARGET<span class="k">)</span>.lss
	<span class="k">$(</span>REMOVE<span class="k">)</span> <span class="k">$(</span>OBJ<span class="k">)</span>
	<span class="k">$(</span>REMOVE<span class="k">)</span> <span class="k">$(</span>LST<span class="k">)</span>
	<span class="k">$(</span>REMOVE<span class="k">)</span> <span class="k">$(</span>SRC:.c<span class="o">=</span>.s<span class="k">)</span>
	<span class="k">$(</span>REMOVE<span class="k">)</span> <span class="k">$(</span>SRC:.c<span class="o">=</span>.d<span class="k">)</span>
	<span class="k">$(</span>REMOVE<span class="k">)</span> .dep/*



<span class="c"># Include the dependency files.</span>
<span class="cp">-include $(shell mkdir .dep 2&gt;/dev/null) $(wildcard .dep/*)</span>


<span class="c"># Listing of phony targets.</span>
<span class="nf">.PHONY </span><span class="o">:</span> <span class="n">all</span> <span class="n">begin</span> <span class="n">finish</span> <span class="n">end</span> <span class="n">sizebefore</span> <span class="n">sizeafter</span> <span class="n">gccversion</span> \
<span class="n">build</span> <span class="n">elf</span> <span class="n">hex</span> <span class="n">eep</span> <span class="n">lss</span> <span class="n">sym</span> <span class="n">coff</span> <span class="n">extcoff</span> \
<span class="n">clean</span> <span class="n">clean_list</span> <span class="n">program</span>
</pre></div>
</td></tr></table></div><p>
Zusätzlich muss das Makefile an das eigene Projekt angepasst werden:</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="c"># MCU name</span>
<span class="nv">MCU</span> <span class="o">=</span> atmega16
</pre></div>
</td></tr></table></div><p>
Hier muss der verwendete Mikrocontroller eingetragen werden.</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="c"># Main Oscillator Frequency</span>
<span class="c"># This is only used to define F_OSC in all assembler and c-sources.</span>
<span class="nv">F_OSC</span> <span class="o">=</span> <span class="m">3686400</span>
</pre></div>
</td></tr></table></div><p>
Hier wird die verwendete Taktrate angegeben. Wird diese falsch angegeben, stimmen Timerzeiten nicht und Schnittstellen wie <a class="interwiki interwiki-wikipedia" href="https://de.wikipedia.org/wiki/UART">UART</a> funktionieren nicht mehr. Kauft man einen neuen AVR, so ist der intern erzeugte Standardtakt meist 1 MHz (beim ATtiny13A 1,2 MHz).</p><p>Etwas weiter unten (etwas Mitte des Skripts) findet man dann folgendes:</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="c"># Programming support using avrdude. Settings and variables.</span>

<span class="c"># Programming hardware: alf avr910 avrisp bascom bsd </span>
<span class="c"># dt006 pavr picoweb pony-stk200 sp12 stk200 stk500</span>
<span class="c">#</span>
<span class="c"># Type: avrdude -c ?</span>
<span class="c"># to get a full listing.</span>
<span class="c">#</span>
<span class="nv">AVRDUDE_PROGRAMMER</span> <span class="o">=</span> stk500
</pre></div>
</td></tr></table></div><p>
Hier wird der verwendete Programmer eingetragen, z.B. USBasp.</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="c"># com1 = serial port. Use lpt1 to connect to parallel port.</span>
<span class="nv">AVRDUDE_PORT</span> <span class="o">=</span> usb    <span class="c1"># programmer connected to serial device</span>
</pre></div>
</td></tr></table></div><p>
Hier wird festgelegt, wie sich avrdude mit dem Programmer verbindet. Im Fall des USBasp ist <code class="notranslate">usb</code> die richtige Angabe.</p><p>Des Weiteren hat der normale Benutzer unter Ubuntu meist nicht die Rechte, den Programmer zu verwenden. Im einfachsten Fall kann man mit Hilfe einer <a class="internal" href="./udev.html">udev</a>-Regel dem Benutzer diese Rechte verschaffen. Dazu muss folgender Text nach <strong>/etc/udev/rules.d/99_usbprog.rules</strong> kopiert werden:</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span># Atmel AVR ISP mkII
SUBSYSTEM=="usb", ATTRS{idVendor}=="03eb", ATTRS{idProduct}=="2104", GROUP="plugdev", MODE="0660" 

# usbprog bootloader
ATTRS{idVendor}=="1781", ATTRS{idProduct}=="0c62", GROUP="plugdev", MODE="0660"
 
# USBasp programmer
ATTRS{idVendor}=="16c0", ATTRS{idProduct}=="05dc", GROUP="plugdev", MODE="0660"
 
# USBtiny programmer
ATTRS{idVendor}=="1781", ATTRS{idProduct}=="0c9f", GROUP="plugdev", MODE="0660"
</pre></div>
</td></tr></table></div><p>
Damit sollten die meist benutzen Programmer abgedeckt sein. Sollte man einen anderen Programmer haben, so kann man ihn nach diesem Schema hinzufügen. Die Nummer <code class="notranslate">idVendor</code> und <code class="notranslate">idProdukt</code> findet man über das Terminal <sup><a href="#source-2">[2]</a></sup> mit Hilfe</p><div class="bash"><div class="contents"><pre class="notranslate">lsusb </pre></div></div><p>
während der Programmer angesteckt ist. Nach dem die Datei angelegt wurde, muss der Programmer ab- und wieder angesteckt werden, damit die Regel übernommen wird.</p></div><div class="section_2"><h3 id="Schreiben-eines-Programms-2">Schreiben eines Programms<a class="headerlink" href="#Schreiben-eines-Programms-2">¶</a></h3><p>
In diesem Schritt wird dem Mikrocontroller gesagt, was er zu tun hat. Dazu müssen die entsprechenden Anweisungen in die eben gespeicherte <strong>main.c</strong> geschrieben werden. Ein Grundgerüst für diesen Quelltext sieht folgendermaßen aus:</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;avr/io.h&gt;			// Einbinden von Einstellungen/Definitionen/usw. für den Mikrocontroller</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>				<span class="c1">// Hauptprogramm, hier startet der Mikrocontroller</span>
<span class="p">{</span>
	<span class="c1">// Initialisierung</span>
	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>			<span class="c1">// Nie endende Hauptschleife (Endlosschleife)</span>
	<span class="p">{</span>
	<span class="c1">// Einlesen</span>
	<span class="c1">// Verarbeiten</span>
	<span class="c1">// Ausgeben</span>
	<span class="p">}</span>				<span class="c1">// Ende der Endlosschleife (Es wird wieder zu "while(1)" gesprungen)</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>			<span class="c1">// Wird nie erreicht, aber ohne schreibt der GCC eine Warnung</span>
<span class="p">}</span>					<span class="c1">// Ende des Hauptprogramms</span>
</pre></div>
</td></tr></table></div><p>
Dieses Programm könnte man jetzt auch schon übersetzen und auf einen Mikrocontroller übertragen. Allerdings wird man keinen Unterschied zu einem unprogrammierten Mikrocontroller erkennen, da das Programm bis jetzt noch nichts macht, außer in einer Endlosschleife zu rotieren, was man von Außen nicht sehen kann.</p><p>Nun kann man das Programm beispielsweise folgendermaßen erweitern:</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;avr/io.h&gt;			// Einbinden von Einstellungen/Definitionen/usw. für den Mikrocontroller</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;util/delay.h&gt;			// Einbinden der _delay_ms()-Funktion um Wartezeiten zu erzeugen</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>				<span class="c1">// Hauptprogramm, hier startet der Mikrocontroller</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">zwischenspeicher</span><span class="p">;</span>		<span class="c1">// Initialisierung</span>
	<span class="n">DDRA</span> <span class="o">=</span> <span class="mi">0</span><span class="n">b00000001</span><span class="p">;</span>		
	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>			<span class="c1">// Nie endende Hauptschleife (Endlosschleife)</span>
	<span class="p">{</span>
		<span class="n">zwischenspeicher</span> <span class="o">=</span> <span class="n">PORTA</span><span class="p">;</span>				<span class="c1">// Einlesen</span>
		<span class="n">zwischenspeicher</span> <span class="o">=</span> <span class="n">zwischenspeicher</span> <span class="o">^</span> <span class="mi">0</span><span class="n">b00000001</span><span class="p">;</span>	<span class="c1">// Verarbeiten</span>
		<span class="n">PORTA</span> <span class="o">=</span> <span class="n">zwischenspeicher</span><span class="p">;</span>				<span class="c1">// Ausgeben</span>
		<span class="n">_delay_ms</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>						<span class="c1">// Wartezeit von 500ms</span>
	<span class="p">}</span>				<span class="c1">// Ende der Endlosschleife (Es wird wieder zu "while(1)" gesprungen)</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>			<span class="c1">// Wird nie erreicht, aber ohne schreibt der GCC eine Warnung</span>
<span class="p">}</span>					<span class="c1">// Ende des Hauptprogramms</span>
</pre></div>
</td></tr></table></div><p>Eine kurze Erklärung zum Quellcode:</p><ol class="arabic"><li><p>Initialisierung: Zuerst wird die Variable <code class="notranslate">zwischenspeicher</code> angelegt, diese ist 8 Bit breit und kann somit eine Ganzzahl von 0-255 aufnehmen. Eine Zeile weiter wird ein Ausgang erstellt. Bei AVRs sind die Pins in Ports zu jeweils 8 Pins zusammengefasst. Jeder Port hat somit so viele Pins, wie ein Byte Bits hat. Damit steht jedes Bit im Byte (0b00000001) für einen Pin des Port A (DDRA). Man kann jetzt sehen, dass die sieben höherwertigen Pins eine 0 und der niederwertigste Pins eine 1 in deren DDR-Register geschrieben bekommen. Das hat zur Folge, dass der niederwertigste PortA-Pin (PA0) zu einem Ausgang wird. Das heißt <code class="notranslate">0</code> = Eingang und <code class="notranslate">1</code> = Ausgang.</p></li><li><p>Einlesen: Nun folgt das Einlesen des Status eines Ausgangs. Da man nicht einen Pin alleine auslesen kann, sondern immer nur einen ganzen Port, wird der ganze 8 Pins breite Port in die ebenfalls 8 Bit breite Variable <code class="notranslate">zwischenspeicher</code> kopiert. Dort ist nun abgelegt, welcher Ausgang high (1) und welcher low (0) ist.</p></li><li><p>Verarbeiten: Als nächstes soll der Status des niederwertigsten Bits von <code class="notranslate">zwischenspeicher</code> umgekehrt werden. Dies ist mit der logischen Verknüpfung <a class="interwiki interwiki-wikipedia" href="https://de.wikipedia.org/wiki/Xor">XOR</a> am einfachsten. Alle Bits, die in dem rechten Byte 1 sind werden umgekehrt.</p></li><li><p>Ausgeben: Da das niederwertigste Bit jetzt umgekehrt ist, kann der Inhalt von <code class="notranslate">zwischenspeicher</code> wieder ausgegeben werden.</p></li><li><p>Wartezeit: Ein Mikrocontroller arbeitet sehr schnell, deshalb wird eine Wartezeit eingebaut, damit man nachverfolgen kann, was der Mikrocontroller macht. Ohne diese Wartezeit würde das Programm so schnell ablaufen, dass ein Mensch dies nicht mehr wahrnehmen kann.</p></li></ol><p>Anschließend kommt der Mikrocontroller bei der Ausführung am Ende der while-Schleife an. Das hat zur Folge, dass er wieder zu <code class="notranslate">while(1)</code> springt und das Programm wieder von vorne ausführt.</p><p>Das Programm macht nun nichts anderes, als ständig Pin 0 des Ports A (PA0) abwechselnd auf High und Low zu setzen, d.h. abwechselnd liegen dort 0V und 5V (bei einem 5V Controller) an. Jetzt kann man dort eine Leuchtdiode mit passendem Widerstand anschließen und diese leuchtet dann ein Mal pro Sekunde auf.</p><p>Dies soll nur ein kurzes einführendes Beispiel darstellen. Wie das Programmieren von AVRs genau funktioniert, kann man zum Beispiel der Anleitung <a class="external" href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial" rel="nofollow">AVR-GCC-Tutorial</a> <img alt="{de}" src="./_/ffd333e1d59794eac31aea8b3e984e1b88473c33.png"/> entnehmen. Dort wird zwar nur auf die AVRs an sich und nicht auf die Grundelemente von C eingegangen, aber es werden C-Tutorials verlinkt.</p></div><div class="section_2"><h3 id="bersetzen-des-Programms-2">Übersetzen des Programms<a class="headerlink" href="#bersetzen-des-Programms-2">¶</a></h3><p>
Da der AVR nur Maschinensprache und kein C versteht, muss der soeben erstellte Quelltext in Maschinensprache übersetzt werden. Dazu wird das weiter oben erwähnte Programm <strong>gcc-avr</strong> und dessen Zusätze <strong>avr-libc</strong>, sowie <strong>binutils-avr</strong> benötigt.</p><p>Um den Quelltext jetzt zu übersetzen, muss man in den Projektordner wechseln und dort ein <code class="notranslate">make all</code> im Terminal <sup><a href="#source-2">[2]</a></sup> ausführen. Das Programm make sieht dann im Makefile nach, welche Aufgaben bei Verwendung des Parameters <code class="notranslate">all</code> vorgesehen sind. Unter anderem ist dies die Übersetzung des Programms durch AVR-GCC in Maschinensprache.</p><p>Anstatt den Befehl im Terminal auszuführen, kann dieser in die Entwicklungsumgebung bzw. den Editor eingebunden werden. Ist das wie oben am Beispiel Geany schon geschehen, so muss man nur noch die entsprechende Schaltfläche drücken und alles läuft automatisch ab. Im Fall von Geany ist das die Schaltfläche <em>"Kompilieren"</em> <img alt="Geany_kompilierenButton.png" class="image-default" src="./_/941a2c6eee91c1a98aa22be2f947fccbdf1c87b3.png"/>. Alternativ funktioniert auch das Tastenkürzel 
<span class="key">F8</span> .</p><p>Wenn der Kompiler AVR-GCC das Programm ohne Probleme übersetzen kann, so wird das im Compiler-Fenster von Geany angezeigt und im Projektordner wird eine Datei mit Namen <strong>main.hex</strong> angelegt. Darin befindet sich das Programm in Maschinensprache. Kann der AVR-GCC einen Befehl nicht verstehen, weil man sich beispielsweise vertippt hat, so wird eine Fehlermeldung im Compiler-Fenster ausgegeben.</p></div><div class="section_2"><h3 id="Programm-aufspielen-2">Programm aufspielen<a class="headerlink" href="#Programm-aufspielen-2">¶</a></h3><p>
Da das Programm jetzt in Maschinensprache vorhanden ist, kann es auf den Mikrocontroller übertragen werden, sofern die folgenden Voraussetzungen erfüllt sind:</p><ul><li><p>Eine <a class="crosslink" href="#Grundschaltungen">Grundschaltung</a> mit passendem <a class="crosslink" href="#Programmierwerkzeug">Programmierwerkzeug</a> ist vorhanden</p></li><li><p>Das Programm avrdude ist installiert und im Makefile für den entsprechenden Programmieradapter richtig konfiguriert. Außerdem hat der Benutzer die entsprechende Rechte, mit dem Programmer zu arbeiten (siehe <a class="crosslink" href="#Einrichten-einer-Entwicklungsumgebung">Einrichten einer Entwicklungsumgebung</a>).</p></li></ul><p>
Sofern diese Bedingungen erfüllt sind und alle Komponenten korrekt miteinander verbunden sind, so kann im Projektordner im Terminal <sup><a href="#source-2">[2]</a></sup> <code class="notranslate">make program</code> ausgeführt werden. Natürlich kann man sich alternativ die Entwicklungsumgebung entsprechend einrichten. Ist das wie oben am Beispiel Geany gezeigt, schon geschehen, so muss man nur noch die entsprechende Schaltfläche drücken. Im Fall von Geany ist das die Schalftfläche <em>"Erstellen"</em> <img alt="Geany_erstellenButton.png" class="image-default" src="./_/a0ee1ad8ea49b073c996b10f5452139a2d70d030.png"/>. Alternativ funktioniert dies ebenfalls über 
<span class="key">F9</span> .</p><p>Hiermit wird wiederum avrdude aufgerufen, welches dann über den Programmieradapter eine Verbindung zum Mikrocontroller aufbaut und das Programm in Maschinensprache überträgt. Der Controller speichert dieses in seinem <a class="interwiki interwiki-wikipedia" href="https://de.wikipedia.org/wiki/Flash-Speicher">Flash-Speicher</a>. Sobald avrdude das Programm komplett übertragen hat (es kann einige Sekunden dauern), beginnt der Mikrocontroller sofort damit, das Programm auszuführen.</p></div></div><div class="section_1"><h2 id="Debugmoeglichkeiten">Debugmöglichkeiten<a class="headerlink" href="#Debugmoeglichkeiten">¶</a></h2><p>
Mit einem <a class="interwiki interwiki-wikipedia" href="https://de.wikipedia.org/wiki/Debugger">Debugger</a> können die einzelnen Programmanweisungen Schritt für Schritt nachvollzogen werden, während das Programm auf dem Mikrocontroller läuft. Dies erleichtert das Auffinden von Fehlern im Programm. Man kann dies beispielsweise folgendermaßen tun:</p><ul><li><p>An einem bestimmten Punkt im Programm eine LED blinken lassen, um zu sehen, dass der Mikrocontroller diesen Punkt soeben erreicht hat.</p></li><li><p>Mit Hilfe einer LED kann man Registerinhalte per Blinkzeichen ausgeben; zum Beispiel jedes Bit eines Bytes einzeln, und zwar jeweils ein langes Aufblinken für eine 1 und ein kurzes Aufblinken für eine 0.</p></li><li><p>An mehreren stellen im Programm Texte auf einem LC-Display ausgeben oder mithilfe des UART an den Computer senden.</p></li><li><p>Die für Debugzwecke vorgesehene JTAG-Schnittstelle des Mikrocontrollers verwenden. Dazu benötigt man zusätzliche Hardware und zum Einstieg in die Mikrocontrollerwelt reichen die beiden erstgenannten Debugmöglichkeiten aus.</p></li></ul><p>
</p></div><div class="section_1"><h2 id="Fehlerbehandlung">Fehlerbehandlung<a class="headerlink" href="#Fehlerbehandlung">¶</a></h2><p>
</p><div class="section_2"><h3 id="Programmer-wird-nicht-erkannt">Programmer wird nicht erkannt<a class="headerlink" href="#Programmer-wird-nicht-erkannt">¶</a></h3><p>
Die Fehlermeldung dazu kann zum Beispiel folgendermaßen aussehen:</p><pre class="notranslate">avrdude: error: could not find USB device "USBasp" with vid=0x16c0 pid=0x5dc</pre><p>
Dies kann folgende Ursachen haben:</p><ul><li><p>Der Benutzer, der den Mikrocontroller programmieren möchte, hat nicht die Rechte, auf den jeweiligen Programmieradapter zuzugreifen. Dies kann man überprüfen, indem man das "make program" als Root ausführt. Wird der Programmer dann erkannt, liegt ein Rechte-Problem vor, das sich üblicherweise mit einer <a class="internal" href="./udev.html">udev</a>-Regel lösen lässt. Die Lösung ist unter <a class="crosslink" href="#Einrichten-einer-Entwicklungsumgebung">Einrichten einer Entwicklungsumgebung</a> beschrieben.</p></li><li><p>Wenn man einen Programmer-Bausatz verwendet, hat man eventuell Fehler beim Aufbauen bzw. Löten des Programmers gemacht.</p></li></ul><p>
</p></div><div class="section_2"><h3 id="AVR-wird-nicht-erkannt">AVR wird nicht erkannt<a class="headerlink" href="#AVR-wird-nicht-erkannt">¶</a></h3><p>
Eine Fehlermeldung, dass der AVR nicht erkannt wurde, kann beispielsweise so aussehen:</p><pre class="notranslate">initialization failed, rc=-1 
Double check connections and try again, or use -F to override this check </pre><p>
Die häufigsten Ursachen hierfür sind:</p><ul><li><p>Der Mikrocontroller hat keine Stromversorgung (vergessen einzuschalten o.ä.).</p></li><li><p>Eine der vier Programmierleitungen (MOSI, MISO, SCK, RESET) ist nicht korrekt verbunden (evtl. Wackelkontakt).</p></li><li><p>Der Mikrocontroller läuft aus irgendeinem Grund mit langsamem Takt und kann deswegen nur mit sehr langsamer Geschwindigkeit programmiert werden. Hier hilft die avrdude-Option  -B 60  oder  -B 600</p></li><li><p>Die sogenannten <a class="external" href="http://www.mikrocontroller.net/articles/AVR_Fuses" rel="nofollow">Fuses</a> <img alt="{de}" src="./_/ffd333e1d59794eac31aea8b3e984e1b88473c33.png"/> (Grundeinstellung des AVR) wurden falsch eingestellt. Wenn man den AVR mit den Fuses beispielsweise auf externe Taktversorgung mittels Rechteck umstellt, funktioniert auch kein Quarz mehr als Taktquelle. Dann muss man an den XTAL1-Pin ein TTL-Rechteck mit einer Frequenz von etwa 1–10 Mhz anlegen (kann man mit einem zweiten AVR erzeugen) und die Fuses des Mikrocontrollers wieder auf interne Taktquelle oder Quarz (sofern einer angeschlossen ist) umstellen.</p></li></ul><p>
</p></div></div><div class="section_1"><h2 id="Links">Links<a class="headerlink" href="#Links">¶</a></h2><p>
</p><ul><li><p><a class="external" href="http://www.atmel.com/products/microcontrollers/avr/default.aspx" rel="nofollow">Offizielle Atmel AVR Webseite</a> <img alt="{en}" src="./_/d5ecf89114b079f85d02099649c4ee617ffa34c7.png"/></p></li><li><p><a class="interwiki interwiki-wikipedia" href="https://de.wikipedia.org/wiki/Atmel_AVR">Atmel AVR</a></p></li><li><p><a class="external" href="http://www.mikrocontroller.net/articles/AVR" rel="nofollow">AVR-Tutorial auf mikrocontroller.net</a> <img alt="{de}" src="./_/ffd333e1d59794eac31aea8b3e984e1b88473c33.png"/></p></li><li><p><a class="external" href="http://www.rn-wissen.de/index.php/Avr" rel="nofollow">AVR-Artikel im Roboternetz</a> <img alt="{de}" src="./_/ffd333e1d59794eac31aea8b3e984e1b88473c33.png"/></p></li></ul><p>
</p></div></div>
<p class="meta">
<a href="./avr/a/revision/940654.html">Diese Revision</a> wurde am 9. Mai 2017 00:00 von <a href="https://ubuntuusers.de/user/ubot/">ubot</a> erstellt.
    
  </p>
</div>
</div>
<div style="clear: both;"></div>
<div class="pathbar breadcrumb">
<div class="breadcrumb">
<ol>
<li><a href="./startseite.html">Wiki</a></li>
<li><a href="./avr.html">AVR</a></li>
</ol>
</div>
</div>
</div>
<div class="footer" style="clear: both;">
<ul>
<li class="poweredby"><li class="poweredby">Erstellt mit <a href="http://inyokaproject.org/">Inyoka</a></li></li>
<li class="license">

<img alt="Copyleft" src="./_/65dad5b770326dbbe1bd26ee6363e366a76bd8b7.png"/>
          2004 – 2017 ubuntuusers.de • Einige Rechte vorbehalten<br/>
<a href="./_lizenz.html" rel="cc:morePermissions">Lizenz</a> •
          <a href="http://ubuntuusers.de/kontakt/">Kontakt</a> •
          <a href="http://ubuntuusers.de/datenschutz/">Datenschutz</a> •
          <a href="http://ubuntuusers.de/impressum/">Impressum</a> •
          <a href="https://ubuntuusers.statuspage.io">Serverstatus</a>
</li>
<li class="housing">
<span title="Unterbringung und Netzanbindung eines Servers">Serverhousing</span> gespendet von<br/>
<img alt="noris network" src="./_/e7d27e9081eec23a8a5a5fe9434d7b2f1532e1d9.png"/>
<img alt="anexia" src="./_/ad1b63a3fc35749344af0a03e8c3ce05a2a3ee7e.png"/>
</li>
</ul>
</div>
<div style="clear: both;"></div>
</div>






</body>
</html>