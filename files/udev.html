<!DOCTYPE html>
<html lang="">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>udev › ubuntuusers statisches Wiki</title>
<link href="./_/34e5d78db234405457773cc26741aada99f7fff2.css" rel="stylesheet" type="text/css"/>
<link href="./_/61af784fc5c93e296fec3be63b8e0bb48443727c.css" rel="stylesheet" type="text/css"/>
<link href="./_/634e8d1015b02df998cdec7cb07c5aff61d068b5.css" rel="stylesheet" type="text/css"/>
<link href="./_/b583ff7e37147497a59224ccf54cfee812a1d21b.css" rel="stylesheet" type="text/css"/>
<link href="./_/a0d5775ed6f36f8cc5b12bcf2f1c1bd98a3eb225.css" rel="stylesheet" type="text/css"/>
<link href="./_/98de73bded109a634cbd1e924abdd8c8964b8df2.css" media="print" rel="stylesheet" type="text/css"/>

<meta content="#a87300" name="theme-color"/>

</head>
<body>
<div class="wrap">
<div class="header">
<h1><a href="http://ubuntuusers.de/"><span>ubuntuusers.de</span></a></h1>
<ul class="tabbar">
<li class="portal">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://ubuntuusers.de/">Portal<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="forum">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://forum.ubuntuusers.de/">Forum<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="wiki active">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://wiki.ubuntuusers.de/">Wiki<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="ikhaya">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://ikhaya.ubuntuusers.de/">Ikhaya<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="planet">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://planet.ubuntuusers.de/">Planet<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="community">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://wiki.ubuntuusers.de/Mitmachen">Mitmachen<span></span></a></div>
<div class="tab_right"></div>
</li>
</ul>
</div>
<div class="body">
<div class="appheader">

<div class="pagetitle">
<h1 class="breadcrumb_title">
<a class="separator" href="./startseite.html">
              Wiki
            </a>
</h1>
<h2 class="breadcrumb_subtitle"><a href="./udev.html">udev</a></h2>
</div>
</div><div class="message staticwikinote"><strong>Hinweis:</strong> Dies ist ein statischer Snapshot unseres Wikis vom Jan. 17, 2018 und kann daher nicht bearbeitet werden. Der aktuelle Artikel ist unter <a href="http://wiki.ubuntuusers.de/udev">wiki.ubuntuusers.de</a> zu finden.</div>

<!--[if lt IE 8]>
      <div class="message fail">Bitte installiere den Internet Explorer 8 oder neuer.</div>
      <![endif]-->
<div class="page_content">
<div class="navi_sidebar navigation">
<div class="container">
<h3 class="navi_wiki">Wiki</h3>
<ul>
<li><a href="./wiki/index.html">Index</a></li>
<li><a href="./wiki/recentchanges.html">Letzte Änderungen</a></li>
<li><a href="./wiki/neue_artikel.html">Liste neuer Artikel</a></li>
<li><a href="./wiki.html">Übersicht</a></li>
<li><a href="./wiki/faq_-_häufig_gestellte_fragen.html">FAQ</a></li>
<li><a href="./wiki/benutzung.html">Benutzung</a></li>
<li><a href="./kategorien.html">Kategorie</a></li>
<li><a href="./wiki/tagcloud.html">Wortwolke</a></li>
</ul>
<h3 class="navi_join">Mitmachen</h3>
<ul>
<li><a href="./wikiartikel_anlegen.html">Wikiartikel anlegen</a></li>
<li><a href="./howto.html">Howto anlegen</a></li>
<li><a href="./wiki/referenz.html">Wiki-Referenz</a></li>
<li><a href="./wiki/syntax.html">Wiki-Syntax</a></li>
<li><a href="./baustelle.html">Baustellen</a></li>
<li><a href="./wiki/artikelideen.html">Artikelideen</a></li>
<li><a href="./wiki/ungetestet.html">Ungetestete Artikel</a></li>
<li><a href="./wiki/vorlagen/ausbaufähig/a/backlinks.html">Ausbaufähige Artikel</a></li>
<li><a href="./wiki/vorlagen/fehlerhaft/a/backlinks.html">Fehlerhafte Artikel</a></li>
<li><a href="https://forum.ubuntuusers.de/forum/wiki/">Rund ums Wiki</a></li>
</ul>
<h3 class="navi_config">Konfiguration</h3>
<ul>
<li><a href="./udev/a/backlinks.html">Backlinks anzeigen</a></li>
<li>
        Exportieren
        <ul>
<li><a href="./udev/a/export/meta.html" rel="nofollow">Metadaten</a></li>
<li><a href="./udev/a/export/raw.html" rel="nofollow">Rohformat</a></li>
<li><a href="./udev/a/export/html.html" rel="nofollow">HTML</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div class="content content_tabbar content_sidebar">
<h1 class="pagetitle"><a href="./udev/a/backlinks.html">udev</a></h1>
<div id="page"><p>
</p><div class="box tested_for"><h3 class="box tested_for">Dieser Artikel wurde für die folgenden
Ubuntu-Versionen getestet:</h3><div class="contents"><p>
</p><ul><li><p><a class="internal" href="./xenial_xerus.html">Ubuntu 16.04</a> Xenial Xerus</p></li><li><p><a class="internal" href="./trusty_tahr.html">Ubuntu 14.04</a> Trusty Tahr</p></li></ul></div></div><p>
</p><p>
</p><div class="box advanced"><h3 class="box advanced">Artikel für fortgeschrittene Anwender</h3><div class="contents"><p>
Dieser Artikel erfordert mehr Erfahrung im Umgang mit
Linux und ist daher nur für fortgeschrittene Benutzer
gedacht.
</p></div></div><div class="box knowledge"><h3 class="box knowledge">Zum Verständnis dieses Artikels sind folgende Seiten hilfreich:</h3><div class="contents"><p>
</p><ol class="arabic"><li><p><a class="crosslink anchor" href="#source-1" id="source-1"></a> <a class="internal" href="./terminal.html">Ein Terminal öffnen</a> </p></li><li><p><a class="crosslink anchor" href="#source-2" id="source-2"></a> <a class="internal" href="./editor.html">Einen Editor öffnen</a> </p></li><li><p><a class="crosslink anchor" href="#source-3" id="source-3"></a> <a class="internal" href="./rechte.html">Rechte</a></p></li><li><p><a class="crosslink anchor" href="#source-4" id="source-4"></a> <a class="internal" href="./mount.html">Dateisysteme einhängen</a></p></li><li><p><a class="crosslink anchor" href="#source-5" id="source-5"></a> <a class="internal" href="./fstab.html">Dateisysteme über /etc/fstab fest einhängen</a>, <em>optional</em></p></li><li><p><a class="crosslink anchor" href="#source-6" id="source-6"></a> <a class="internal" href="./benutzer_und_gruppen.html">Benutzer und Gruppen</a></p></li></ol></div></div><p>
</p><div class="toc toc-depth-3"><div class="head">Inhaltsverzeichnis</div><ol class="arabic"><li><a class="crosslink" href="#Installation">Installation
</a></li><li><a class="crosslink" href="#udev-Regeln">udev-Regeln
</a></li><li><a class="crosslink" href="#Standardregeln">Standardregeln
</a><ol class="arabic"><li><a class="crosslink" href="#Beispiele-fuer-Standardregeln">Beispiele für Standardregeln
</a></li></ol></li><li><a class="crosslink" href="#Eigene-udev-Regeln">Eigene udev-Regeln
</a><ol class="arabic"><li><a class="crosslink" href="#Sinn-eigener-Regeln">Sinn eigener Regeln
</a></li><li><a class="crosslink" href="#Beispiele-fuer-eigene-Regeln">Beispiele für eigene Regeln
</a></li><li><a class="crosslink" href="#Erstellen-eigener-udev-Regeln">Erstellen eigener udev-Regeln
</a><ol class="arabic"><li><a class="crosslink" href="#Auslesen-von-Informationen">Auslesen von Informationen
</a></li><li><a class="crosslink" href="#Daten-ueber-ein-USB-Geraet-herausfinden-mit-lsusb">Daten über ein USB-Gerät herausfinden ...</a></li><li><a class="crosslink" href="#Daten-ueber-beliebige-Geraete-auslesen-mit-udevadm">Daten über beliebige Geräte auslesen m...</a></li><li><a class="crosslink" href="#Alternativen">Alternativen
</a></li><li><a class="crosslink" href="#udev-Regel-schreiben-und-speichern">udev-Regel schreiben und speichern
</a></li><li><a class="crosslink" href="#Automatischer-Start-eines-Skripts">Automatischer Start eines Skripts
</a></li><li><a class="crosslink" href="#udev-Regel-fuer-das-Entfernen-eines-Geraetes">udev-Regel für das Entfernen eines Ger...</a></li><li><a class="crosslink" href="#Neustart-des-udev-Systems">Neustart des udev-Systems
</a></li><li><a class="crosslink" href="#Funktionstest">Funktionstest
</a></li></ol></li><li><a class="crosslink" href="#Einhaengen-eines-Dateisystems">Einhängen eines Dateisystems
</a></li><li><a class="crosslink" href="#Regelsyntax">Regelsyntax
</a></li></ol></li><li><a class="crosslink" href="#Weitere-Befehle-rund-um-udev">Weitere Befehle rund um udev
</a></li><li><a class="crosslink" href="#Problembehebung">Problembehebung
</a><ol class="arabic"><li><a class="crosslink" href="#Probleme-mit-einigen-Digitalkameras">Probleme mit einigen Digitalkameras
</a></li></ol></li><li><a class="crosslink" href="#Tipps-und-Tricks">Tipps und Tricks
</a><ol class="arabic"><li><a class="crosslink" href="#Austausch-von-Netzwerkkarten">Austausch von Netzwerkkarten
</a></li><li><a class="crosslink" href="#Die-Ausgabe-von-lsusb-vs-BUS-NAME-DEVICE-NAME-ist-leer">Die Ausgabe von lsusb -vs BUS_NAME:DEVIC...</a></li><li><a class="crosslink" href="#Partition-mit-Windows-ausblenden">Partition mit Windows ausblenden
</a></li></ol></li><li><a class="crosslink" href="#Links">Links
</a></li></ol></div><p><img alt="./udev_logo.png" class="image-left" src="./_/abbb1d3d1004f234826a6b1336f3e132839249b7.png"/>
<a class="interwiki interwiki-wikipedia" href="https://de.wikipedia.org/wiki/udev">udev</a> ist ein Dienst (Hintergrundprogramm), der die Gerätedateien im Verzeichnis <strong>/dev</strong> dynamisch verwaltet. udev übernimmt außerdem die Rechteverwaltung von Geräten und legt bei Bedarf <a class="internal" href="./symlink.html">Symlinks</a> auf Gerätedateien an. Dies geschieht sowohl beim Bootvorgang als auch durch nachträgliches An- oder Abstecken eines Gerätes im laufenden Betrieb (<a class="interwiki interwiki-wikipedia" href="https://de.wikipedia.org/wiki/Hot_Swapping">Hotplug</a>). Bekommt udev vom Kernel Informationen über ein Gerät (sog. "device uevents"), wertet es diese anhand fester, aber frei konfigurierbarer Regeln aus.</p><p>Es werden auch Eingabegeräte über udev konfiguriert, da <a class="internal" href="./archiv/hal.html">HAL</a> entfällt. Weitere Hinweise hierzu findet man im Artikel <a class="internal" href="./xorg.conf.d.html">xorg.conf.d</a>.</p><div class="section_1"><h2 id="Installation">Installation<a class="headerlink" href="#Installation">¶</a></h2><p>
udev ist als Bestandteil des Pakets
</p><ul><li><p><strong>udev</strong></p></li></ul><p>unter Ubuntu bereits vorinstalliert.</p></div><div class="section_1"><h2 id="udev-Regeln">udev-Regeln<a class="headerlink" href="#udev-Regeln">¶</a></h2><p>
udev-Regeln legen fest, was passiert, wenn ein Gerät erkannt wird. Eine udev-Regel enthält dazu mindestens eine Bedingung und mindestens eine Zuweisung (<a class="crosslink" href="#Regelsyntax">Regelsyntax</a>). Treffen alle Bedingungen einer Regel auf ein Gerät zu, werden die Zuweisungen dieser Regel ausgeführt. Auf diese Weise werden auch Gerätenamen erzeugt, unter denen das Gerät anschließend im Dateisystem zur Verfügung steht. Es können mehrere Regeln auf das gleiche Gerät angewendet werden. Damit ist es möglich, zusätzlich zu den Standardregeln eigene Regeln auf dasselbe Gerät anzuwenden. Die einzelnen Regeldateien beginnen mit einer zweistelligen Zahl und werden in alphanumerischer Reihenfolge abgearbeitet. So ist sichergestellt, dass wichtige Regeln zuerst behandelt werden. Werden mehrere Regeln in eine Regeldatei geschrieben, werden diese zeilenweise voneinander getrennt.</p></div><div class="section_1"><h2 id="Standardregeln">Standardregeln<a class="headerlink" href="#Standardregeln">¶</a></h2><p>
Die Standardregeln liegen in <strong>/lib/udev/rules.d/</strong>. Einige Systemregeln, z.B. für Netzwerkkarten, sind auch unter <strong>/etc/udev/rules.d/</strong> zu finden.</p><div class="section_2"><h3 id="Beispiele-fuer-Standardregeln">Beispiele für Standardregeln<a class="headerlink" href="#Beispiele-fuer-Standardregeln">¶</a></h3><p>
Das folgende Beispiel zeigt eine Standardregel aus der Datei <strong>/lib/udev/rules.d/50-udev-default.rules</strong>. Sie besagt: Gehört ein erkanntes Gerät zum Subsystem "<code class="notranslate">block</code>", wird ihm die Gruppe "<code class="notranslate">disk</code>"<sup><a href="#source-6">[6]</a></sup> zugewiesen.</p><pre class="notranslate"># Block
SUBSYSTEM=="block", GROUP="disk"</pre><p>
Die nächste Regel ist etwas länger: Wird ein Gerät im Subsystem "<code class="notranslate">net</code>" mit der MAC-Adresse <code class="notranslate">57:04:b6:c2:6c:z3</code> erkannt, erhält es den Namen "<code class="notranslate">eth0</code>", eine Gerätedatei wird unter Linux für Netzwerkschnittstellen nicht angelegt.</p><pre class="notranslate">SUBSYSTEM=="net", ACTION=="add", DRIVERS=="?*", ATTR{address}=="57:04:b6:c2:6c:z3", ATTR{dev_id}=="0x0", ATTR{type}=="1", KERNEL=="eth*", NAME="eth0" </pre></div></div><div class="section_1"><h2 id="Eigene-udev-Regeln">Eigene udev-Regeln<a class="headerlink" href="#Eigene-udev-Regeln">¶</a></h2><p>
</p><div class="section_2"><h3 id="Sinn-eigener-Regeln">Sinn eigener Regeln<a class="headerlink" href="#Sinn-eigener-Regeln">¶</a></h3><p>
Standardmäßig werden Gerätenamen unter Linux "hochgezählt". So heißt z.B. der erste USB-Stick <strong>/dev/sdb1</strong>, der zweite <strong>/dev/sdc1</strong>. Das System kennt zunächst keinen Unterschied zwischen beiden Sticks. Das bringt einige Nachteile mit sich, wie folgende Beispiele zeigen:</p><ul><li><p>Auf einer USB-Festplatte liegen <strong>.mp3</strong>-Dateien. Da die Platte immer anders eingebunden wird, wird die Sammlung vom Mediaplayer immer neu eingelesen. </p></li><li><p>Ein Gerät verschwindet plötzlich aus dem System, Gerätedateien wie z.B. <strong>/dev/cdrom</strong> funktionieren nicht mehr. Der Grund: SCSI-Geräte werden bei Fehlern einfach "hochgezählt" und fehlerhafte Gerätedateien verworfen. Ein zunächst als <strong>sr0</strong> eingebundenes Gerät heißt nach einem Trennen der Verbindung ("disconnect") etwa <strong>sr1</strong>, und der zugehörige Verweis von <strong>/dev/cdrom</strong> auf <strong>/dev/sr0</strong> ist dann nicht mehr verwendbar.</p></li><li><p>Ein Skript soll von oder zu einem Laufwerk kopieren (z.B. bei der Datensicherung oder beim Kopieren von SD-Karten), ohne von der Gerätebezeichnung abhängig zu sein.</p></li></ul><p>
Durch die Verwendung eigener Regeln ist es möglich, Geräte mit eindeutig zugeordneten Gerätenamen im Dateisystem einzubinden (siehe <a class="crosslink" href="#Erstellen-eigener-Regeln">Erstellen eigener Regeln</a>). Durch die umfangreichen Möglichkeiten von udev lässt sich auch erreichen, dass beim Anstecken eines Gerätes ein Skript ausgeführt wird. Das kann z.B. sehr hilfreich für die Datensicherung sein (siehe <a class="crosslink" href="#Automatischer-Start-eines-Skripts">Automatischer Start eines Skripts</a>).</p><div class="box notice"><h3 class="box notice">Hinweis:</h3><div class="contents"><p>Man unterscheidet das Einbinden von Geräten vom Einhängen eines Dateisystems. Dateisysteme auf externen (USB-)Geräten werden standardmäßig mit dem Partitionsnamen (Label) oder der <a class="internal" href="./uuid.html">UUID</a> in das Verzeichnis <strong>/media</strong> eingehängt - unabhängig vom Gerätenamen. Dadurch wird zwar eine gewisse Eindeutigkeit in der Verzeichnisstruktur gewährleistet, die aber bei einer Neuformatierung des Datenträgers wieder verlorengeht.</p><p>Im Gegensatz dazu kümmern sich udev-Regeln zuerst um das Einbinden des Geräts mit einem eindeutigen Namen in das Verzeichnis <strong>/dev/</strong>. Sie können sich dazu an Kriterien orientieren, die fester und eindeutiger an das Gerät gebunden sind.
</p></div></div></div><div class="section_2"><h3 id="Beispiele-fuer-eigene-Regeln">Beispiele für eigene Regeln<a class="headerlink" href="#Beispiele-fuer-eigene-Regeln">¶</a></h3><p>
</p><ul><li><p>Es wird für eine USB-Festplatte mit der Seriennummer <code class="notranslate">ABCDEF012345</code> die Gerätedatei <strong>/dev/musik</strong> als <a class="internal" href="./symlink.html">Symlink</a> erzeugt: </p><pre class="notranslate"># Beispiel 1: USB HDD Musik
KERNEL=="sd?1", SUBSYSTEMS=="usb", ATTRS{serial}=="ABCDEF012345", SYMLINK+="musik"</pre></li><li><p>Für ein externes USB-DVD-Laufwerk mit der Modellbezeichnung "<code class="notranslate">DVD-ROM GDR8163B</code>" wird der Gerätenamen <strong>/dev/dvd-rom-lg</strong> als Symlink erzeugt: </p><pre class="notranslate"># Beispiel 2: externes LG DVD-ROM
KERNEL=="sr?", SUBSYSTEMS=="usb", ATTRS{model}=="DVD-ROM GDR8163B", SYMLINK+="dvd-rom-lg"</pre></li><li><p>Ein USB-Stick, der die Herstellernummer "<code class="notranslate">0204</code>" und die Produktnummer "<code class="notranslate">0275</code>" übermittelt, wird als <strong>/dev/usbstick</strong> erzeugt und ein Skript <strong>/usr/local/bin/usbstick-backup</strong> gestartet: </p><pre class="notranslate"># Beispiel 3: USB-Stick für Backups
KERNEL=="sd?1", SUBSYSTEMS=="usb", ATTRS{idVendor}=="0204", ATTRS{idProduct}=="0275", SYMLINK+="usbstick", ACTION=="add", RUN+="/usr/local/bin/usbstick-backup"</pre></li><li><p>Ein Mobilgerät am USB-Port wird für den Zugriff als normaler Benutzer freigeschaltet. Das erleichtert eine Synchronisierung: </p><pre class="notranslate"># Beispiel 4: Handy
SUBSYSTEMS=="usb", ATTRS{serial}=="123456789123456789", OWNER="benutzername"</pre></li><li><p>Eine Tastatur, mit der Herstellernummer "<code class="notranslate">046d</code>" und die Produktnummer "<code class="notranslate">c519</code>" aktiviert/deaktiviert Numlock, beim ein/ausstecken <a class="footnote" href="#fn-1" id="bfn-1"><span class="paren">[</span>1<span class="paren">]</span></a> : </p><pre class="notranslate"># Beispiel 5: Numlock
# &lt;BENUTZERNAME&gt; muss angepasst werden und das Packet numlockx installiert sein
ATTRS{idVendor}=="046d", ATTRS{idProduct}=="c519", ACTION=="add", RUN+="/bin/su &lt;BENUTZERNAME&gt; -c 'DISPLAY=:0 /usr/bin/numlockx on'"
ENV{ID_VENDOR_ID}=="046d", ENV{ID_MODEL_ID}=="c519", ACTION=="remove", RUN+="/bin/su &lt;BENUZTERNAME&gt; -c 'DISPLAY=:0 /usr/bin/numlockx off'"</pre></li></ul><p>
</p></div><div class="section_2"><h3 id="Erstellen-eigener-udev-Regeln">Erstellen eigener udev-Regeln<a class="headerlink" href="#Erstellen-eigener-udev-Regeln">¶</a></h3><p>
Hier wird die Erstellung eigener udev-Regeln am Beispiel einer USB-Festplatte und eines externen USB-DVD-Laufwerks erklärt. Die Aufgabe ist, die USB-Festplatte beim Einschalten oder Anstecken automatisch einzubinden und ein Backup-Skript zu starten, um bequem eine Datensicherung durchzuführen. Die Aufgabe für das DVD-Laufwerk ist simpler. Letztlich geht es darum, dass das Gerät immer unter einem spezifischen Gerätenamen verfügbar ist.</p><div class="section_3"><h4 id="Auslesen-von-Informationen">Auslesen von Informationen<a class="headerlink" href="#Auslesen-von-Informationen">¶</a></h4><p>
Zunächst müssen möglichst eindeutige Informationen über das jeweilige Gerät ausgelesen werden.</p><p>Als Kriterien für eine udev-Regel empfiehlt sich insbesondere:</p><ul><li><p>Die Seriennummer des Geräts (falls vorhanden und nicht <code class="notranslate">NULL</code>).</p></li><li><p>Die Kombination aus Herstellerkennung und Produktkennung.</p></li><li><p>Die Kombination aus Hersteller und Modellbezeichnung.</p></li></ul><p>
Informationen kann man auf mehrerlei Weise sammeln. Je nachdem, um was für ein Gerät es sich handelt (und wie es angeschlossen wurde), eignen sich hierfür unterschiedliche Werkzeuge. Als Universalwerkzeug kann <strong>udevadm</strong> eingesetzt werden.</p></div><div class="section_3"><h4 id="Daten-ueber-ein-USB-Geraet-herausfinden-mit-lsusb">Daten über ein USB-Gerät herausfinden mit lsusb<a class="headerlink" href="#Daten-ueber-ein-USB-Geraet-herausfinden-mit-lsusb">¶</a></h4><p>
Zunächst die USB-Festplatte: Zuerst sollte man das Gerät anstecken oder einschalten. Standardmäßig wird das Dateisystem dabei automatisch eingehängt, was sich mit <code class="notranslate">mount</code><sup><a href="#source-4">[4]</a></sup> überprüfen lässt.</p><div class="bash"><div class="contents"><pre class="notranslate">mount </pre></div></div><p>
Gekürzte Ausgabe:
</p><pre class="notranslate">/dev/sdb1 on /media/EE80-57H2</pre><p>
Die Partition wurde als <strong>/dev/sdb1</strong> eingebunden, das Dateisystem ist unter <strong>/media/EE80-57H2</strong> eingehängt.</p><p>Jetzt führt man folgenden Befehl aus:</p><div class="bash"><div class="contents"><pre class="notranslate">lsusb </pre></div></div><p>
Die Ausgabe sieht dann in etwa wie folgt aus:</p><pre class="notranslate">Bus 005 Device 036: ID 04b4:6830 Cypress Semiconductor Corp. USB-2.0 IDE Adapter
Bus 005 Device 033: ID 144d:c019
Bus 005 Device 001: ID 0000:0000
Bus 001 Device 001: ID 0000:0000
Bus 003 Device 001: ID 0000:0000
Bus 004 Device 001: ID 0000:0000
Bus 002 Device 001: ID 0000:0000</pre><p>
Anhand der Bus-Nummer und der Device-Nummer fragt man jetzt mit der Option <code class="notranslate">-v</code> detailliertere Informationen über das Gerät ab:</p><div class="bash"><div class="contents"><pre class="notranslate">sudo lsusb -vs  005:036 </pre></div></div><pre class="notranslate">Bus 005 Device 013: ID 04b4:6830 Cypress Semiconductor Corp. USB-2.0 IDE Adapter
Device Descriptor:
  bLength                18
  bDescriptorType         1
  bcdUSB               2.00
  bDeviceClass            0 (Defined at Interface level)
  bDeviceSubClass         0
  bDeviceProtocol         0
  bMaxPacketSize0        64
  idVendor           0x0ab4 Cypress Semiconductor Corp.
  idProduct          0x685a USB-2.0 IDE Adapter
  bcdDevice            0.01
  iManufacturer          56 Cypress Semiconductor
  iProduct               78 USB2.0 Storage Device
  iSerial               100 ABCDEF012345
  bNumConfigurations      1</pre><p>Interessant sind vor allem die Zeilen <code class="notranslate">idVendor</code>, <code class="notranslate">idProduct</code> und <code class="notranslate">iSerial</code>, da sich ihre Werte wegen ihrer Eindeutigkeit relativ gut für eine udev-Regel verwenden lassen. Mit diesen Angaben lassen sich bereits funktionierende Bedingungen für eine eigene udev-Regel bauen. Weiter mit <a class="crosslink" href="#udev-Regel-schreiben-und-speichern">udev-Regel schreiben und speichern</a>.</p></div><div class="section_3"><h4 id="Daten-ueber-beliebige-Geraete-auslesen-mit-udevadm">Daten über beliebige Geräte auslesen mit udevadm<a class="headerlink" href="#Daten-ueber-beliebige-Geraete-auslesen-mit-udevadm">¶</a></h4><p>
SCSI- oder andere Geräte können eine andere Vorgehensweise nötig machen. Dazu verwendet man Angaben aus der <a class="internal" href="./logdateien.html">Logdatei</a> <strong>/var/log/syslog</strong>. Dort werden am Ende die Protokoll-Einträge des Kernels angezeigt. Mit dem Befehl:</p><div class="bash"><div class="contents"><pre class="notranslate">tail -f /var/log/syslog </pre></div></div><p>
lassen sich die letzten zehn Zeilen aus der Logdatei beobachten. Wie oben sollte man jetzt das Gerät - einen Scanner, ein SCSI-Laufwerk, ein Mobiltelefon oder eine Kamera - anstecken oder einschalten. Wenn die Erkennung des Gerätes nach ein paar Sekunden abgeschlossen ist, kann man die Ausgabe mit 
<span class="key">Strg</span>  + 
<span class="key">C</span>  abbrechen.</p><p>Eine Beispielausgabe für ein externes USB-DVD-Gerät, welches als SCSI-Gerät erkannt wird, zeigt, was nach dem Einstecken passiert:</p><pre class="notranslate">[51755.613225] usb 4-1: new high speed USB device using ehci_hcd and address 16
[51755.754296] usb 4-1: configuration #1 chosen from 1 choice
[51755.766872] scsi13 : SCSI emulation for USB Mass Storage devices
[51755.767872] usb-storage: device found at 16
[51755.767880] usb-storage: waiting for device to settle before scanning
[51760.764575] usb-storage: device scan complete
[51760.769702] scsi 13:0:0:0: CD-ROM            HL-DT-ST DVD-ROM GDR8163B 0L23 PQ: 0 ANSI: 0
[51760.790142] sr1: scsi3-mmc drive: 52x/52x cd/rw xa/form2 cdda tray
[51760.790274] sr 13:0:0:0: Attached scsi CD-ROM sr1
[51760.790372] sr 13:0:0:0: Attached scsi generic sg1 type 5</pre><p>
Wie man sieht, wurde ein externes CD-ROM-USB-Laufwerk eingesteckt, das jedoch als SCSI-Gerät erkannt und geführt wird: <strong>sr1</strong>. Eine Kontrolle im <strong>/dev/</strong>-Verzeichnis zeigt die Existenz des neuen Gerätes <strong>/dev/sr1</strong>:</p><div class="bash"><div class="contents"><pre class="notranslate">ls -l /dev/sr1 </pre></div></div><p>
Nun kann man mit dem Gerätenamen <strong>/dev/sr1</strong> genaue Informationen darüber finden, mit welchen Attributen das Gerät im System geführt wird. Diese Attribute können später 1:1 für eine udev-Regel verwendet werden. Die Eingabe des Befehls:</p><div class="bash"><div class="contents"><pre class="notranslate">udevadm info --query=all --attribute-walk --name=/dev/sr1 </pre></div></div><p>
führt meist zu einer sehr langen Ausgabe. Es ist jedoch mit ein wenig Fantasie möglich, die Spreu vom Weizen zu trennen. Die Ausgabe beginnt beim angegebenen Block-Device (in diesem Fall beim Dateisystem <strong>/dev/sr1</strong>). Anschließend folgen alle beteiligten "Elternsysteme" in aufsteigender Reihenfolge. Dies können z.B. sein</p><ul><li><p>einzelne Partitionen des Gerätes</p></li><li><p>einzelne Chipsätze, Controller</p></li><li><p>Adapter (z.B. USB auf SATA) oder Lesegeräte</p></li><li><p>Subsysteme, wie verschiedene USB Systeme (1.0, 1.1, 2.0, 3.0)</p></li><li><p>Linux-Treiber (z.B. <code class="notranslate">ehci_hcd</code>)</p></li></ul><p>
Für jedes dieser Geräte werden alle Attribute ausgegeben, die in udev-Regeln verwendet werden können. Die Ausgabe der beteiligten Elternsysteme erfolgt blockweise. Jeder Block beginnt mit:</p><pre class="notranslate">looking at ...</pre><p>
Der erste Ausgabeblock für das obige Gerät lautet z.B.:</p><pre class="notranslate">looking at device '/block/sr1':
  KERNEL=="sr1"
  SUBSYSTEM=="block"
  [...]</pre><p>
Jetzt sucht man sich ein Elternsystem, das möglichst eindeutige Attribute für das Gerät enthält. In diesem Fall ist das bereits der nächste Ausgabeblock:</p><pre class="notranslate">looking at parent device '/devices/pci0000:00/[...gekürzt]':
[...]
SUBSYSTEMS=="scsi"
[...]
ATTRS{model}=="DVD-ROM GDR8163B"
ATTRS{vendor}=="HL-DT-ST"
[...]</pre><p>
Hier nimmt man die Modellnummer (<code class="notranslate">ATTRS{model}</code>), um das DVD-Laufwerk als solches eindeutig zu erkennen. Der Unterschied zur Methode mit <code class="notranslate">lsusb</code> ist, dass man dies für beliebige Geräte anwenden kann und direkt die Attributnamen (<code class="notranslate">ATTRS{...</code>) für die Erstellung der udev-Regeln verwenden kann. Beliebt ist auch die Seriennummer des Gerätes, meist <code class="notranslate">ATTRS{serial}</code>.</p><div class="box notice"><h3 class="box notice">Hinweis:</h3><div class="contents"><p>Eine Kombination von Attributen aus mehreren Elternsystemen in einer udev-Regel ist nicht möglich. Es können aber problemlos Attribute aus einem Elternsystem mit Attributen des eigentlichen Geräts zu einer Bedingung kombiniert werden, was im Beispiel auch gemacht wird.
</p></div></div></div><div class="section_3"><h4 id="Alternativen">Alternativen<a class="headerlink" href="#Alternativen">¶</a></h4><p>
Als Alternative zu o.g. Methoden gibt es noch</p><div class="bash"><div class="contents"><pre class="notranslate">udevadm monitor --property </pre></div></div><p>
Da die Ausgabe aber nicht zwischen Gerät und Elternsystem unterscheidet, empfiehlt sich die Verwendung nur für routinierte Autoren von udev-Regeln.</p></div><div class="section_3"><h4 id="udev-Regel-schreiben-und-speichern">udev-Regel schreiben und speichern<a class="headerlink" href="#udev-Regel-schreiben-und-speichern">¶</a></h4><p>
Eigene udev-Regeln erstellt man in einem Editor mit Root-Rechten<sup><a href="#source-3">[3]</a></sup> und legt sie im Verzeichnis <strong>/etc/udev/rules.d/</strong> ab. Um sicher zu gehen, dass die eigenen Regeln nicht anschließend von Systemstandards überschrieben werden, sollte man den Dateinamen mit einer hohen Zahl oder ohne Zahl beginnen. Wichtig ist, dass die Dateien, die die Regeln enthalten, mit <strong>.rules</strong> enden, da sie sonst nicht ausgeführt werden. Es ist vorteilhaft für spätere Änderungen, nicht mit Kommentaren zu sparen. Beispiel:</p><pre class="notranslate"># USB-Festplatte für Backups</pre><p>
Nun geht es an das eigentliche Erstellen der udev-Regel aus den oben ermittelten Werten. Zuerst nimmt man die <code class="notranslate">KERNEL</code>-Information des Geräts selbst (also <code class="notranslate">sdb1</code> oder <code class="notranslate">sr1</code>). Da man ja will, dass die Regel auch bei anderer Nummerierung durch den Kernel zutrifft (z.B. <code class="notranslate">sdc1</code> oder <code class="notranslate">sr2</code>), sieht der erste Eintrag so aus:</p><pre class="notranslate">KERNEL=="sd?1"</pre><p>
bzw.
</p><pre class="notranslate">KERNEL=="sr?"</pre><p>
Jetzt kombiniert man diesen Eintrag mit den ermittelten Werten aus einem Elternsystem (Wurde die Abfrage mit <code class="notranslate">lsusb</code> gemacht, nimmt man einfach die ermittelten Werte und fügt sie wie folgt ein):</p><pre class="notranslate">KERNEL=="sd?1", SUBSYSTEMS=="usb", ATTRS{serial}=="Hier Serialnummer einfügen"</pre><p>
Ist die <code class="notranslate">iSerial</code> nicht gesetzt, kann man die Erkennung auch alternativ über <code class="notranslate">idProduct</code> machen:</p><pre class="notranslate">KERNEL=="sd?1", SUBSYSTEMS=="usb", ATTRS{idProduct}=="685a"</pre><p>
Oder über <code class="notranslate">idVendor</code>:</p><pre class="notranslate">KERNEL=="sd?1", SUBSYSTEMS=="usb", ATTRS{idVendor}=="0ab4"</pre><p>
Oder über eine Kombination aus beiden:</p><pre class="notranslate">KERNEL=="sd?1", SUBSYSTEMS=="usb", ATTRS{idVendor}=="0ab4", ATTRS{idProduct}=="685a"</pre><p>
Damit hat man bereits eindeutige Bedingungen für das Gerät definiert. Nun folgt die Zuweisung, hier der zusätzliche Gerätename in <strong>/dev</strong>:</p><pre class="notranslate">KERNEL=="sd?1", SUBSYSTEMS=="usb", ATTRS{serial}=="ABCDEF012345", SYMLINK+="backup"</pre><p>
Das Gerät steht dann künftig unter <strong>/dev/backup</strong> zur Verfügung.</p><div class="box notice"><h3 class="box notice">Hinweis:</h3><div class="contents"><p>In den Standardregeln wird die Zuweisung für eine Gerätedatei oft mit dem Schlüssel <code class="notranslate">NAME</code> erzeugt. Dies verleitet möglicherweise dazu, in eigenen Regeln <code class="notranslate">NAME="backup"</code> zu schreiben. udev sieht aber insgesamt nur eine Zuweisung für ein Gerät über <code class="notranslate">NAME</code> vor. Im Zweifelsfall sollte deshalb der Schlüssel <code class="notranslate">SYMLINK</code> verwendet werden, da hier mehrere Zuweisungen pro Gerät möglich sind (deshalb auch der Operator <code class="notranslate">+=</code>). So wird ein Konflikt mit einer <code class="notranslate">NAME</code>-Zuweisung in einer Standardregel vermieden.
</p></div></div><p>Mit der gleichen Methode wird die Regel für das externe DVD-Laufwerk erstellt (zweites Beispiel der Einführung). Zur näheren Bestimmung werden lediglich das Subsystem "<code class="notranslate">scsi</code>" und der Attributwert "<code class="notranslate">model</code>" verwendet. Dies genügt zur eindeutigen Bestimmung.</p><pre class="notranslate"># LG DVD-ROM
KERNEL=="sr?", SUBSYSTEMS=="scsi", ATTRS{model}=="DVD-ROM GDR8163B", SYMLINK+="dvd-rom-lg"</pre><p>
Abschließend muss die Datei gespeichert werden, z.B. als <strong>/etc/udev/rules.d/70-usb-storage-custom.rules</strong>. Ein paar Richtlinien, nach denen man die Zahl am Anfang aussuchen sollte, finden sich in der Datei <strong>/etc/udev/rules.d/README</strong>.</p></div><div class="section_3"><h4 id="Automatischer-Start-eines-Skripts">Automatischer Start eines Skripts<a class="headerlink" href="#Automatischer-Start-eines-Skripts">¶</a></h4><p>
Man kann über udev ein Skript automatisch starten lassen, wenn ein Gerät erkannt wird. Hierzu werden der udev-Regel zwei weitere Punkte hinzugefügt:</p><ol class="arabic"><li><p>Der Punkt <code class="notranslate">ACTION=="add"</code> sorgt dafür, dass die Regel nur zutrifft, wenn das Gerät neu angeschlossen wird, und sollte nach Möglichkeit verwendet werden: </p><pre class="notranslate">KERNEL=="sd?1", SUBSYSTEMS=="usb", ATTRS{serial}=="ABCDEF012345", SYMLINK+="backup", ACTION=="add", RUN+="/usr/local/bin/backup"</pre></li><li><p>Der Punkt <code class="notranslate">RUN+="/usr/local/bin/backup"</code> ruft das Skript <strong>/usr/local/bin/backup</strong> auf. Dabei muss darauf geachtet werden, dass das Skript mit vollständiger Pfadangabe aufgerufen wird. Dem Punkt <code class="notranslate">RUN</code> kann immer nur ein einzelner Befehl (mit Parametern) übergeben werden. Allerdings lassen sich über mehrere <code class="notranslate">RUN+="..."</code>-Einträge mehrere Befehle hintereinander ausführen: </p><pre class="notranslate">KERNEL=="sd?1", SUBSYSTEMS=="usb", ATTRS{serial}=="ABCDEF012345", SYMLINK+="backup", ACTION=="add", RUN+="/usr/bin/logger Starte Backup.", RUN+="/usr/local/bin/backup"</pre></li></ol><p>
In obigem Beispiel wird nach dem Anstecken der Festplatte zuerst die Zeile "Starte Backup." mit <a class="internal" href="./logger.html">logger</a> in das Systemprotokoll geschrieben und danach das Skript <strong>/usr/local/bin/backup</strong> gestartet. Voraussetzung ist eine gültige <a class="internal" href="./shebang_für_shellskripte.html#Faustregeln">Shebang-Zeile</a>. Dabei muss es sich selbst um das korrekte Einbinden kümmern:</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="ch">#!/bin/bash</span>
mkdir /media/backup
mount /dev/backup /media/backup
...
</pre></div>
</td></tr></table></div></div><div class="section_3"><h4 id="udev-Regel-fuer-das-Entfernen-eines-Geraetes">udev-Regel für das Entfernen eines Gerätes<a class="headerlink" href="#udev-Regel-fuer-das-Entfernen-eines-Geraetes">¶</a></h4><p>
Eine Regel, die beim Anschließen des Gerätes funktioniert, wird in der Regel beim Entfernen des Geräts nicht funktionieren, wenn man nur den Wert des Schlüssels <code class="notranslate">ACTION</code> von "add" auf "remove" ändert. Das liegt daran, dass auf die Speicherbereiche des Gerätes, in denen die Signaturen gespeichert sind, nicht mehr zugegriffen werden kann, da das Gerät ja nicht mehr vorhanden ist. Daher muss hier ein anderer Ansatz gewählt werden, um das entfernte Gerät dennoch zu identifizieren. Udev speichert zu jedem Gerät Informationen in den Environment-Variablen. Diese kann man mit dem Befehl:</p><div class="bash"><div class="contents"><pre class="notranslate">udevadm monitor --env </pre></div></div><p>
überwachen. Wenn man jetzt das Gerät entfernt, kann man die Ausgabe nach den bekannten Werten für die Identifikation untersuchen. In folgender Tabelle sind beispielhaft einander entsprechende Ausgaben von <code class="notranslate">lsusb -sv xxxx:yyyy</code> und <code class="notranslate">udevadm monitor --env</code> gegenübergestellt.</p><p>
</p><table><tr class="titel"><td colspan="2"> Ausgaben der beiden Befehle, die einander entsprechen </td></tr><tr class="kopf"><td> <code class="notranslate">lsusb -sv</code> </td><td> <code class="notranslate">udevadm monitor --env</code> </td></tr><tr><td> idVendor           0x0ab4 Cypress Semiconductor Corp. </td><td> ID_VENDOR_ID=0ab4 </td></tr><tr><td> idProduct          0x685a USB-2.0 IDE Adapter </td><td> ID_MODEL_ID=685a </td></tr><tr><td> iSerial          100 ABCDEF012345 </td><td> ID_SERIAL_SHORT=ABCDEF012345 </td></tr></table><p>
Die oben beschriebene Regel zum Ausführen eines Skripts beim Hinzufügen wäre dann für das Entfernen folgendermaßen anzupassen:</p><pre class="notranslate">ACTION=="remove",  ENV{ID_SERIAL_SHORT}=="ABCDEF012345",   RUN+="/usr/local/bin/remove"</pre><p>
Die gesamte Ausgabe beim Entfernen des Gerätes kann mehrere hundert Zeilen umfassen, und bietet unter Umständen deutlich mehr Möglichkeiten zur eindeutigen Identifzierung. Falls das Gerät keine Seriennummer hat, gibt es z.B. Variablen für UUID, Dateisystem und Label. Auch können hier der Variablenname und der zugehörige Wert 1:1 übernommen werden, was bei der Abfrage mit <code class="notranslate">lsusb</code> nicht immer der Fall ist. Die Environment-Variablen lassen sich natürlich auch beim Anstecken des Geräts nutzen.</p></div><div class="section_3"><h4 id="Neustart-des-udev-Systems">Neustart des udev-Systems<a class="headerlink" href="#Neustart-des-udev-Systems">¶</a></h4><p>
Ein Neustart von udev ist eigentlich nicht erforderlich, da udev beim Anschließen eines neuen Gerätes automatisch die Regeln im Verzeichnis <strong>/etc/udev/rules.d/</strong> durchgeht. Wurde die Regel für entfernbare Geräte erstellt, können diese einfach entfernt und wieder eingesteckt werden. Wurden dagegen Regeln für fest eingebaute Geräte (z.B. PCI-Karten) festgelegt, muss udev aber dazu veranlasst werden, alle Geräte neu einzulesen. Dies geschieht mittels:</p><div class="bash"><div class="contents"><pre class="notranslate">sudo udevadm trigger </pre></div></div><p>
Falls es dennoch notwendig sein sollte, udev neu zu starten, verwendet man den Befehl:</p><div class="bash"><div class="contents"><pre class="notranslate">sudo reload udev </pre></div></div></div><div class="section_3"><h4 id="Funktionstest">Funktionstest<a class="headerlink" href="#Funktionstest">¶</a></h4><p>
Ein Funktionstest ist recht einfach durchzuführen: Dazu muss man einfach die USB-Festplatte abziehen und neu anstecken. Ist dann eine Gerätedatei <strong>/dev/backup</strong> erstellt worden, hat alles geklappt. Wenn nicht, dann ist an der udev-Regel etwas falsch, und man sollte sie korrigieren. Dabei helfen verschiedene Werkzeuge.</p><p>Das System prüft eine udev-Regel in <strong>/etc/udev/rules.d/</strong> sofort beim Speichern der Datei und protokolliert mögliche Fehler in <strong>/var/log/syslog</strong>. Es empfiehlt sich deshalb, die Log-Datei in einem Fenster mit <strong>tail -n 10 -f /var/log/syslog</strong> offen zu halten. Selbst auskommentierte Zeilen werden hier auf ihre Syntax geprüft, auch wenn sie nicht angewendet werden.</p><div class="box notice"><h3 class="box notice">Hinweis:</h3><div class="contents"><p>Ein "beliebter" Fehler ist die Angabe des Operatorts <code class="notranslate">*=</code> statt <code class="notranslate">+=</code>, weil das <code class="notranslate">+</code> als einziges Zeichen in der Kette ohne Umschalttaste eingegeben werden muss.
</p></div></div><p>Als Universalwerkzeug kann man auch hier udevadm verwenden. Mit dem Befehl:</p><div class="bash"><div class="contents"><pre class="notranslate">sudo udevadm test /sys/class/block/sdb1 </pre></div></div><p>
lässt sich prüfen, welche Regeln und Attribute auf das Gerät <strong>sdb1</strong> angewendet werden. Möchte man nur wissen, welche Symlinks für ein Gerät existieren, kann man das z.B. mit dem Befehl:</p><div class="bash"><div class="contents"><pre class="notranslate">sudo udevadm info --root --query=symlink --name=/dev/GERÄTEDATEI_ODER_SYMLINK </pre></div></div><p>
machen. Weitere Anwendungsmöglichkeiten findet man in der <a class="internal" href="./manpage.html">Manpage</a> von udevadm.</p></div></div><div class="section_2"><h3 id="Einhaengen-eines-Dateisystems">Einhängen eines Dateisystems<a class="headerlink" href="#Einhaengen-eines-Dateisystems">¶</a></h3><p>
Über den erstellten Symlink des Geräts kann ein Dateisystem wie gewohnt eingehängt<sup><a href="#source-4">[4]</a></sup> werden:</p><div class="bash"><div class="contents"><pre class="notranslate">sudo mkdir EINHÄNGEPUNKT
sudo mount SYMLINK EINHÄNGEPUNKT </pre></div></div><p>Beispiel:
</p><div class="bash"><div class="contents"><pre class="notranslate">sudo mkdir /media/usb-backup
sudo mount /dev/usb-backup /media/usb-backup </pre></div></div><p>
Für eine dauerhafte Lösung bietet sich das Einhängen per <strong>/etc/fstab</strong><sup><a href="#source-5">[5]</a></sup> an.</p></div><div class="section_2"><h3 id="Regelsyntax">Regelsyntax<a class="headerlink" href="#Regelsyntax">¶</a></h3><p>
Hier noch eine Übersicht möglicher Schlüssel. Eine vollständige Liste findet man in der <a class="internal" href="./manpage.html">Manpage</a> von udev.</p><p>
</p><table><tr class="titel"><td colspan="3"> Vergleichsschlüssel, um Bedingungen zu definieren </td></tr><tr class="kopf"><td> Schlüssel </td><td> Bedeutung </td><td> Beispiel </td></tr><tr><td> <code class="notranslate">ACTION</code> </td><td> Gerät neu eingesteckt bzw. entfernt </td><td> <code class="notranslate">ACTION=="add"</code>, <code class="notranslate">ACTION=="remove"</code> </td></tr><tr class="highlight"><td><code class="notranslate">KERNEL</code> </td><td> Kernelname des Geräts </td><td> <code class="notranslate">KERNEL=="block"</code> </td></tr><tr><td> <code class="notranslate">KERNELS</code> </td><td> Wert für den Kernelnamen des Elternsystems </td><td> <code class="notranslate">KERNELS=="3:0:0:0"</code> </td></tr><tr class="highlight"><td><code class="notranslate">SUBSYSTEM</code> </td><td> Subsystem des Geräts </td><td> <code class="notranslate">SUBSYSTEM=="block"</code> </td></tr><tr><td> <code class="notranslate">SUBSYSTEMS</code> </td><td> Subsystem des Elternsystems </td><td> <code class="notranslate">SUBSYSTEMS=="usb"</code> </td></tr><tr class="highlight"><td><code class="notranslate">ATTRS</code> </td><td> SYSFS-Attribut des Elternsystems </td><td> <code class="notranslate">ATTRS{model}=="WDC WD20EARS-07M"</code>, <code class="notranslate">ATTRS{vendor}=="WD"</code>, <code class="notranslate">ATTRS{serial}=="AEFHSSK768KJH"</code> </td></tr></table><p>
</p><table><tr class="titel"><td colspan="4"> Zuweisungsschlüssel </td></tr><tr class="kopf"><td> Schlüssel </td><td> Bedeutung </td><td> Verwendung </td><td> Hinweis </td></tr><tr><td> <code class="notranslate">NAME</code> </td><td> definiert den <code class="notranslate">NAMEN</code> des Geräts in <strong>/dev</strong> </td><td> <code class="notranslate">NAME="eth0"</code> </td><td> Darf nur 1x pro Gerät vergeben werden. Die Vergabe von eigenen Namen mit <code class="notranslate">NAME=</code> ist nur für Netzwerkschnittstellen eth* sinnvoll. Bis Ubuntu 13.04 könnnen zwar auch andere Geräte noch umbenannt werden, dies führt aber zu Inkonsistenzen mit dem Kernel. Daher unterstützt Ubuntu ab 13.10 nur noch das das Umbenennen von eth*-Geräten. </td></tr><tr class="highlight"><td><code class="notranslate">SYMLINK</code> </td><td> definiert einen Symlink für das Gerät in <strong>/dev</strong> </td><td> <code class="notranslate">SYMLINK+="usb-backup"</code> </td><td> Kann mit dem Operator <code class="notranslate">+=</code> mehrfach verwendet werden. </td></tr><tr><td> <code class="notranslate">OWNER</code>, <code class="notranslate">GROUP</code>, <code class="notranslate">MODE</code> </td><td> definiert Rechte für das Gerät </td><td> <code class="notranslate">OWNER="users"</code> </td><td> Ein angegebener Wert überschreibt den bisher definierten. </td></tr><tr class="highlight"><td><code class="notranslate">RUN</code> </td><td> startet ein Skript oder ein Programm </td><td> <code class="notranslate">RUN+="/usr/local/bin/backup"</code> </td><td> Verlangt den absoluten Pfad des Skripts, sollte zusammen mit <code class="notranslate">ACTION=="add"</code> verwendet werden. Wenn das Skript auf das neu hinzugefügte Gerät zugreifen soll, muss dieses vorher eingehängt werden. </td></tr></table><p>
</p><table><tr class="titel"><td colspan="4"> Operatoren </td></tr><tr class="kopf"><td> Operator </td><td> Typ </td><td> Bedeutung </td><td> Hinweis </td></tr><tr><td> <code class="notranslate">==</code> </td><td> Vergleichsoperator </td><td> prüft, ob der angegebene Schlüssel dem Wert entspricht </td><td> alle Kriterien müssen erfüllt sein, damit eine Regel ausgeführt wird </td></tr><tr class="highlight"><td><code class="notranslate">!=</code> </td><td> Vergleichsoperator </td><td> prüft, ob der angegebene Schlüssel dem Wert nicht entspricht </td><td> alle Kriterien müssen erfüllt sein, damit eine Regel ausgeführt wird </td></tr><tr><td> <code class="notranslate">=</code> </td><td> Zuweisungsoperator </td><td> weist einem Schlüssel einen Wert zu </td><td> alle Werte, die bisher für diesen Schlüssel definiert wurden, werden ignoriert </td></tr><tr class="highlight"><td><code class="notranslate">+=</code> </td><td> Zuweisungsoperator </td><td> weist einem Schlüssel einen Wert hinzu </td><td> mehrere Werte pro Schlüssel möglich </td></tr><tr><td> <code class="notranslate">:=</code> </td><td> Zuweisungsoperator </td><td> weist einem Schlüssel einen Wert zu </td><td> lässt ab sofort keine Änderungen an diesem Schlüssel mehr zu </td></tr></table></div></div><div class="section_1"><h2 id="Weitere-Befehle-rund-um-udev">Weitere Befehle rund um udev<a class="headerlink" href="#Weitere-Befehle-rund-um-udev">¶</a></h2><p>
Den udev-Dienst starten/stoppen oder den Status anzeigen:</p><div class="bash"><div class="contents"><pre class="notranslate">sudo systemctl status udev
sudo systemctl stop udev
sudo systemctl start udev </pre></div></div><p>bzw. für System mit Upstart (also bis einschließlich Ubuntu 14.04):</p><div class="bash"><div class="contents"><pre class="notranslate">sudo start udev 
sudo stop udev
sudo status udev </pre></div></div><p>
Zeigt Kernel-Events:</p><div class="bash"><div class="contents"><pre class="notranslate">udevadm monitor --kernel 
udevadm monitor --udev  </pre></div></div></div><div class="section_1"><h2 id="Problembehebung">Problembehebung<a class="headerlink" href="#Problembehebung">¶</a></h2><p>
</p><div class="section_2"><h3 id="Probleme-mit-einigen-Digitalkameras">Probleme mit einigen Digitalkameras<a class="headerlink" href="#Probleme-mit-einigen-Digitalkameras">¶</a></h3><p>
Es kann sein, dass eine Kamera nicht als Massenspeichermedium erkannt wird, aber über <a class="external" href="http://www.gphoto.org/" rel="nofollow">Gphoto2</a> <img alt="{en}" src="./_/d5ecf89114b079f85d02099649c4ee617ffa34c7.png"/> zugänglich ist. In diesem Fall erfolgt der Zugriff durch normale ("Userspace") Programme anstatt über einen Kernel-Treiber. Das Problem daran ist vor allem, dass die erwähnten Kernel-Namen in diesem Fall nicht funktionieren, da die Kamera ja kein Block-Device ist. Siehe auch <a class="internal" href="./kamera_via_ptp_einbinden.html">Kamera via PTP einbinden</a>.</p></div></div><div class="section_1"><h2 id="Tipps-und-Tricks">Tipps und Tricks<a class="headerlink" href="#Tipps-und-Tricks">¶</a></h2><p>
</p><div class="section_2"><h3 id="Austausch-von-Netzwerkkarten">Austausch von Netzwerkkarten<a class="headerlink" href="#Austausch-von-Netzwerkkarten">¶</a></h3><p>
Falls man die Netzwerkkarte (LAN oder WLAN) austauscht, wird die neue zwar im Regelfall automatisch erkannt, aber die Bezeichnung hochgezählt (aus ehemals <code class="notranslate">eth0</code> wird z.B. <code class="notranslate">eth2</code>). Die Zuordnung findet in der Datei <strong>/etc/udev/rules.d/70-persistent-net.rules</strong> statt und kann darüber (mit Root-Rechten) angepasst werden. Anschließend ist ein Neustart des Systems erforderlich.</p></div><div class="section_2"><h3 id="Die-Ausgabe-von-lsusb-vs-BUS-NAME-DEVICE-NAME-ist-leer">Die Ausgabe von lsusb -vs BUS_NAME:DEVICE_NAME ist leer<a class="headerlink" href="#Die-Ausgabe-von-lsusb-vs-BUS-NAME-DEVICE-NAME-ist-leer">¶</a></h3><p>
Wenn mit <code class="notranslate">lsusb</code> das gewünschte Gerät angezeigt wird, die Ausgabe von <code class="notranslate">lsusb -vs BUS_NAME:DEVICE_NAME</code> aber leer bleibt, liegt das wahrscheinlich daran, dass das Gerät nicht eingehängt ist. Möglicherweise wurde das Gerät zwar bereits eingehängt, hat sich aber in den Ruhezustand verabschiedet. In diesem Fall empfiehlt es sich, das Gerät ab- und wieder anzustecken. Dadurch ändert sich aber die Device-Nummer, sodass <code class="notranslate">lsusb</code> erneut ausgeführt und die neue Nummer zur Abfrage durch <code class="notranslate">lsusb -vs BUS_NAME:DEVICE_NAME</code> verwendet werden muss.</p></div><div class="section_2"><h3 id="Partition-mit-Windows-ausblenden">Partition mit Windows ausblenden<a class="headerlink" href="#Partition-mit-Windows-ausblenden">¶</a></h3><p>
Manche Nutzer haben neben Ubuntu noch eine Partition (hier <strong>/dev/sda1</strong>) mit Windows. Diese Partition wird in <a class="internal" href="./nautilus.html">Nautilus</a> und unter "Orte" ständig angezeigt, obwohl man sie evtl. gar nicht braucht.</p><p>Mit Hilfe der folgenden Regel kann die Partition leicht ausgeblendet werden.</p><pre class="notranslate">KERNEL=="sda1", ENV{UDISKS_PRESENTATION_HIDE}="1"</pre></div></div><div class="section_1"><h2 id="Links">Links<a class="headerlink" href="#Links">¶</a></h2><p>
</p><ul><li><p><a class="external" href="http://www.freedesktop.org/software/systemd/libudev/" rel="nofollow">udev API Reference</a> <img alt="{en}" src="./_/d5ecf89114b079f85d02099649c4ee617ffa34c7.png"/></p></li><li><p><a class="external" href="http://www.reactivated.net/writing_udev_rules.html" rel="nofollow">Writing udev rules</a> <img alt="{en}" src="./_/d5ecf89114b079f85d02099649c4ee617ffa34c7.png"/> - gut erklärt und mit Beispielen</p></li><li><p><a class="interwiki interwiki-uf_thread" href="https://ubuntuforums.org/showthread.php?t=168221">Create your own udev rules to control removable devices</a> <img alt="{en}" src="./_/d5ecf89114b079f85d02099649c4ee617ffa34c7.png"/> - Ubuntuforums.org, 04/2006</p></li><li><p><a class="external" href="http://www.linux-user.de/ausgabe/2007/12/096-udev/" rel="nofollow">Geräteschuppen - udev &amp; Co</a> <img alt="{de}" src="./_/ffd333e1d59794eac31aea8b3e984e1b88473c33.png"/> - LinuxUser, 12/2007 (teilweise veraltet)</p></li><li><p><a class="external" href="http://udev-notify.learnfree.eu/" rel="nofollow">udev-notify</a> <img alt="{en}" src="./_/d5ecf89114b079f85d02099649c4ee617ffa34c7.png"/> - grafische Benachrichtigungen beim Anschluss externer Geräte anzeigen</p></li><li><p><a class="interwiki interwiki-heise" href="https://www.heise.de/-1500474">udev wird Bestandteil von Init-System Systemd</a> <img alt="{de}" src="./_/ffd333e1d59794eac31aea8b3e984e1b88473c33.png"/> - heise Open Source, 04/2012</p></li><li><p><a class="internal" href="./logitech_harmony_fernbedienung.html">Logitech Harmony Fernbedienung</a> - Praxisbeispiel für die Hardware-Erkennung mittels udev</p></li></ul><p>
</p><ul class="footnotes"><li><a class="crosslink" href="#bfn-1" id="fn-1">1</a>: <a class="external" href="http://ericheikes.com/turning-numlock-on-off-in-linux-when-plugging-in-keyboard/" rel="nofollow" title="http://ericheikes.com/turning-numlock-on-off-in-linux-when-plugging-in-keyboard/"><span class="longlink_show">http://ericheikes.com/turning-numloc</span><span class="longlink_collapse">k-on-off-in-linux-when-pluggin</span><span>g-in-keyboard/</span></a></li></ul></div></div>
<p class="meta">
<a href="./udev/a/revision/945995.html">Diese Revision</a> wurde am 3. Januar 2018 11:27 von <a href="https://ubuntuusers.de/user/BillMaier/">BillMaier</a> erstellt.
    
  </p>
</div>
</div>
<div style="clear: both;"></div>
<div class="pathbar breadcrumb">
<div class="breadcrumb">
<ol>
<li><a href="./startseite.html">Wiki</a></li>
<li><a href="./udev.html">udev</a></li>
</ol>
</div>
</div>
</div>
<div class="footer" style="clear: both;">
<ul>
<li class="poweredby"><li class="poweredby">Erstellt mit <a href="http://inyokaproject.org/">Inyoka</a></li></li>
<li class="license">

<img alt="Copyleft" src="./_/65dad5b770326dbbe1bd26ee6363e366a76bd8b7.png"/>
          2004 – 2017 ubuntuusers.de • Einige Rechte vorbehalten<br/>
<a href="./_lizenz.html" rel="cc:morePermissions">Lizenz</a> •
          <a href="http://ubuntuusers.de/kontakt/">Kontakt</a> •
          <a href="http://ubuntuusers.de/datenschutz/">Datenschutz</a> •
          <a href="http://ubuntuusers.de/impressum/">Impressum</a> •
          <a href="https://ubuntuusers.statuspage.io">Serverstatus</a>
</li>
<li class="housing">
<span title="Unterbringung und Netzanbindung eines Servers">Serverhousing</span> gespendet von<br/>
<img alt="noris network" src="./_/e7d27e9081eec23a8a5a5fe9434d7b2f1532e1d9.png"/>
<img alt="anexia" src="./_/ad1b63a3fc35749344af0a03e8c3ce05a2a3ee7e.png"/>
</li>
</ul>
</div>
<div style="clear: both;"></div>
</div>






</body>
</html>