<!DOCTYPE html>
<html lang="">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>GRUB_2/Skripte › ubuntuusers statisches Wiki</title>
<link href="../_/34e5d78db234405457773cc26741aada99f7fff2.css" rel="stylesheet" type="text/css"/>
<link href="../_/61af784fc5c93e296fec3be63b8e0bb48443727c.css" rel="stylesheet" type="text/css"/>
<link href="../_/634e8d1015b02df998cdec7cb07c5aff61d068b5.css" rel="stylesheet" type="text/css"/>
<link href="../_/b583ff7e37147497a59224ccf54cfee812a1d21b.css" rel="stylesheet" type="text/css"/>
<link href="../_/a0d5775ed6f36f8cc5b12bcf2f1c1bd98a3eb225.css" rel="stylesheet" type="text/css"/>
<link href="../_/98de73bded109a634cbd1e924abdd8c8964b8df2.css" media="print" rel="stylesheet" type="text/css"/>

<meta content="#a87300" name="theme-color"/>

</head>
<body>
<div class="wrap">
<div class="header">
<h1><a href="http://ubuntuusers.de/"><span>ubuntuusers.de</span></a></h1>
<ul class="tabbar">
<li class="portal">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://ubuntuusers.de/">Portal<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="forum">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://forum.ubuntuusers.de/">Forum<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="wiki active">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://wiki.ubuntuusers.de/">Wiki<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="ikhaya">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://ikhaya.ubuntuusers.de/">Ikhaya<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="planet">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://planet.ubuntuusers.de/">Planet<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="community">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://wiki.ubuntuusers.de/Mitmachen">Mitmachen<span></span></a></div>
<div class="tab_right"></div>
</li>
</ul>
</div>
<div class="body">
<div class="appheader">

<div class="pagetitle">
<h1 class="breadcrumb_title">
<a class="separator" href="../startseite.html">
              Wiki
            </a>
</h1>
<h2 class="breadcrumb_subtitle"><a href="../grub_2/skripte.html">Skripte</a></h2>
</div>
</div><div class="message staticwikinote"><strong>Hinweis:</strong> Dies ist ein statischer Snapshot unseres Wikis vom Jan. 17, 2018 und kann daher nicht bearbeitet werden. Der aktuelle Artikel ist unter <a href="http://wiki.ubuntuusers.de/GRUB_2/Skripte">wiki.ubuntuusers.de</a> zu finden.</div>

<!--[if lt IE 8]>
      <div class="message fail">Bitte installiere den Internet Explorer 8 oder neuer.</div>
      <![endif]-->
<div class="page_content">
<div class="navi_sidebar navigation">
<div class="container">
<h3 class="navi_wiki">Wiki</h3>
<ul>
<li><a href="../wiki/index.html">Index</a></li>
<li><a href="../wiki/recentchanges.html">Letzte Änderungen</a></li>
<li><a href="../wiki/neue_artikel.html">Liste neuer Artikel</a></li>
<li><a href="../wiki.html">Übersicht</a></li>
<li><a href="../wiki/faq_-_häufig_gestellte_fragen.html">FAQ</a></li>
<li><a href="../wiki/benutzung.html">Benutzung</a></li>
<li><a href="../kategorien.html">Kategorie</a></li>
<li><a href="../wiki/tagcloud.html">Wortwolke</a></li>
</ul>
<h3 class="navi_join">Mitmachen</h3>
<ul>
<li><a href="../wikiartikel_anlegen.html">Wikiartikel anlegen</a></li>
<li><a href="../howto.html">Howto anlegen</a></li>
<li><a href="../wiki/referenz.html">Wiki-Referenz</a></li>
<li><a href="../wiki/syntax.html">Wiki-Syntax</a></li>
<li><a href="../baustelle.html">Baustellen</a></li>
<li><a href="../wiki/artikelideen.html">Artikelideen</a></li>
<li><a href="../wiki/ungetestet.html">Ungetestete Artikel</a></li>
<li><a href="../wiki/vorlagen/ausbaufähig/a/backlinks.html">Ausbaufähige Artikel</a></li>
<li><a href="../wiki/vorlagen/fehlerhaft/a/backlinks.html">Fehlerhafte Artikel</a></li>
<li><a href="https://forum.ubuntuusers.de/forum/wiki/">Rund ums Wiki</a></li>
</ul>
<h3 class="navi_config">Konfiguration</h3>
<ul>
<li><a href="../grub_2/skripte/a/backlinks.html">Backlinks anzeigen</a></li>
<li>
        Exportieren
        <ul>
<li><a href="../grub_2/skripte/a/export/meta.html" rel="nofollow">Metadaten</a></li>
<li><a href="../grub_2/skripte/a/export/raw.html" rel="nofollow">Rohformat</a></li>
<li><a href="../grub_2/skripte/a/export/html.html" rel="nofollow">HTML</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div class="content content_tabbar content_sidebar">
<h1 class="pagetitle"><a href="../grub_2/skripte/a/backlinks.html">Skripte</a></h1>
<div id="page"><p>
</p><div class="box tested_for"><h3 class="box tested_for">Dieser Artikel wurde für die folgenden
Ubuntu-Versionen getestet:</h3><div class="contents"><p>
</p><ul><li><p><a class="internal" href="../xenial_xerus.html">Ubuntu 16.04</a> Xenial Xerus</p></li><li><p><a class="internal" href="../trusty_tahr.html">Ubuntu 14.04</a> Trusty Tahr</p></li></ul></div></div><p>
</p><div class="box knowledge"><h3 class="box knowledge">Zum Verständnis dieses Artikels sind folgende Seiten hilfreich:</h3><div class="contents"><p>
</p><ol class="arabic"><li><p><a class="crosslink anchor" href="#source-1" id="source-1"></a> <a class="internal" href="../terminal.html">Terminal</a> - Ein Terminal öffnen</p></li><li><p><a class="crosslink anchor" href="#source-2" id="source-2"></a> <a class="internal" href="../cd-images.html#Inhalt-von-Images-lesen">CD-Images</a> - Den Inhalt eines CD-Images (ISO) lesen</p></li><li><p><a class="crosslink anchor" href="#source-3" id="source-3"></a> <a class="internal" href="../editor.html">Editor</a> - einen Editor öffnen</p></li><li><p><a class="crosslink anchor" href="#source-4" id="source-4"></a> <a class="internal" href="../rechte/dateimanager.html">Rechte/Dateimanager</a> Rechte von Dateien anpassen</p></li></ol></div></div><div class="toc toc-depth-2"><div class="head">Inhaltsverzeichnis</div><ol class="arabic"><li><a class="crosslink" href="#Erstellen-eigener-Menue-Eintraege">Erstellen eigener Menü-Einträge
</a><ol class="arabic"><li><a class="crosslink" href="#Anlegen-eines-eigenen-Skriptes">Anlegen eines eigenen Skriptes
</a></li></ol></li><li><a class="crosslink" href="#Allgemeiner-Aufbau-Menueeintrag">Allgemeiner Aufbau Menüeintrag
</a><ol class="arabic"><li><a class="crosslink" href="#Allgemeines-Beispiel">Allgemeines Beispiel
</a></li></ol></li><li><a class="crosslink" href="#Ubuntu-oder-andere-Linux-Distributionen-starten">Ubuntu oder andere Linux-Distributionen st...</a><ol class="arabic"><li><a class="crosslink" href="#Kernel-Images">Kernel-Images
</a></li><li><a class="crosslink" href="#Anzeige-in-der-Menuezeile">Anzeige in der Menüzeile
</a></li><li><a class="crosslink" href="#LVM-und-RAID">LVM und RAID
</a></li><li><a class="crosslink" href="#Symlink-zum-Wurzelverzeichnis">Symlink zum Wurzelverzeichnis
</a></li><li><a class="crosslink" href="#Symlink-zur-Boot-Partition">Symlink zur Boot-Partition
</a></li><li><a class="crosslink" href="#Configfile">Configfile
</a></li><li><a class="crosslink" href="#Submenue-einrichten">Submenü einrichten
</a></li></ol></li><li><a class="crosslink" href="#Fremde-Betriebssysteme-Windows-mittels-chainloader-laden">Fremde Betriebssysteme (Windows) mittels c...</a><ol class="arabic"><li><a class="crosslink" href="#Beispiel-BIOS-Modus">Beispiel BIOS-Modus
</a></li><li><a class="crosslink" href="#Beispiel-EFI-Modus">Beispiel EFI-Modus
</a></li></ol></li><li><a class="crosslink" href="#Von-ISO-Dateien-mittels-loopback-booten">Von ISO-Dateien mittels loopback booten
</a><ol class="arabic"><li><a class="crosslink" href="#Beispiel-Ubuntu-Iso">Beispiel Ubuntu-Iso
</a></li><li><a class="crosslink" href="#Beispiel-Lubuntu-14-10-64bit">Beispiel Lubuntu 14.10 64bit
</a></li><li><a class="crosslink" href="#Beispiel-Parted-Magic-Iso">Beispiel Parted Magic Iso
</a></li><li><a class="crosslink" href="#Kernel-Boot-Optionen-fuer-ISO-ermitteln">Kernel-Boot-Optionen für ISO ermitteln
</a></li></ol></li><li><a class="crosslink" href="#Kaskadiertes-Starten">Kaskadiertes Starten
</a><ol class="arabic"><li><a class="crosslink" href="#Fehler-in-Grub-abfangen">Fehler in Grub abfangen
</a></li><li><a class="crosslink" href="#Fehler-im-Betriebssystem-abfangen">Fehler im Betriebssystem abfangen
</a></li></ol></li><li><a class="crosslink" href="#Ausfuehrbarkeit-der-Skripte">Ausführbarkeit der Skripte
</a></li><li><a class="crosslink" href="#Links">Links
</a></li></ol></div><div class="box warning"><h3 class="box warning">Achtung!</h3><div class="contents"><p>Der Grub 2 Bootloader in der Version 2.0 (stable) ist weiter in der Entwicklung. Hinweise auf tatsächliche Gegebenheiten können daher noch fehlen bzw. nach einem Update nicht mehr zutreffen. Wesentliche Abweichungen sind  gekennzeichnet und wenn erforderlich, auch beschrieben.
</p></div></div><p><img alt="GRUB_2/grub-script.png" class="image-left" src="../_/dcc85faf4f5a0db249fe20d6db329f25cd74d219.png"/>GRUB 2 ermöglicht es, mit einfachen Mitteln das GRUB 2 Bootmenü an seine Bedürfnisse und Wünsche anzupassen. Dazu kann man eigene Skripte erstellen, deren Syntax sich an der Standard-Shell <a class="internal" href="../shell.html">Shell</a> ausrichtet und im Verzeichnis <strong>/etc/grub.d</strong> abgelegt und dort lauffähig gemacht werden.</p><div class="section_1"><h2 id="Erstellen-eigener-Menue-Eintraege">Erstellen eigener Menü-Einträge<a class="headerlink" href="#Erstellen-eigener-Menue-Eintraege">¶</a></h2><p>
Es sollte das Bearbeiten / Verändern der Standardskripte im Verzeichnis <strong>/etc/grub.d</strong> vermieden werden. Diese Veränderungen werden mit dem nächsten Update der Grub 2 Pakete zerstört!</p><p>Im folgenden werden die für die meisten Situationen gängigen Menü-Einträge erklärt. Dabei handelt es sich lediglich um Beispiele, die anleiten sollen, eigene Skripte richtig zu erstellen.</p><div class="box notice"><h3 class="box notice">Hinweis:</h3><div class="contents"><p>Die Beispiele und Entwürfe müssen an das jeweilige System angepasst werden - insbesondere die Datenträger- und Partitions-Bezeichnungen sowie andere Parameter wie z.B. die <a class="internal" href="../uuid.html">UUID</a>.
</p></div></div><div class="section_2"><h3 id="Anlegen-eines-eigenen-Skriptes">Anlegen eines eigenen Skriptes<a class="headerlink" href="#Anlegen-eines-eigenen-Skriptes">¶</a></h3><p>
Zunächst muss ein eigenes Skript angelegt werden. Dazu legt man mit einen Editor <sup><a href="#source-3">[3]</a></sup> eine Datei mit dem Namensschema "XX_Eigenes_Skript" vorzugsweise im eigenen <a class="internal" href="../homeverzeichnis.html">Homeverzeichnis</a> an. Dabei muss die Bezeichnung - wie unter <a class="internal" href="../grub_2/konfiguration.html#Die-Abarbeitungs-Reihenfolge-der-Skripte">Konfiguation</a> von GRUB 2 dargestellt - den eigenen Bedürfnissen entsprechend angepasst werden.</p><div class="box notice"><h3 class="box notice">Hinweis:</h3><div class="contents"><p>Eine Variable im eigenen Skript kann auf zwei Arten interpretiert werden:
</p><ul><li><p>Übernahme eines Werte aus der Datei <strong>/etc/default/grub</strong> in die <strong>/boot/grub/grub.cfg</strong>, dann wird der z.B.: mit  ${GRUB_CMDLINE_LINUX_DEFAULT} vorgegebene Inhalt (z.B.: quiet splash) direkt übernommen </p></li><li><p>Soll dagegen die Übernahme eines Werte erst beim Booten erfolgen, dann wird das mit einem vorangestelltem Rückstrich ( \ ), wie z.B.: bei \${root}  in ein eigenes Skript eingetragen.</p></li></ul></div></div><p>Nachdem das Skript inhaltlich den eigenen Vorstellungen entspricht, muss man diese Datei vor dem Kopieren mit den erforderlichen Rechten <sup><a href="#source-4">[4]</a></sup> versehen und die Ausführbarkeit einstellen.</p><p>Jetzt kann man diese Datei im Terminal <sup><a href="#source-1">[1]</a></sup> mit:
</p><div class="bash"><div class="contents"><pre class="notranslate">sudo cp -f &lt;meine Datei&gt; /etc/grub.d/ </pre></div></div><p>
kopieren und sich im Terminal <sup><a href="#source-1">[1]</a></sup> mit:
</p><div class="bash"><div class="contents"><pre class="notranslate">sudo grub-mkconfig </pre></div></div><p>
das Ergebnis anzeigen lassen.</p></div></div><div class="section_1"><h2 id="Allgemeiner-Aufbau-Menueeintrag">Allgemeiner Aufbau Menüeintrag<a class="headerlink" href="#Allgemeiner-Aufbau-Menueeintrag">¶</a></h2><p>
Das folgende Beispiel für ein Skript wurde abgeleitet aus einem Standard-Eintrag für den <a class="internal" href="../recovery_modus.html">Recovery Modus</a>):</p><div class="section_2"><h3 id="Allgemeines-Beispiel">Allgemeines Beispiel<a class="headerlink" href="#Allgemeines-Beispiel">¶</a></h3><p>
</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="ch">#! /bin/sh -e</span>

<span class="nb">echo</span> <span class="s2">"Füge Eintrag für Lucid Lynx ein"</span>  &gt;<span class="p">&amp;</span><span class="m">2</span>

cat <span class="s">&lt;&lt; EOF</span>
<span class="s">menuentry "Ubuntu" --class ubuntu --class gnu-linux {</span>
<span class="s">        recordfail</span>
<span class="s">	savedefault</span>
<span class="s">	insmod ext2</span>
<span class="s">	set root='(hd0,msdos3)'</span>
<span class="s">	search --no-floppy --fs-uuid --set=root ae875d31-cc84-4349-95d7-01a82ad76d61</span>
<span class="s">	linux	/vmlinuz root=UUID=ae875d31-cc84-4349-95d7-01a82ad76d61 ro ${GRUB_CMDLINE_LINUX_DEFAULT}</span>
<span class="s">	echo  Lade aktuellen Kernel von ${GRUB_DEVICE}... </span>
<span class="s">	initrd	/initrd.img</span>
<span class="s">	echo  Lade und Initiere RAM-Image von ${GRUB_DEVICE}...</span>
<span class="s">}</span>
<span class="s">EOF</span>
</pre></div>
</td></tr></table></div><div class="section_3"><h4 id="Erlaeuterungen">Erläuterungen<a class="headerlink" href="#Erlaeuterungen">¶</a></h4><p>
Es sind dabei die <a class="internal" href="../grub_2/konfiguration.html#Festplatten-und-Partitions-Bezeichnungen">Festplatten- bzw. Partitions-Bezeichnung</a>, die <a class="internal" href="../uuid.html">UUID</a> und soweit eingesetzt, die <a class="internal" href="../kernel.html">Kernel</a>-Bezeichnung an die jeweiligen Gegebenheiten anzupassen!</p><p>
</p><table style="width: 95%"><tr class="titel"><td colspan="2"> Befehlszeilen in den Skripten </td></tr><tr class="kopf"><td style="text-align: center; width: 70px"> Zeile </td><td style="text-align: center"> Funktion </td></tr><tr><td style="text-align: left; vertical-align: top">Zeile 1: </td><td> Die erforderliche <a class="internal" href="../shell/bash-skripting-guide_für_anfänger.html#Die-Shebang">Shebang</a> für jedes separate Skript im Verzeichnis <strong>/etc/grub.d/</strong>. </td></tr><tr><td style="text-align: left; vertical-align: top">Zeile 3: </td><td> Diese Zeile ist optional. Beim <a class="internal" href="../grub_2/terminalbefehle.html#Befehle-zum-Konfigurieren-des-Auswahl-Menues">Updaten</a> der Grub-Konfiguration mit <code class="notranslate">grub-mkconfig</code> bzw. <code class="notranslate">update-grub</code> im Terminal gibt diese Zeile eine Rückmeldung - im Beispiel "Füge Eintrag für Lucid Lynx ein" - so dass man überprüfen kann, ob das Skript  berücksichtigt wurde. Der Text für die Rückmeldung kann dabei innerhalb der <code class="notranslate">""</code> beliebig festgelegt werden. </td></tr><tr><td style="text-align: left; vertical-align: top">Zeile 5+17: </td><td> <code class="notranslate">cat &lt;&lt; EOF</code> und das abschließende <code class="notranslate">EOF</code> stellen den Bereich dar, der später der <strong>/boot/grub/grub.cfg</strong> hinzugefügt wird. Menü-Einträge müssen also innerhalb dieses Bereichs definiert werden. </td></tr><tr><td style="text-align: left; vertical-align: top">Zeilen 6-16: </td><td> Definieren den eigentliche Bereich für einen Menü-Eintrag. </td></tr><tr><td style="text-align: left; vertical-align: top">Zeile 6: </td><td> Der Menü-Eintrag wird eingeleitet durch <code class="notranslate">menuentry "Bezeichnung"</code>, danach später nicht mehr sichtbare interne Systemparameter wie <code class="notranslate">--class ubuntu</code> sowie mit dem Startzeichen <code class="notranslate">{</code> für die Menü-Sequenz. Die Bezeichnungen werden dabei  für die <span class="underline">automatisch</span> generierten Einträge von den gefundenen Kernel-Bezeichnungen abgeleitet (für eigene Skripte sind diese frei wählbar) und repräsentieren dann den Eintrag im Auswahlmenü. <div class="box experts"><h3 class="box experts">Experten-Info:</h3><div class="contents"><p>Will man die automatisch generierte Bezeichnung <code class="notranslate">Ubuntu</code> auch auf das installierte Ubuntu-Derivat einstellen, dann kann man die Skripte unter <a class="crosslink" href="#Anzeige-in-der-Menuezeile">Anzeige in der Menüzeile</a> verwenden.
</p></div></div> </td></tr><tr><td style="text-align: left; vertical-align: top"> Zeile 7: </td><td> Dieser Eintrag wird automatisch <span class="underline">nur</span> für Kerneleinträge im Verzeichnis <strong>/boot</strong> erstellt. Damit wird vorsorglich ein Eintrag für die Datei <strong>/boot/grub/grubenv</strong> generiert, falls es bei dem nachfolgenden Auslesen Fehler geben sollte oder das System aus der Grub2 Commandline gestartet wurde (aufgerufen mit Taste "C" bzw. "E"). </td></tr><tr><td style="text-align: left; vertical-align: top"> Zeile 8: </td><td> Hiermit wird der mittels Pfeiltaste "<strong>↓</strong>" bzw. "<strong>↑</strong>" im Grub-Menü aktuell ausgewählte Eintrag mit seiner Bezeichnung (siehe Zeile 6) in der Datei <strong>/boot/grub/grubenv</strong> abgespeichert. <div class="box notice"><h3 class="box notice">Hinweis:</h3><div class="contents"><p>Dieser Eintrag wird bei einem <code class="notranslate">update-grub</code> <span class="underline">nur</span> für Kerneleinträge im Verzeichnis <strong>/boot</strong> erstellt <span class="underline">und</span> wenn die Option <code class="notranslate">GRUB_SAVEDEFAULLT=true</code> in der Datei <strong>/etc/default/grub</strong> aktiviert wurde. Diese Auswahl wird beim nächsten Booten <span class="underline">nur</span> angeboten, sofern <span class="underline">auch</span> die Option <code class="notranslate">GRUB_DEFAULT=saved</code> in der Datei <strong>/etc/default/grub</strong> entsprechend aktiviert wurde.
</p></div></div> </td></tr><tr><td style="text-align: left; vertical-align: top"> Zeile 9: </td><td> Gibt die Art der Formatierung des Datenträger an und veranlasst Grub2 die entsprechenden Treiber zu laden. Es muss für jeden erforderlichen Treiber eine Zeile / ein Eintrag vorgesehen werden - siehe dazu auch die Ausführungen <a class="crosslink" href="#LVM-und-RAID">zu den Treibern</a>. </td></tr><tr><td rowspan="2" style="text-align: left; vertical-align: top">Zeile 10:  </td><td> <code class="notranslate">set root=</code> gibt die Partition an, auf der die Bootdateien des im Menü-Eintrag angegebenen Systems liegen. Siehe dazu auch <a class="internal" href="../grub_2/konfiguration.html#Festplatten-und-Partitions-Bezeichnungen">Festplatten- und Partitions-Bezeichnungen</a>.  </td></tr><tr><td style="text-align: left; vertical-align: top"> Je nach Erstellung der Partitionstabelle sind z.B. <code class="notranslate">(hd0,msdos3)</code>, <code class="notranslate">(hd0,gpt3)</code> einzusetzen. </td></tr><tr><td rowspan="4" style="vertical-align: top">Zeile 11: </td><td> Die Option <code class="notranslate">--no-floppy</code> unterbindet die Suche nach einem Floppy-Disk-Laufwerk. Statt <code class="notranslate">--no-floppy</code> kann auch die Kurzform <code class="notranslate">-n</code> gesetzt werden. </td></tr><tr><td> Der Eintrag <code class="notranslate">search --fs-uuid --set=root</code> sucht nach der angegebene <a class="internal" href="../uuid.html">UUID</a> der Partition hinter <code class="notranslate">set=root</code>. Statt <code class="notranslate">--fs-uuid</code> kann auch die Kurzform <code class="notranslate">-u</code> gesetzt werden.  </td></tr><tr><td> Ein Eintrag <code class="notranslate">search --label --set=root</code> sucht nach dem angegebenen <a class="internal" href="../labels.html">Label</a> der Partition hinter <code class="notranslate">set=root</code>. Statt <code class="notranslate">--label</code> kann auch die Kurzform <code class="notranslate">-l</code> gesetzt werden. </td></tr><tr><td> Wird die Suche mit den vorgegebenen Parametern fündig, so überschreibt dieser Eintrag die Vorgabe aus der Zeile 10. Wird die angegebene Vorgabe nicht gefunden - z.B. weil die Partition zwischenzeitlich formatiert wurde - dann wird das <code class="notranslate">set root=</code> aus Zeile 10 angewendet. </td></tr><tr><td style="text-align: left; vertical-align: top">Zeile 12: </td><td> Diese Zeile gibt die Bezeichnung für den Kernel an, der geladen werden soll und wo sich dieser befindet (siehe auch nachfolgend die diversen Varianten). Der Eintrag der Kernel-Optionen erfolgt entsprechend der obigen Vorgaben, siehe  <a class="internal" href="../grub_2/konfiguration.html#Variable-fuer-Kernelzeilen">Variablen für Kernelzeilen</a>. Hier kann entweder der relative Pfad (wie im Beispiel) als auch der absolute Pfad mit relevantem Kernel angegeben werden. </td></tr><tr><td style="text-align: left; vertical-align: top">Zeile 13+15: </td><td> Diese Zeile wird <span class="underline">automatisch</span> bei Menüeinträgen für den <a class="internal" href="../recovery_modus.html">Recovery Modus</a> erstellt und nach der Auswahl angezeigt. Diese Anzeige kann auch für eigene Skripte angewendet werden. Der Zusatz <code class="notranslate">${GRUB_DEVICE}</code> fügt automatisch die relevante Partition in Form von <code class="notranslate">/dev/sda3</code> ein. </td></tr><tr><td style="text-align: left; vertical-align: top">Zeile 14: </td><td> Diese Zeile gibt die Bezeichnung für das Boot-Image an, das geladen werden soll und wo sich dieses befindet (siehe auch nachfolgend die diversen Varianten) und den Hinweis in Zeile 12. </td></tr><tr><td style="text-align: left; vertical-align: top">Zeile 16: </td><td> Hier befindet sich das abschließende <code class="notranslate">}</code> für den Menüeintrag. </td></tr></table></div></div></div><div class="section_1"><h2 id="Ubuntu-oder-andere-Linux-Distributionen-starten">Ubuntu oder andere Linux-Distributionen starten<a class="headerlink" href="#Ubuntu-oder-andere-Linux-Distributionen-starten">¶</a></h2><p>
</p><div class="section_2"><h3 id="Kernel-Images">Kernel-Images<a class="headerlink" href="#Kernel-Images">¶</a></h3><p>
Ein Kernel-Menü-Eintrag ist der Standard-Menü-Eintrag unter GRUB 2, um ein Linux-System zu booten. Dazu wird der Pfad zum entsprechenden Kernel-Image - der das Starten des Systems einleitet - angegeben. Grundsätzlich werden Kernel-Einträge automatisch über das Skript <strong>10_linux</strong> für die aktuelle Distribution und <strong>30_os_prober</strong> für andere auf dem Computer installierte Linux-Distributionen gesucht und erstellt.</p><p>Sollte es notwendig sein, so kann man einen solchen Eintrag auch manuell erstellen:</p><p>Beispiel:
</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="ch">#! /bin/sh -e</span>
<span class="nb">echo</span> <span class="s2">"Adding Saucy Salamander entry"</span> &gt;<span class="p">&amp;</span><span class="m">2</span>
 cat <span class="s">&lt;&lt; EOF</span>
<span class="s">menuentry "Ubuntu, mit Linux 3.11.0-15-generic" {</span>
<span class="s">insmod ext2</span>
<span class="s">set root='(hd0,msdos3)'</span>
<span class="s">search --no-floppy --fs-uuid --set=root d3afdd1-045a-490f-b7ba-86c0c2d8c500</span>
<span class="s">       linux /boot/vmlinuz-3.11.0-15-generic root=UUID=d3afdd1-045a-490f-b7ba-86c0c2d8c500 ro quiet splash</span>
<span class="s">       initrd /boot/initrd.img-3.11.0-15-generic </span>
<span class="s">}</span>
<span class="s">EOF</span>
</pre></div>
</td></tr></table></div><p>Liegt das Zielsystem auf einem externen Datenträger wie z.B. einer USB-HDD, so ist zu obigem Eintrag zusätzlich direkt unter der Zeile <code class="notranslate">menuentry</code> die Zeile 3 einzutragen:
</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span>....
menuentry <span class="s2">"Ubuntu, auf externer Festplatte"</span> <span class="o">{</span>
insmod usb
insmod ext2
....
</pre></div>
</td></tr></table></div><p>
damit die folgenden Daten richtig ausgelesen werden können. Das externe Medium muss aber grundsätzlich vom BIOS erkannt und ausgelesen werden können. Insbesondere einige USB 3.0-Ports haben damit in diesem frühen Zeitpunt noch Probleme.</p></div><div class="section_2"><h3 id="Anzeige-in-der-Menuezeile">Anzeige in der Menüzeile<a class="headerlink" href="#Anzeige-in-der-Menuezeile">¶</a></h3><p>
Für Ubuntu wird aufgrund der System-ID als Anzeige im Grubmenü immer "Ubuntu" verwendet, auch wenn es sich z.B. um das Derivat "Lubuntu" handelt. Dieser Umstand ist für viele Benutzer unbefriedigend. Um diese Anzeige auf das wirkliche Derivat zu bringen, kann man nachfolgende Veränderungen vornehmen:</p><div class="section_3"><h4 id="Derivate-Kennung-aktivieren">Derivate-Kennung aktivieren<a class="headerlink" href="#Derivate-Kennung-aktivieren">¶</a></h4><p>
Es ist in der <strong>/etc/default/grub</strong> folgende Änderung mit Rootrechten einzubringen:
</p><pre class="notranslate">#GRUB_DISTRIBUTOR=`lsb_release -i -s 2&gt; /dev/null || echo Debian`
GRUB_DISTRIBUTOR="Lubuntu"</pre><p>
Hier wurde als Ersatz für <img alt="{*}" src="../_/37868c2b60e9556f3ed2fca9185705260fd214a9.png"/> Ubuntu beispielhaft <img alt="{l}" src="../_/4cfef3b6ccbfb0ad610cc831900bb88f3d9f5027.png"/> Lubuntu für die Anzeige im Grubmenü eingesetzt.</p></div><div class="section_3"><h4 id="Basis-fuer-Umstellung-der-Anzeige">Basis für Umstellung der Anzeige<a class="headerlink" href="#Basis-fuer-Umstellung-der-Anzeige">¶</a></h4><p>
In das Verzeichnis <strong>/etc/grub.d</strong> wird das folgende Skript ausführbar als <strong>00_abfrage</strong> abgelegt. Damit wird sichergestellt:
</p><ul><li><p>das bei einem Upgrade von <a class="internal" href="../grub_2.html">GRUB 2</a> </p><ul><li><p>diese Änderung wieder übernommen wird</p></li><li><p>die Bezeichnung im Skript <strong>/etc/grub.d/10_linux</strong> akzeptiert wird </p></li></ul></li></ul><p>
</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="ch">#!/bin/sh -e</span>
<span class="o">[</span> <span class="s2">"</span><span class="nv">$GRUB_DISTRIBUTOR</span><span class="s2">"</span> <span class="o">]</span> <span class="o">||</span> exit<span class="p">;</span>
<span class="o">[</span> <span class="s2">"</span><span class="nv">$GRUB_DISTRIBUTOR</span><span class="s2">"</span> <span class="o">=</span> <span class="s2">"Ubuntu"</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nb">exit</span>
<span class="nb">echo</span> <span class="s2">"OS-Bezeichnung = </span><span class="nv">$GRUB_DISTRIBUTOR</span><span class="s2">"</span>  &gt;<span class="p">&amp;</span><span class="m">2</span><span class="p">;</span>
<span class="nv">request_file</span><span class="o">=</span>/etc/grub.d/10_linux<span class="p">;</span>
<span class="k">if</span> grep -r <span class="s1">'Ubuntu|Kubuntu'</span> <span class="nv">$request_file</span><span class="p">;</span> <span class="k">then</span>
   sed -i s/Ubuntu<span class="se">\|</span>Kubuntu/<span class="nv">$GRUB_DISTRIBUTOR</span>/g <span class="nv">$request_file</span><span class="p">;</span>
<span class="k">fi</span><span class="p">;</span>
</pre></div>
</td></tr></table></div><p>Man testet dieses danach im Terminal <sup><a href="#source-1">[1]</a></sup> aus mit</p><div class="bash"><div class="contents"><pre class="notranslate">sudo grub-mkconfig </pre></div></div><p>und überprüft die dabei angezeigten Anzeigen unter dem jeweiligen <code class="notranslate">menuentry</code>, bevor man das mit</p><div class="bash"><div class="contents"><pre class="notranslate">sudo update-grub </pre></div></div><p>in sein System übernimmt.</p></div></div><div class="section_2"><h3 id="LVM-und-RAID">LVM und RAID<a class="headerlink" href="#LVM-und-RAID">¶</a></h3><p>
Ein Fortschritt von GRUB 2 ist, dass die Informationen für ein Betriebssystem von einem <a class="internal" href="../software-raid.html">RAID-Verbund</a> oder <a class="internal" href="../lvm.html">LVM</a> sowie eine Kombination aus beiden, <span class="underline">direkt</span> ausgelesen werden kann.</p><div class="box warning"><h3 class="box warning">Achtung!</h3><div class="contents"><p>Die Funktion <em>"savedefault"</em> bzw. <em>"recordfail"</em> funktioniert zur Zeit weder auf einem RAID-Verbund (siehe <a class="interwiki interwiki-bug" href="https://launchpad.net/bugs/560594">560594</a>), einem LVM-Dateisystem (siehe <a class="interwiki interwiki-bug" href="https://launchpad.net/bugs/625234">625234</a>) noch beim <a class="internal" href="../btrfs.html">Btrfs</a>-Dateisystem!
</p></div></div><div class="section_3"><h4 id="LVM-RAID-Skript">LVM-RAID-Skript<a class="headerlink" href="#LVM-RAID-Skript">¶</a></h4><p>
Ein Menüeintrag am Beispiel einer Kombination kann dann so aussehen:</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="ch">#! /bin/sh -e</span>
<span class="nb">echo</span> <span class="s2">"Füge eigene Menü-Option Saucy Salamander ein"</span> &gt;<span class="p">&amp;</span><span class="m">2</span>
 cat <span class="s">&lt;&lt; EOF</span>
<span class="s">menuentry "Ubuntu, mit Linux 3.11.0-15-generic" {</span>
<span class="s">	insmod raid</span>
<span class="s">	insmod mdraid</span>
<span class="s">	insmod lvm</span>
<span class="s">	insmod ext2</span>
<span class="s">	set root='(vg_1-boot)'</span>
<span class="s">	search --no-floppy --fs-uuid --set=root 11992cde-b1d9-4392-bcc4-13c2ce8702aa</span>
<span class="s">	linux	/vmlinuz-3.11.0-15-generic root=/dev/mapper/vg_1-root ro quiet splash</span>
<span class="s">	initrd	/initrd.img-3.11.0-15-generic</span>
<span class="s">}</span>
<span class="s">EOF</span>
</pre></div>
</td></tr></table></div><p>Relevant sind dabei die Zeilen, die mit <code class="notranslate">insmod</code> beginnen. Hier werden die Module für das RAID <code class="notranslate">raid</code>, <code class="notranslate">mdraid</code> und für das LVM benötigte Modul <code class="notranslate">lvm</code> geladen. Des weiteren muss die Bezeichnung für das LVM-Device (hier im Beispiel <code class="notranslate">vg_1-boot</code> in Zeile 11 bzw. <code class="notranslate">vg_1-root</code> in Zeile 13) neben den anderen Daten an die eigenen Gegebenheiten angepasst werden!</p><p>In der Regel werden die erforderlichen Module durch das Skript <strong>/etc/grub.d/10_linux</strong> bei einem <code class="notranslate">grub-mkconfig</code> bzw. <code class="notranslate">update-grub</code> (<a class="internal" href="../grub_2/terminalbefehle.html#Befehle-zum-Konfigurieren-des-Auswahl-Menues">siehe</a>) automatisch ermittelt und eingesetzt.</p></div></div><div class="section_2"><h3 id="Symlink-zum-Wurzelverzeichnis">Symlink zum Wurzelverzeichnis<a class="headerlink" href="#Symlink-zum-Wurzelverzeichnis">¶</a></h3><p>
Ein <a class="interwiki interwiki-wikipedia" href="https://de.wikipedia.org/wiki/Symbolische_Verkn%C3%BCpfung">symlink</a>-Menü-Eintrag startet wie der Kernel-Menü-Eintrag auch einen Linux Kernel. Dabei wird anstelle einer kompletten Pfad- und Kernel-Bezeichnung </p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span>       linux   /boot/vmlinuz-2.6.32-25-generic <span class="nv">root</span><span class="o">=</span><span class="nv">UUID</span><span class="o">=</span>41b9df5e-....-...
       initrd  /boot/initrd.img-2.6.32-25-generic 
</pre></div>
</td></tr></table></div><p>
der Pfad als Symlink zum Kernel angegeben. Dieser Symlink befindet sich direkt im Wurzelverzeichnis und verweist im folgenden Beispiel auf den jeweils aktuellen Kernel im Verzeichnis <strong>/boot</strong>.</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span>       linux /vmlinuz <span class="nv">root</span><span class="o">=</span><span class="nv">UUID</span><span class="o">=</span>41b9df5e-...-...
       initrd /initrd.img
</pre></div>
</td></tr></table></div><div class="box experts"><h3 class="box experts">Experten-Info:</h3><div class="contents"><p>Es ist zu beachten, dass der automatisch generierte Symlink im Wurzelverzeichnis bei einem Betriebssystem mit einem <a class="internal" href="../efi_bootmanagement.html">EFI Bootmanagement</a> den Einsprung für das <strong>secure-boot</strong> auf das Image <strong>vmlinuz-xxx-generic.efi.signed</strong> nicht berücksichtigt!</p><p>Es muss <span class="underline">immer</span> geprüft werden, ob dieser Symlink sowohl nach einem Kernelupdate als auch beim <a class="internal" href="../kernel.html#Kernel-deinstallieren">Entfernen alter Kernel</a> richtig gesetzt wurden. Es können sich dabei diese symbolischen Links so verändern, dass ein Starten des Systems verhindert wird.
</p></div></div></div><div class="section_2"><h3 id="Symlink-zur-Boot-Partition">Symlink zur Boot-Partition<a class="headerlink" href="#Symlink-zur-Boot-Partition">¶</a></h3><p>
Befindet sich das Verzeichnis <strong>/boot</strong> auf einer separaten Partition, so greift die Vorgehensweise unter <a class="crosslink" href="#Symlink-zum-Wurzelverzeichnis">Symlink zum Wurzelverzeichnis</a> nicht. Dazu muss dann das folgende Skript (mit z.B. mit <strong>09_K_aktuell</strong> bezeichnet) zwischen geschaltet werden:</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="ch">#!/bin/sh -e</span>
<span class="c1"># Hiermit wird bei einem 'update-grub' der aktuelle Kernel</span>
<span class="c1"># intern auf eine einheitliche Form innerhalb '/boot' verlinkt.</span>

SETZE_LINK <span class="o">()</span> <span class="o">{</span>
rm -f <span class="si">${</span><span class="nv">SUCHE_WAS</span><span class="si">}</span><span class="p">;</span>
<span class="nv">list</span><span class="o">=</span><span class="k">$(</span> <span class="k">for</span> i in <span class="si">${</span><span class="nv">SUCHE_WAS</span><span class="si">}</span>-* <span class="p">;</span> <span class="k">do</span>
    <span class="nb">echo</span> -n <span class="s2">"</span><span class="nv">$i</span><span class="s2"> "</span> <span class="p">;</span> <span class="k">done</span> <span class="k">)</span>
<span class="o">[</span> <span class="s2">"x</span><span class="nv">$list</span><span class="s2">"</span> <span class="o">=</span> <span class="s2">"x"</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nb">exit</span> 
<span class="nv">linux</span><span class="o">=</span><span class="k">$(</span> version_find_latest <span class="nv">$list</span> <span class="k">)</span>
ln -s <span class="s2">"</span><span class="nv">$linux</span><span class="s2">"</span> <span class="si">${</span><span class="nv">SUCHE_WAS</span><span class="si">}</span> &gt; /dev/null
<span class="nb">echo</span> <span class="s2">"Link für </span><span class="nv">$linux</span><span class="s2"> eingefügt"</span>  &gt;<span class="p">&amp;</span><span class="m">2</span><span class="p">;</span>
<span class="o">}</span>

. /usr/lib/grub/grub-mkconfig_lib
<span class="nb">cd</span> /boot<span class="p">;</span>

<span class="nv">SUCHE_WAS</span><span class="o">=</span><span class="s2">"vmlinuz"</span> <span class="o">&amp;&amp;</span> SETZE_LINK<span class="p">;</span>
<span class="nv">SUCHE_WAS</span><span class="o">=</span><span class="s2">"initrd.img"</span> <span class="o">&amp;&amp;</span> SETZE_LINK<span class="p">;</span>
</pre></div>
</td></tr></table></div><p>Nun wird nach jedem Kernelupdate bzw. nach der Eingabe in das Terminal von:</p><div class="bash"><div class="contents"><pre class="notranslate">sudo update-grub </pre></div></div><p>ausschließlich der jeweils <span class="underline">aktuelle</span> (höchste) Kernel als Symlink im Verzeichnis für die Images angeboten.</p><div class="box experts"><h3 class="box experts">Experten-Info:</h3><div class="contents"><p>Dieses Skript berücksichtigt auch die Belange eines <a class="internal" href="../efi_bootmanagement.html">EFI Bootmanagement</a> und setzt sofern ein <strong>secure-boot</strong> erkannt wurde, den Symlink auf das aktuelle Image <strong>vmlinuz-xxx-generic.efi.signed</strong>. Das Skript kann somit generell für eine Korrektur des automatisch gesetzten <a class="crosslink" href="#Symlink-zur-Boot-Partition">Symlink zur Boot-Partition</a> benutzt werden.
</p></div></div></div><div class="section_2"><h3 id="Configfile">Configfile<a class="headerlink" href="#Configfile">¶</a></h3><p>
Mit einem configfile-Menü-Eintrag kann man GRUB 2 anweisen, die Menü-Konfiguration zur Laufzeit aus einer anderen Datei als der standardmäßigen <strong>/boot/grub/grub.cfg</strong> zu entnehmen. Das ist z.B. dann sinnvoll, wenn man eine weitere Distribution auf dem Computer installiert hat, die auch GRUB 2 als Bootloader einsetzt oder aber auch einfach nur für Experimente.</p><p>Beispiel:
</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="ch">#! /bin/sh -e</span>
<span class="nb">echo</span> <span class="s2">"Adding Precise Testing menuentry"</span> &gt;<span class="p">&amp;</span><span class="m">2</span>
 cat <span class="s">&lt;&lt; EOF</span>
<span class="s">menuentry "Nachladen Precise grub.cfg von /dev/sdb1" {</span>
<span class="s">        insmod ext2</span>
<span class="s">        set root='(hd1,1)'</span>
<span class="s">	search --no-floppy --fs-uuid --set=root 11992cde-b1d9-4392-bcc4-13c2ce8702aa        </span>
<span class="s">        configfile  /boot/grub/grub.cfg</span>
<span class="s">}</span>
<span class="s">EOF</span>
</pre></div>
</td></tr></table></div><p>Hier wird die <strong>/boot/grub/grub.cfg</strong> einer Installation eingelesen, die sich auf der ersten Partition der zweiten Festplatte im Computer befindet. Mit der 
<span class="key">Esc</span> -Taste kann man wieder in das Menü zurück wechseln, von dem aus aufgerufen wurde.</p></div><div class="section_2"><h3 id="Submenue-einrichten">Submenü einrichten<a class="headerlink" href="#Submenue-einrichten">¶</a></h3><p>
Man kann die Funktion <a class="internal" href="../grub_2/konfiguration.html#Erscheinungsbild-Grubmenue">Submenü</a> auch für seine eigenen Zwecke benutzen.</p><p>Um das zu realisieren, kann man verschiedene Wege beschreiten - wichtig ist nur, dass man die relevanten Menüpunkte (Skripte) zusammenfasst und vor diesen die Sequenz</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span>submenu <span class="s1">'Meine Menüsammlung'</span> <span class="o">{</span>
</pre></div>
</td></tr></table></div><p>
im ersten Skript einbringt und am Ende der Sammlung noch eine geschweifte Klammer hinter dem letzten Skript <span class="underline">zusätzlich</span> anordnet. Oder man macht das z.B.: jeweils in einem Skript, dass dann in der Zählung entsprechend angelegt wird:
</p><ul><li><p><strong>12A_submenu_start</strong> mit:</p></li></ul><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="ch">#! /bin/bash -e</span>
cat <span class="s">&lt;&lt; EOF</span>
<span class="s">submenu 'Meine Menüsammlung' {</span>
<span class="s">EOF</span>
</pre></div>
</td></tr></table></div><p>
</p><ul><li><p><strong>13_... bis 16_...</strong> Skriptesammlung</p></li><li><p><strong>19A_submenu_abschluss</strong> mit:</p></li></ul><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="ch">#! /bin/bash -e</span>
cat <span class="s">&lt;&lt; EOF</span>
<span class="s">}</span>
<span class="s">EOF</span>
</pre></div>
</td></tr></table></div></div></div><div class="section_1"><h2 id="Fremde-Betriebssysteme-Windows-mittels-chainloader-laden">Fremde Betriebssysteme (Windows) mittels chainloader laden<a class="headerlink" href="#Fremde-Betriebssysteme-Windows-mittels-chainloader-laden">¶</a></h2><p>
Der <a class="interwiki interwiki-wikipedia" href="https://de.wikipedia.org/wiki/Boot-Loader#Chain-Loader">chainloader</a>-Menü-Eintrag wird für Betriebssysteme genutzt deren Kernel GRUB 2 nicht direkt laden kann - in der Praxis also in aller Regel Windows. Dabei wird GRUB 2 angewiesen, das fremde System zu starten, indem es entweder den Partitions-Bootsektor der Partition des betreffenden Betriebssystems oder aber den <a class="interwiki interwiki-wikipedia" href="https://de.wikipedia.org/wiki/Master-Boot-Record">MBR</a> der Platte auf der das betreffende Betriebssystem installiert ist, lädt.</p><p>Dabei muss man aber unterscheiden, wie das fremde Betreibssystem installiert wurde:
</p><ul><li><p>im <em>"BIOS-Modus"</em></p></li><li><p>im <em>"EFI-Modus"</em></p></li></ul><p>
</p><div class="box experts"><h3 class="box experts">Experten-Info:</h3><div class="contents"><p>Eine Mischung aus beiden Modi ist nicht startfähig bzw. können sich nicht wechselseitig aufrufen.
</p></div></div><div class="section_2"><h3 id="Beispiel-BIOS-Modus">Beispiel BIOS-Modus<a class="headerlink" href="#Beispiel-BIOS-Modus">¶</a></h3><p>
In der Regel wird das Windows bei der Installation von Ubuntu automatisch gefunden und der Menüeintrag richtig erstellt. Mit dem folgenden Skript kann man Probleme oder Besonderheiten umgehen, um Windows zu starten.</p><p>Man muss als erstes ermitteln, auf welcher Partition der Bootmanager (die Datei <strong>bootmgr</strong>) von Windows sich befindet. Das kann je nach Art der Installation von Windows auf der separaten Partion mit der Bezeichnung
</p><ul><li><p><em>"System-reserviert"</em></p></li></ul><p>oder auf einer normalen <em>"NTFS"</em>-Partition sein. Diese sei beispielhaft <strong>/dev/sda1</strong>. Mit dieser Information ermittelt man die <a class="internal" href="../uuid.html">UUID</a> mit:</p><div class="bash"><div class="contents"><pre class="notranslate">sudo grub-probe -t fs_uuid -d /dev/sda1 </pre></div></div><p>Diese <a class="internal" href="../uuid.html">UUID</a> wird nun in das folgende Skript in Zeile 7 übernommen:</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="ch">#! /bin/sh -e</span>
<span class="nb">echo</span> <span class="s2">"Füge einen Starteintrag für Windows ein"</span> &gt;<span class="p">&amp;</span><span class="m">2</span>
cat <span class="s">&lt;&lt; EOF</span>
<span class="s">menuentry "Microsoft Windows im BIOS-Modus starten" {</span>
<span class="s">        insmod part_msdos</span>
<span class="s">	insmod ntfs</span>
<span class="s">	search --no-floppy --fs-uuid --set=root eaf815c4f8159045</span>
<span class="s">        parttool \${root} hidden-</span>
<span class="s">	drivemap -s (hd0) \${root}</span>
<span class="s">	chainloader +1</span>
<span class="s">}</span>
<span class="s">EOF</span>
</pre></div>
</td></tr></table></div><div class="box experts"><h3 class="box experts">Experten-Info:</h3><div class="contents"><p>Es ist darauf zu achten, dass in der Zeile 9 die Nummerierung von <strong>(hd0)</strong> sich auf den Datenträger bezieht, auf der sich GRUB 2 mit der <strong>../grub.cfg</strong> befindet. Herausfinden lässt sich das, indem man im Grub-Menü mit 
<span class="key">C</span>  die <code class="notranslate">cmdline</code> aufruft und am Prompt 
</p><ul><li><p>grub&gt; <strong>ls</strong></p></li></ul><p>eingibt. Aus den angezeigten Datenträgern muss man nun die richtige Zuordnung treffen (was manchmal nicht ganz einfach ist). Nachdem man mit 
<span class="key">Esc</span>  die <code class="notranslate">cmdline</code> verlassen und mit den Pfeiltasten den Windows-Eintrag ausgewählt hat, kann man diesen mit 
<span class="key">E</span>  zum Editieren aufrufen.</p><p>Nach der Korrektur der "drivemap"-Zeile muss man nun mit der Taste 
<span class="key">F10</span>  den Bootvorgang starten.
</p></div></div></div><div class="section_2"><h3 id="Beispiel-EFI-Modus">Beispiel EFI-Modus<a class="headerlink" href="#Beispiel-EFI-Modus">¶</a></h3><p>
</p><div class="box notice"><h3 class="box notice">Hinweis:</h3><div class="contents"><p>Die folgende Beschreibung zum EFI-Modus ist erst ab <a class="internal" href="../precise_pangolin.html">Precise 12.04.2 LTS</a> anwendbar! <strong>fast-boot</strong> sowie <strong>secure-boot</strong> dürfen im Setup nicht aktiviert sein!
</p></div></div><p>In der Regel wird ein EFI-Windows bei der Installation von Ubuntu (bis Version <a class="internal" href="../raring_ringtail.html">Raring Ringtail</a> (13.04)) nicht automatisch gefunden und der Menüeintrag fehlt deshalb im Grubmenü. Das ist kein <a class="interwiki interwiki-bug" href="https://launchpad.net/bugs/"></a>, sondern konzeptionell so gewollt! Läßt sich das Windows aber über das EFI-Menü des Rechners starten, dann kann man das auch in das Grubmenü einbringen und von hier aus das Windows starten.</p><p>Dabei ist es wichtig, dass das Ubuntu im EFI-Modus gestartet wurde, von dem aus das Windows aufgerufen werden soll! Dazu gibt man in ein Terminal <sup><a href="#source-1">[1]</a></sup> ein:</p><div class="bash"><div class="contents"><pre class="notranslate">sudo parted -l </pre></div></div><p>und sucht in der Ausgabe unter 
</p><ul><li><p><em>"Flags"</em> nach</p><ul><li><p><em>"EFI system partition"</em></p></li></ul></li></ul><p>(oder einem sinngemäß vergleichbaren Eintrag) und überprüft das Vorhandensein einer EFI-Partition. Diese Partition wird zur Erstellung des folgenden Skriptes als Ziel verwendet und wird z.B. als <strong>29_windows</strong> lauffähig in das Verzeichnis <strong>/etc/grub.d</strong> abgelegt und sollte nach einen</p><div class="bash"><div class="contents"><pre class="notranslate">sudo update-grub </pre></div></div><p>einen Eintag im Grubmenü zum Starten des Windows bereitstellen.</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="ch">#!/bin/bash</span>
<span class="c1"># EFI-Partition suchen und auswerten</span>
<span class="k">if</span> <span class="o">[</span> -f /boot/efi/EFI/Microsoft/Boot/bootmgfw.efi <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
	<span class="nv">EFI_UUID</span><span class="o">=</span><span class="k">$(</span> grub-probe -t fs_uuid /boot/efi/EFI <span class="k">)</span>
	<span class="nb">echo</span> <span class="s2">"Menüeintrag für Windows eingefügt"</span> &gt;<span class="p">&amp;</span><span class="m">2</span>

cat <span class="s">&lt;&lt;EOF</span>
<span class="s">menuentry "Windows 8 Pro (UEFI)" {</span>
<span class="s">	insmod fat</span>
<span class="s">	insmod chain</span>
<span class="s">	search --no-floppy --fs-uuid --set=root ${EFI_UUID}</span>
<span class="s">	chainloader /EFI/Microsoft/Boot/bootmgfw.efi</span>
<span class="s">}</span>
<span class="s">EOF</span>
<span class="k">fi</span>
</pre></div>
</td></tr></table></div><div class="box notice"><h3 class="box notice">Hinweis:</h3><div class="contents"><p>Ab Windows 7 werden die Linux Partitionen (im EFI-Modus) unter Windows mit einem Laufwerksbuchstaben versehen und angezeigt. Da Windows diese dennoch nicht lesen kann, bietet es bei einem Zugriff auf das Laufwerk an, dieses zu formatieren.</p><p>Möchte man verhindern, dass Windows den Partitionen einen Laufwerksbuchstaben zuweist, so kann man mit Hilfe von <a class="internal" href="../gparted.html">gparted</a> den Partitionen z.B. die Markierung <em>atvrecv</em> zuweisen. Ein verstecken der Partition hilft bei Laufwerken mit <a class="interwiki interwiki-wikipedia" href="https://de.wikipedia.org/wiki/GUID_Partition_Table">GUID-Partitions-Tabelle</a> nicht mehr.
</p></div></div></div></div><div class="section_1"><h2 id="Von-ISO-Dateien-mittels-loopback-booten">Von ISO-Dateien mittels loopback booten<a class="headerlink" href="#Von-ISO-Dateien-mittels-loopback-booten">¶</a></h2><p>
Der loopback-Menü-Eintrag dient dazu .iso Dateien über GRUB direkt einzubinden und als Live-System zu booten.
</p><div class="box warning"><h3 class="box warning">Achtung!</h3><div class="contents"><p><code class="notranslate">loopback</code> hängt die gesamte Partition, auf der sich die ISO-Datei befindet, in das Live-System unter <strong>/isodevice</strong> ein. Auf den Inhalt bzw. die Daten dieser so eingebundenen Partition kann , bis auf das ISO selbst, les- und schreibbar zugegriffen werden.</p><p>Ein so gestartetes Live-System kann nicht für Installationen verwendet werden: Der Installer möchte <strong>/isodevice</strong> aushängen, was jedoch (auch per <a class="internal" href="../mount.html">umount</a>) nur scheitern kann und dazu führt, dass die Installation auch im letzten Schritt, des Kopierens der Daten, nicht voranschreitet und keine Dateien kopiert werden können (Lubuntu 14.04). Abhilfe kann nur geschafft werden, wenn man mit <code class="notranslate">sudo umount -lfr</code> das Aushängen des <strong>/isodevice</strong> erzwingt. Die Installation muss natürlich dennoch auf eine andere Partition erfolgen, Änderungen am Live-System sind danach auch nicht mehr möglich.</p><p>Damit das für den Live-Betrieb ohne Installation nötige Einbinden einwandfrei ausgeführt werden kann, <span class="underline">muss</span> das Folgende beachtet werden:</p><p>1. Die ISO-Datei darf nicht auf einem <a class="internal" href="../software-raid.html">RAID-Verbund</a> und/oder <a class="internal" href="../logical_volume_manager.html">LVM</a> basiertem System abgelegt werden. Eine Ausnahme besteht, wenn /boot außerhalb des RAID bzw. LVM angelegt wurde. Die Basis-Dateien (<code class="notranslate">vmlinuz</code> bzw. <code class="notranslate">initrd</code>) werden zwar von Grub 2 noch ausgelesen, die darin integrierten Routinen können jedoch wegen fehlender Treiber nicht korrekt arbeiten.</p><p>2. Das Skript <span class="underline">muss</span> in der Nummerierung später als 10 angelegt sein, ansonsten werden die Kerneleinträge <span class="underline">nicht</span> berücksichtigt.</p><p>3. Das Skript darf <span class="underline">keine</span> Partitionen enthalten, die bereits mit den <strong>/etc/grub.d/10_linux</strong> aufgerufen werden/wurden oder mit den anderen Skripten (siehe oben) aufgerufen werden.
</p></div></div><div class="section_2"><h3 id="Beispiel-Ubuntu-Iso">Beispiel Ubuntu-Iso<a class="headerlink" href="#Beispiel-Ubuntu-Iso">¶</a></h3><p>
</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="ch">#! /bin/sh -e</span>
<span class="nb">export</span> <span class="nv">GRUB_LOOPBACK_ISO_FILE</span><span class="o">=</span><span class="s2">"/Pfad_zum_ISO/ubuntu-12.04-desktop-i386.iso"</span>
<span class="nb">echo</span> <span class="s2">"Adding Live CD entry"</span> &gt;<span class="p">&amp;</span><span class="m">2</span>

 cat <span class="s">&lt;&lt; EOF</span>
<span class="s">menuentry 'Precise Pangolin Live CD i386-ISO booten' {</span>
<span class="s">insmod part_msdos</span>
<span class="s">insmod ntfs</span>
<span class="s">insmod ext2</span>
<span class="s">search -n -f --set=root ${GRUB_LOOPBACK_ISO_FILE}</span>
<span class="s">    loopback loop ${GRUB_LOOPBACK_ISO_FILE}</span>
<span class="s">    linux (loop)/casper/vmlinuz boot=casper iso-scan/filename=${GRUB_LOOPBACK_ISO_FILE} \</span>
<span class="s">        ${GRUB_CMDLINE_LINUX_DEFAULT} ${GRUB_CMDLINE_LINUX} quiet splash --</span>
<span class="s">    initrd (loop)/casper/initrd.lz</span>
<span class="s">}</span>
<span class="s">EOF</span>
</pre></div>
</td></tr></table></div><p>Die Bezeichnung <code class="notranslate">loop</code> im obigen Beispiel als Identmerkmal ist frei wählbar, sollte aber keine Umlaute enthalten! Durch dieses Skript wird ein Menü-Eintrag generiert, der das mittels <strong>/Pfad_zum_ISO/ubuntu-xyz-i386.iso</strong> ausgewiesene ISO-Image auf den Festplatten sucht und als Live-CD bootet. Der <strong>/Pfad_zum_ISO/</strong> darf im übrigen nicht das Laufwerk enthalten, da die Zeile</p><pre class="notranslate"> search -n -f --set=root ${GRUB_LOOPBACK_ISO_FILE} </pre><p> auf allen verfügbaren Laufwerken nach dem ${GRUB_LOOPBACK_ISO_FILE} sucht, und das Laufwerk, auf dem die Datei liegt, als <strong>/root</strong> setzt.  Außerdem darf der Pfad auch keinen logischen Link beinhalten, weil grub diesem nicht folgen kann.</p><p>
</p><table><tr class="kopf"><td> Einstellungen in der <strong>/etc/default/grub</strong> </td></tr><tr><td> GRUB_CMDLINE_LINUX_DEFAULT="quiet splash" </td></tr><tr><td> GRUB_CMDLINE_LINUX="locale=de_DE bootkbd=de console-setup/layoutcode=de" </td></tr></table><p>
Mit diesen Einstellungen werden die Desktop- und die Tastatur-Einstellungen gleich auf Deutsch gestartet. Es können auch <a class="internal" href="../grub_2/konfiguration.html#Variable-fuer-Kernelzeilen">weitere Parameter übergeben</a> werden. Auch der Eintrag für das ISO-Image kann alternativ entsprechend <a class="internal" href="../grub_2/konfiguration.html#Eigene-Variablen">eigene Variablen</a> direkt eingebracht werden:</p><p>
</p><table><tr class="kopf"><td> Einstellungen in der <strong>/etc/default/grub</strong> </td></tr><tr><td> export GRUB_LOOPBACK_ISO_FILE="/Pfad_zum_ISO/ubuntu-12.04-desktop-i386.iso" </td></tr></table><p>
Dafür kann dann die relevante Zeile 2 im obigen <a class="crosslink" href="#Beispiel-Ubuntu-Iso">Skript</a> entfallen. Wenn man das Live-System nicht nur benutzen, sondern auf der Festplatte installieren möchte, muss man vor der Installation das Image mittels 
</p><div class="bash"><div class="contents"><pre class="notranslate">sudo umount -l -r -f /isodevice </pre></div></div><p>
aushängen, da sonst die Installation nicht möglich ist. Da das <strong>/isodevice</strong> ansonsten in Benutzung ist, kann es nicht automatisch von der Installtionsroutine ausgehängt werden.</p></div><div class="section_2"><h3 id="Beispiel-Lubuntu-14-10-64bit">Beispiel Lubuntu 14.10 64bit<a class="headerlink" href="#Beispiel-Lubuntu-14-10-64bit">¶</a></h3><p>
</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="ch">#! /bin/sh -e</span>

<span class="nb">export</span> <span class="nv">ISOFILE</span><span class="o">=</span><span class="s2">"/Pfad_zum_ISO/lubuntu-14.10-desktop-amd64.iso"</span>
<span class="nb">echo</span> <span class="s2">"Found ISOFILE image: </span><span class="si">${</span><span class="nv">ISOFILE</span><span class="si">}</span><span class="s2">"</span> &gt;<span class="p">&amp;</span><span class="m">2</span>
cat <span class="s">&lt;&lt; EOF</span>
<span class="s">menuentry "${ISOFILE}" {</span>
<span class="s">	insmod loopback</span>
<span class="s">	insmod iso9660</span>
<span class="s">	insmod part_msdos</span>
<span class="s">	insmod part_gpt</span>
<span class="s">	insmod ext2</span>
<span class="s">	insmod ntfs</span>
<span class="s">	insmod btrfs</span>
<span class="s">	search -n -f --set=root ${ISOFILE}</span>
<span class="s">	loopback loop ${ISOFILE}</span>
<span class="s">	linux (loop)/casper/vmlinuz.efi boot=casper iso-scan/filename=${ISOFILE} ro noprompt noeject noplymouth </span>
<span class="s">	initrd (loop)/casper/initrd.lz</span>
<span class="s">	}</span>
<span class="s">EOF</span>
</pre></div>
</td></tr></table></div></div><div class="section_2"><h3 id="Beispiel-Parted-Magic-Iso">Beispiel Parted Magic Iso<a class="headerlink" href="#Beispiel-Parted-Magic-Iso">¶</a></h3><p>
</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="ch">#! /bin/sh -e</span>
<span class="nb">echo</span> <span class="s2">"Adding Parted Magic ISO entry"</span> &gt;<span class="p">&amp;</span><span class="m">2</span>
 cat <span class="s">&lt;&lt; EOF</span>
<span class="s">menuentry "Parted Magic - ISO" {</span>
<span class="s">       loopback loop (hd0,3)/pmagic-4.4.iso</span>
<span class="s">       linux (loop)/pmagic/bzImage isofrom=/dev/sda3/pmagic-4.4.iso edd=off noapic load_ramdisk=1 prompt_ramdisk=0 rw vga=791 sleep=10 loglevel=0 keymap=de</span>
<span class="s">       initrd (loop)/pmagic/initramfs</span>
<span class="s">}</span>
<span class="s">EOF</span>
</pre></div>
</td></tr></table></div><p>
Dieser Eintrag bootet das <a class="internal" href="../parted_magic.html">Parted Magic</a>-ISO Version 4.4 von der dritten Partition der ersten Festplatte.</p></div><div class="section_2"><h3 id="Kernel-Boot-Optionen-fuer-ISO-ermitteln">Kernel-Boot-Optionen für ISO ermitteln<a class="headerlink" href="#Kernel-Boot-Optionen-fuer-ISO-ermitteln">¶</a></h3><p>
Um ISO-Dateien erfolgreich booten zu können sind - wie man an den langen <code class="notranslate">GRUB_CMDLINE_LINUX</code> bzw. <code class="notranslate">linux</code>-Zeilen in den Beispielen sieht - die richtigen Kernel-Boot-Optionen von entscheidender Bedeutung. Diese sind jedoch von ISO zu ISO unterschiedlich. Die Optionen sind aber stets auf dem ISO erhalten, so dass man diese nur auslesen <sup><a href="#source-2">[2]</a></sup> muss, um die Optionen setzen zu können.</p><p>In aller Regel befinden sich diese Optionen in der Datei <strong>isolinux.cfg</strong>, die sich im Verzeichnis <strong>/isolinux</strong> innerhalb des ISO befindet. Dort kann man auch herauslesen, welche Dateien im ISO die zu ladende Kernel-Datei und Ramdisk enthalten.</p><p>Bei den offiziellen Ubuntu ISO-Dateien verzweigt die <strong>isolinux.cfg</strong> in weitere Dateien, so dass diese Informationen in der <strong>txt.cfg</strong> im Verzeichnis <strong>/isolinux</strong> zu finden sind.</p></div></div><div class="section_1"><h2 id="Kaskadiertes-Starten">Kaskadiertes Starten<a class="headerlink" href="#Kaskadiertes-Starten">¶</a></h2><p>
Sofern man z.B. einen headless Server betreibt und diesen einschaltet, kann man ohne Monitor nicht erkennen, ob das Booten erfolgreich war oder nicht - schlimmer noch, man erkennt erst nach einem erfolglosen Verbindungsversuch z.B.: über "ssh", dass etwas nicht stimmt. Nun kann man das System erneut starten und hoffen, dass es dann funktioniert - nur GRUB startet (normalerweise) mit der gleichen Konfiguration. Und hier setzt jetzt das Kaskadierte Starten als Notfallbehandlung (fallback-modus) an.</p><p>Vorausgesetzt man hat ein Reserve-System in einer anderen Partition auf demselben Rechner oder externem Datenträger, dann kann man GRUB 2 so konfigurieren, dass nach einem <em>erfolglosen</em> Start automatisch das Reservesystem gestartet wird, war dieser Bootvorgang und die Reparatur erfolgreich, so wird beim nächsten Einschalten (oder Rebooten) wieder das (erste) Hauptsystem ausgewählt.</p><div class="section_2"><h3 id="Fehler-in-Grub-abfangen">Fehler in Grub abfangen<a class="headerlink" href="#Fehler-in-Grub-abfangen">¶</a></h3><p>
Um Fehler abzufangen, die von GRUB_2 erkannt werden können (z.B. dass nach einem Update die Kerneleinträge falsch sind), so bietet sich die nachfolgend beschriebene Prozedur an.</p><div class="section_3"><h4 id="Vorbereitungen-Grubfehler">Vorbereitungen Grubfehler<a class="headerlink" href="#Vorbereitungen-Grubfehler">¶</a></h4><p>
</p><p>
</p><table style="width: 40%"><tr class="kopf"><td> Einstellungen in der <strong>/etc/default/grub</strong> </td></tr><tr><td> GRUB_DEFAULT="0" </td></tr><tr><td> export GRUB_FALLBACK="2" </td></tr><tr><td> GRUB_TIMEOUT_STYLE=hidden </td></tr><tr><td> GRUB_TIMEOUT=10 </td></tr><tr><td> GRUB_RECORDFAIL_TIMEOUT=10 </td></tr></table><p>Die beiden Werte <code class="notranslate">GRUB_HIDDEN_TIMEOUT=</code> und <code class="notranslate">GRUB_HIDDEN_TIMEOUT_QUIET=</code> müssen auskommentiert bzw. gelöscht werden. Siehe auch die Ausführungen unter <a class="internal" href="../grub_2/konfiguration.html#Die-Datei-etc-default-grub">GRUB 2/Konfiguration</a> zur Datei <strong>/etc/default/grub</strong>.</p></div><div class="section_3"><h4 id="Fallback-Skript">Fallback-Skript<a class="headerlink" href="#Fallback-Skript">¶</a></h4><p>
Man kopiert das nachfolgende Skript und benennt es <strong>01_fallback</strong>, wobei es <span class="underline">nur</span> darauf ankommt, dass dieses Skript unmittelbar nach dem Skript <strong>/etc/grub.d/00_header</strong> ausgeführt wird (siehe auch <a class="internal" href="../grub_2/konfiguration.html#Die-Abarbeitungs-Reihenfolge-der-Skripte">Abarbeitungs-Reihenfolge</a>).</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="ch">#! /bin/sh -e</span>

<span class="k">if</span> <span class="o">[</span> ! <span class="s2">"x</span><span class="si">${</span><span class="nv">GRUB_DEFAULT</span><span class="si">}</span><span class="s2">"</span> <span class="o">=</span> <span class="s2">"xsaved"</span>  <span class="o">]</span> <span class="p">;</span> <span class="k">then</span>
  <span class="k">if</span> <span class="o">[</span> <span class="s2">"x</span><span class="si">${</span><span class="nv">GRUB_FALLBACK</span><span class="si">}</span><span class="s2">"</span> <span class="o">=</span> <span class="s2">"x"</span> <span class="o">]</span> <span class="p">;</span> <span class="k">then</span> 
     <span class="nb">export</span> <span class="nv">GRUB_FALLBACK</span><span class="o">=</span><span class="s2">""</span>
     <span class="nv">GRUB_FALLBACK</span><span class="o">=</span><span class="k">$(</span> ls /boot <span class="p">|</span> grep -c <span class="s1">'initrd.img'</span> <span class="k">)</span>
     <span class="o">[</span> <span class="si">${</span><span class="nv">GRUB_DISABLE_LINUX_RECOVERY</span><span class="si">}</span> <span class="o">]</span> <span class="o">||</span> <span class="nv">GRUB_FALLBACK</span><span class="o">=</span><span class="k">$((</span> <span class="si">${</span><span class="nv">GRUB_FALLBACK</span><span class="si">}</span> <span class="o">*</span> <span class="m">2</span> <span class="k">))</span>
  <span class="k">fi</span>
  <span class="nb">echo</span> <span class="s2">"fallback modus set to menuentry=</span><span class="si">${</span><span class="nv">GRUB_FALLBACK</span><span class="si">}</span><span class="s2">"</span>  &gt;<span class="p">&amp;</span><span class="m">2</span>

  cat <span class="s">&lt;&lt; EOF</span>
<span class="s">  set fallback="${GRUB_FALLBACK}"</span>
<span class="s">EOF</span>

<span class="k">fi</span>
</pre></div>
</td></tr></table></div><p>Wurde die Vorgaben zu <code class="notranslate">GRUB_DEFAULT</code> einerseits und der adequate Eintrag im Skript zu <code class="notranslate">GRUB_FALLBACK</code> den eigenen Erfordernissen entsprechend in die <strong>/etc/default/grub</strong> eingetragen, so sind diese Werte statisch und müssen ggf. nach einem Kernelupdate manuell korrigiert werden.</p><p>Wird z.B. nach den mit <strong>/etc/grub.d/10_linux</strong> erzeugten Kerneleinträgen ein Reserve-System durch ein geeignetes Skript eingetragen, so berücksichtig das obige Skript automatisch die Position dieses Menüeintrages auch über ein Kernelupdate hinaus mit folgenden</p><p>
</p><table style="width: 40%"><tr class="kopf"><td> Einstellungen in der <strong>/etc/default/grub</strong> </td></tr><tr><td> GRUB_DEFAULT="0" </td></tr><tr><td> export GRUB_FALLBACK="" </td></tr></table><p>bzw. man verzichtet auf einen Eintrag der Variablen <code class="notranslate">GRUB_FALLBACK</code> an dieser Stelle.</p><div class="box notice"><h3 class="box notice">Hinweis:</h3><div class="contents"><p>Dieser "Fallback-Modus" ist <span class="underline">nur</span> wirksam, wenn Grub ohne manuellen Eingriff hochläuft. Wurde hingegen ein "fehlerhafter" Menü-Eintrag von Hand mittels der Pfeiltasten 
<span class="key">↑</span>  + 
<span class="key">↓</span>  und Betätigung von 
<span class="key">⏎</span>  aufgerufen, so erscheint die relevante Fehlermeldung. Dieses ist vom Konzept her so vorgesehen, um eine Fehlersuche aus dem Grub-Menü heraus zu ermöglichen.
</p></div></div></div></div><div class="section_2"><h3 id="Fehler-im-Betriebssystem-abfangen">Fehler im Betriebssystem abfangen<a class="headerlink" href="#Fehler-im-Betriebssystem-abfangen">¶</a></h3><p>
Fehler im Betriebssystem erkennt GRUB 2 mit der oben beschriebenen <a class="crosslink" href="#Fehler-in-Grub-abfangen">Methode</a> nicht, nachdem das Laden der Kerneldateien erfolgreich war.</p><p>Will man auftretende Fehler nach diesem Zeitpunkt abfangen, so muss man einen Neustart auf ein Reservesystem umleiten, welches in einer anderen Partition auf demselben Rechner oder einem externem Datenträger liegt.</p><p>Angenommen wird das Haupt-System liegt z.B.: auf der ersten Menüposition ("0"), das Reserve-System dagegen auf der zweiten Menüposition ("1").</p><div class="section_3"><h4 id="Vorbereitung-OS-Fehler">Vorbereitung OS-Fehler<a class="headerlink" href="#Vorbereitung-OS-Fehler">¶</a></h4><p>
</p><p>
</p><table style="width: 40%"><tr class="kopf"><td> Einstellungen in der <strong>/etc/default/grub</strong> </td></tr><tr><td> GRUB_DEFAULT="saved" </td></tr><tr><td> GRUB_TIMEOUT_STYLE=hidden </td></tr><tr><td> GRUB_RECORDFAIL_TIMEOUT=10  </td></tr><tr><td> GRUB_TIMEOUT=10 </td></tr></table><p>
Die beiden Werte <code class="notranslate">GRUB_HIDDEN_TIMEOUT=</code> und <code class="notranslate">GRUB_HIDDEN_TIMEOUT_QUIET=</code> müssen auskommentiert bzw. gelöscht werden.</p></div><div class="section_3"><h4 id="Umleitungs-Skript">Umleitungs-Skript<a class="headerlink" href="#Umleitungs-Skript">¶</a></h4><p>
</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span><span class="ch">#! /bin/sh -e</span>
<span class="nb">echo</span> <span class="s2">"Menü zum Umleiten und Rückstellen eingefügt"</span>  &gt;<span class="p">&amp;</span><span class="m">2</span>
cat <span class="s">&lt;&lt; EOF</span>
<span class="s">menuentry "Hauptsystem Headless Server (0)" {</span>
<span class="s">	set saved_entry="1"</span>
<span class="s">	save_env saved_entry</span>
<span class="s">	insmod ext2</span>
<span class="s">	insmod raid</span>
<span class="s">	set root='(hd0,2)'</span>
<span class="s">	search --no-floppy --label --set=root ROOT_MAIN</span>
<span class="s">	linux	/vmlinuz root=UUID=ae875d31-cc84-4349-95d7-01a82ad76d61 ro </span>
<span class="s">	initrd	/initrd.img</span>
<span class="s">}</span>
<span class="s">menuentry "Reservesystem Headless Server (1)" {</span>
<span class="s">	set saved_entry="0"</span>
<span class="s">	save_env saved_entry</span>
<span class="s">	insmod ext2</span>
<span class="s">	insmod raid</span>
<span class="s">	set root='(hd0,3)'</span>
<span class="s">	search --no-floppy --label --set=root ROOT_SAVE</span>
<span class="s">	linux	/vmlinuz root=UUID=43c4345B-0c0a-4df6-8abe-8114b06393b2 ro </span>
<span class="s">	initrd	/initrd.img</span>
<span class="s">}</span>
<span class="s">EOF</span>
</pre></div>
</td></tr></table></div></div><div class="section_3"><h4 id="Rueckstellungs-Skript">Rückstellungs-Skript<a class="headerlink" href="#Rueckstellungs-Skript">¶</a></h4><p>
Nun würde nach einem (fehlerfreien) Booten und anschließendem Reboot bzw. Aus-/Einschalten anstelle des Haupt-Systemes das Reserve-System starten. Dieses muss noch wieder zurück gestellt werden.</p><p>Das kann man wie im folgenden Beispiel über das Skript <strong>/etc/rc.local</strong> realisieren, jedoch sollte man auch die bessere Lösung über ein Skript im Verzeichnis <strong>/etc/init.d</strong> in Betracht ziehen, weil dann das Timing über die Dienste (runlevel) gezielter vorzunehmen ist. Noch besser allerdings ab LUCID LYNX (10.04 LTS) ist eine Integration in <strong>/etc/init</strong>, weil dann die Voraussetzungen für ein Rückstellen an konkrete Bedingungen und nicht nur an eine zeitliche Anbindung möglich ist.</p><p>In der <strong>/etc/rc.local</strong> trägt man vor exit 0 nun ein:
</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span>    grub-set-default <span class="m">0</span> &gt; /dev/null<span class="p">;</span>
</pre></div>
</td></tr></table></div><p>
Siehe auch die Hinweise unter <a class="internal" href="../grub_2/terminalbefehle.html#grub-set-default">GRUB 2/Terminalbefehle</a></p><div class="box notice"><h3 class="box notice">Hinweis:</h3><div class="contents"><p>Im Prinzip ist auch eine Kombination aus beiden oben beschriebenen Methoden möglich. Nach einer Anpassung der Skripte an die eigenen Gegebenheiten und Erfordernisse sollte durch eine ausführliche Testphase der fehlerfreie Ablauf sicher gestellt werden.
</p></div></div></div></div></div><div class="section_1"><h2 id="Ausfuehrbarkeit-der-Skripte">Ausführbarkeit der Skripte<a class="headerlink" href="#Ausfuehrbarkeit-der-Skripte">¶</a></h2><p>
Ein Skript kann von der <strong>update-grub</strong>- bzw. <strong>grub-mkconfig</strong>-Prozedur nur berücksichtigt werden, wenn es ausführbar ist. Dies erledigt man mit dem folgenden Kommando im Terminal:
</p><div class="bash"><div class="contents"><pre class="notranslate">sudo chmod +x /etc/grub.d/XX_EigenesSkript </pre></div></div><p>
Hingegen kann man im Terminal <sup><a href="#source-1">[1]</a></sup>mit:
</p><div class="bash"><div class="contents"><pre class="notranslate">sudo chmod -x /etc/grub.d/XX_EigenesSkript </pre></div></div><p>
ein Skript von der Erfassung wieder ausschließen.</p><p><strong>XX_EigenesSkript</strong> muss dabei mit dem Namen des eigens erstellten Skripts ersetzt werden.</p></div><div class="section_1"><h2 id="Links">Links<a class="headerlink" href="#Links">¶</a></h2><p>
</p><ul><li><p><a class="internal" href="../grub_2.html">GRUB 2 Übersicht</a> <img alt="{Übersicht}" src="../_/021d71c30babf2ce4dd27339ba3c55995610945b.png"/></p><ul><li><p><a class="internal" href="../grub_2/grundlagen.html">GRUB 2 Grundlagen</a></p></li><li><p><a class="internal" href="../grub_2/installation.html">GRUB 2 Installation</a></p></li><li><p><a class="internal" href="../grub_2/konfiguration.html">GRUB 2 Konfiguration</a></p></li><li><p><a class="internal" href="../grub_2/aussehen.html">GRUB 2 optisch anpassen</a></p></li><li><p><a class="internal" href="../grub_2/problembehebung.html">GRUB 2 Probleme und Lösungen</a></p></li><li><p><a class="internal" href="../grub_2/reparatur.html">GRUB 2 Reparatur</a></p></li><li><p><a class="internal" href="../grub_2/shell.html">GRUB 2 Shell</a></p></li><li><p><a class="internal" href="../grub_2/terminalbefehle.html">GRUB 2 Terminalbefehle</a></p></li><li><p><a class="internal" href="../grub_umgebung_analysieren.html">GRUB 2 Umgebung analysieren</a></p></li></ul></li></ul><p>
</p><ul><li><p><a class="internal" href="../efi_bootmanagement.html">EFI Bootmanagement</a> <img alt="{Übersicht}" src="../_/021d71c30babf2ce4dd27339ba3c55995610945b.png"/> Details zur EFI-Installation und Einsatz von GRUB 2</p></li></ul><p></p></div></div>
<p class="meta">
<a href="../grub_2/skripte/a/revision/938601.html">Diese Revision</a> wurde am 1. Mai 2017 12:14 von <a href="https://ubuntuusers.de/user/Heinrich_Schwietering/">Heinrich_Schwietering</a> erstellt.
    
  </p>
</div>
</div>
<div style="clear: both;"></div>
<div class="pathbar breadcrumb">
<div class="breadcrumb">
<ol>
<li><a href="../startseite.html">Wiki</a></li>
<li><a href="../grub_2.html">GRUB 2</a></li>
<li><a href="../grub_2/skripte.html">Skripte</a></li>
</ol>
</div>
</div>
</div>
<div class="footer" style="clear: both;">
<ul>
<li class="poweredby"><li class="poweredby">Erstellt mit <a href="http://inyokaproject.org/">Inyoka</a></li></li>
<li class="license">

<img alt="Copyleft" src="../_/65dad5b770326dbbe1bd26ee6363e366a76bd8b7.png"/>
          2004 – 2017 ubuntuusers.de • Einige Rechte vorbehalten<br/>
<a href="../_lizenz.html" rel="cc:morePermissions">Lizenz</a> •
          <a href="http://ubuntuusers.de/kontakt/">Kontakt</a> •
          <a href="http://ubuntuusers.de/datenschutz/">Datenschutz</a> •
          <a href="http://ubuntuusers.de/impressum/">Impressum</a> •
          <a href="https://ubuntuusers.statuspage.io">Serverstatus</a>
</li>
<li class="housing">
<span title="Unterbringung und Netzanbindung eines Servers">Serverhousing</span> gespendet von<br/>
<img alt="noris network" src="../_/e7d27e9081eec23a8a5a5fe9434d7b2f1532e1d9.png"/>
<img alt="anexia" src="../_/ad1b63a3fc35749344af0a03e8c3ce05a2a3ee7e.png"/>
</li>
</ul>
</div>
<div style="clear: both;"></div>
</div>






</body>
</html>