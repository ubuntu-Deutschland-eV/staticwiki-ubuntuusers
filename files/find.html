<!DOCTYPE html>
<html lang="">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>find › ubuntuusers statisches Wiki</title>
<link href="./_/34e5d78db234405457773cc26741aada99f7fff2.css" rel="stylesheet" type="text/css"/>
<link href="./_/61af784fc5c93e296fec3be63b8e0bb48443727c.css" rel="stylesheet" type="text/css"/>
<link href="./_/634e8d1015b02df998cdec7cb07c5aff61d068b5.css" rel="stylesheet" type="text/css"/>
<link href="./_/b583ff7e37147497a59224ccf54cfee812a1d21b.css" rel="stylesheet" type="text/css"/>
<link href="./_/a0d5775ed6f36f8cc5b12bcf2f1c1bd98a3eb225.css" rel="stylesheet" type="text/css"/>
<link href="./_/98de73bded109a634cbd1e924abdd8c8964b8df2.css" media="print" rel="stylesheet" type="text/css"/>

<meta content="#a87300" name="theme-color"/>

</head>
<body>
<div class="wrap">
<div class="header">
<h1><a href="http://ubuntuusers.de/"><span>ubuntuusers.de</span></a></h1>
<ul class="tabbar">
<li class="portal">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://ubuntuusers.de/">Portal<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="forum">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://forum.ubuntuusers.de/">Forum<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="wiki active">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://wiki.ubuntuusers.de/">Wiki<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="ikhaya">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://ikhaya.ubuntuusers.de/">Ikhaya<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="planet">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://planet.ubuntuusers.de/">Planet<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="community">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://wiki.ubuntuusers.de/Mitmachen">Mitmachen<span></span></a></div>
<div class="tab_right"></div>
</li>
</ul>
</div>
<div class="body">
<div class="appheader">

<div class="pagetitle">
<h1 class="breadcrumb_title">
<a class="separator" href="./startseite.html">
              Wiki
            </a>
</h1>
<h2 class="breadcrumb_subtitle"><a href="./find.html">find</a></h2>
</div>
</div><div class="message staticwikinote"><strong>Hinweis:</strong> Dies ist ein statischer Snapshot unseres Wikis vom Jan. 17, 2018 und kann daher nicht bearbeitet werden. Der aktuelle Artikel ist unter <a href="http://wiki.ubuntuusers.de/find">wiki.ubuntuusers.de</a> zu finden.</div>

<!--[if lt IE 8]>
      <div class="message fail">Bitte installiere den Internet Explorer 8 oder neuer.</div>
      <![endif]-->
<div class="page_content">
<div class="navi_sidebar navigation">
<div class="container">
<h3 class="navi_wiki">Wiki</h3>
<ul>
<li><a href="./wiki/index.html">Index</a></li>
<li><a href="./wiki/recentchanges.html">Letzte Änderungen</a></li>
<li><a href="./wiki/neue_artikel.html">Liste neuer Artikel</a></li>
<li><a href="./wiki.html">Übersicht</a></li>
<li><a href="./wiki/faq_-_häufig_gestellte_fragen.html">FAQ</a></li>
<li><a href="./wiki/benutzung.html">Benutzung</a></li>
<li><a href="./kategorien.html">Kategorie</a></li>
<li><a href="./wiki/tagcloud.html">Wortwolke</a></li>
</ul>
<h3 class="navi_join">Mitmachen</h3>
<ul>
<li><a href="./wikiartikel_anlegen.html">Wikiartikel anlegen</a></li>
<li><a href="./howto.html">Howto anlegen</a></li>
<li><a href="./wiki/referenz.html">Wiki-Referenz</a></li>
<li><a href="./wiki/syntax.html">Wiki-Syntax</a></li>
<li><a href="./baustelle.html">Baustellen</a></li>
<li><a href="./wiki/artikelideen.html">Artikelideen</a></li>
<li><a href="./wiki/ungetestet.html">Ungetestete Artikel</a></li>
<li><a href="./wiki/vorlagen/ausbaufähig/a/backlinks.html">Ausbaufähige Artikel</a></li>
<li><a href="./wiki/vorlagen/fehlerhaft/a/backlinks.html">Fehlerhafte Artikel</a></li>
<li><a href="https://forum.ubuntuusers.de/forum/wiki/">Rund ums Wiki</a></li>
</ul>
<h3 class="navi_config">Konfiguration</h3>
<ul>
<li><a href="./find/a/backlinks.html">Backlinks anzeigen</a></li>
<li>
        Exportieren
        <ul>
<li><a href="./find/a/export/meta.html" rel="nofollow">Metadaten</a></li>
<li><a href="./find/a/export/raw.html" rel="nofollow">Rohformat</a></li>
<li><a href="./find/a/export/html.html" rel="nofollow">HTML</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div class="content content_tabbar content_sidebar">
<h1 class="pagetitle"><a href="./find/a/backlinks.html">find</a></h1>
<div id="page"><p>
</p><div class="box tested_for"><h3 class="box tested_for">Dieser Artikel wurde für die folgenden
Ubuntu-Versionen getestet:</h3><div class="contents"><p> 
Dieser Artikel ist größtenteils für alle Ubuntu-Versionen gültig.
</p></div></div><p>
</p><div class="box knowledge"><h3 class="box knowledge">Zum Verständnis dieses Artikels sind folgende Seiten hilfreich:</h3><div class="contents"><p>
</p><ol class="arabic"><li><p><a class="crosslink anchor" href="#source-1" id="source-1"></a> <a class="internal" href="./terminal.html">Ein Terminal öffnen</a></p></li></ol></div></div><p>
</p><div class="toc toc-depth-1"><div class="head">Inhaltsverzeichnis</div><ol class="arabic"><li><a class="crosslink" href="#Installation">Installation
</a></li><li><a class="crosslink" href="#bersichten">Übersichten
</a></li><li><a class="crosslink" href="#Beispiele">Beispiele
</a></li><li><a class="crosslink" href="#Weitere-Informationen">Weitere Informationen
</a></li><li><a class="crosslink" href="#Links">Links
</a></li></ol></div><p><img alt="Wiki/Icons/terminal.png" class="image-left" src="./_/e81889fd6e485dd32e1cde611eabc18abced7993.png"/>
Das Kommandozeilenprogramm <strong>find</strong> dient der Dateisuche in ganzen Verzeichniszweigen ab definierten <a class="crosslink" href="#Startpunkt-e">Startpunkten</a>. Dabei kann es die Suche auf vielfältige Weise filtern, z.B. nach Dateiname, -alter, -größe und die Suchergebnisse weiterverarbeiten und/oder formatiert ausgeben.</p><p>Da unter unixoiden Systemen der Leitsatz <em>"Alles ist eine Datei"</em> gilt, werden auch Verzeichnisse und anderes, was Linux im Dateiverzeichnisbaum einträgt (z.B. Sockets), gefunden. Der Einfachheit halber werden deshalb in diesem Artikel meist nur Dateien genannt. Eine Alternative zu find (mit Vor- und Nachteilen) bietet der Befehl <a class="internal" href="./locate.html">locate</a>.</p><div class="section_1"><h2 id="Installation">Installation<a class="headerlink" href="#Installation">¶</a></h2><p>
Das Programm ist im Paket</p><ul><li><p><strong>findutils</strong></p></li></ul><p>
von Ubuntu enthalten und ist deshalb auf jedem System vorinstalliert.</p></div><div class="section_1"><h2 id="bersichten">Übersichten<a class="headerlink" href="#bersichten">¶</a></h2><p>
Bevor einige praktische Beispiele die vielfältigen Verwendungsmöglichkeiten von find zeigen, zwei kurze Übersichten ...</p><p>
</p><table><tr class="titel"><td colspan="2">Einige, wenn auch nicht alle Suchkriterien für find </td></tr><tr class="kopf"><td style="width: 200px">Kriterium </td><td> Beschreibung </td></tr><tr><td> <code class="notranslate">-name DATEI</code> </td><td> sucht nach dem Namen <code class="notranslate">DATEI</code>. Werden <a class="interwiki interwiki-wikipedia" href="https://de.wikipedia.org/wiki/Wildcard_(Informatik)">Platzhalter</a> verwendet, müssen sie maskiert werden, sonst interpretiert sie schon die Shell. Beispiele: <code class="notranslate">\*.txt</code> oder <code class="notranslate">"???.t*xt"</code> </td></tr><tr><td> <code class="notranslate">-iname DATEI</code> </td><td> sucht nach dem Namen <code class="notranslate">DATEI</code>, ohne Beachtung der Groß- und Kleinschreibung. </td></tr><tr><td> <code class="notranslate">-type T</code> </td><td> sucht nach nur einem Typ, z.B. mit <code class="notranslate">f</code> (=file) echte Dateien oder mit <code class="notranslate">d</code> (=directory) Verzeichnisse. </td></tr><tr><td> <code class="notranslate">-mtime n</code> </td><td> sucht nach Dateien, deren Inhalt vor n bis n+1 Tagen geändert (m=modified) wurde. </td></tr><tr><td> <code class="notranslate">-mtime +n</code> </td><td> sucht nach Dateien, deren Inhalt älter als n+1 Tage ist. </td></tr><tr><td> <code class="notranslate">-mtime -n</code> </td><td> sucht nach Dateien, deren Inhalt jünger als n Tage ist. </td></tr><tr><td> <code class="notranslate">-ctime n</code> </td><td> sucht nach Dateien, deren Name oder Status (Modus, Besitzer oder Gruppe) vor n bis n+1 Tagen geändert (c=changed) wurde. </td></tr><tr><td> <code class="notranslate">-atime n</code> </td><td> sucht nach Dateien, auf die zuletzt vor n bis n+1 Tagen zugegriffen (a=accessed) wurde. (Hinweis: Die Aussagekraft der Datei-Zugriffszeit ist stark von den <a class="internal" href="./mount.html#Optionen">Einhängeoptionen</a> <code class="notranslate">atime</code>, <code class="notranslate">noatime</code> und <code class="notranslate">relatime</code> abhängig.) </td></tr><tr><td> <code class="notranslate">-mmin n</code> </td><td> sucht nach Dateien, deren Inhalt vor n-1 bis n Minuten geändert wurde. (Achtung: andere Zählweise als bei <code class="notranslate">-Xtime</code>) </td></tr><tr><td> <code class="notranslate">-mmin +n</code> </td><td> sucht nach Dateien, deren Inhalt älter als n Minuten ist. (Achtung: andere Zählweise als bei <code class="notranslate">-Xtime</code>) </td></tr><tr><td> <code class="notranslate">-mmin -n</code> </td><td> sucht nach Dateien, deren Inhalt jünger als n Minuten ist. (gleiche Zählweise als bei <code class="notranslate">-Xtime</code>) </td></tr><tr><td> <code class="notranslate">-daystart</code> </td><td> misst für alle darauf folgenden <code class="notranslate">-Xtime</code>- und <code class="notranslate">-Xmin</code>-Kriterien ab 0:00 h des nächsten Tages, also ab Mitternacht. </td></tr><tr><td> <code class="notranslate">-newer DATEI</code> </td><td> sucht nach Dateien, deren Inhalt nach dem von <code class="notranslate">DATEI</code> verändert wurde. </td></tr><tr><td> <code class="notranslate">-size n[cwbkMG]</code> </td><td> sucht Dateien die n Zuordnungseinheiten belegen. Folgende Multiplikatoren können zusätzlich verwendet werden: <code class="notranslate">c</code> für Bytes, <code class="notranslate">w</code> für Zwei-Byte-Wörter, <code class="notranslate">b</code> für 512-Byte-Blöcke (Standard), <code class="notranslate">k</code> für KiB (Kibibyte), <code class="notranslate">M</code> für MiB, <code class="notranslate">G</code> für GiB. </td></tr><tr><td> <code class="notranslate">-user BENUTZER</code> </td><td> sucht nur nach Dateien des Benutzers <code class="notranslate">BENUTZER</code>. </td></tr><tr><td> <code class="notranslate">-nouser</code> </td><td> sucht nach Dateien, deren User-ID keinem Benutzer entspricht. </td></tr><tr><td> <code class="notranslate">-nogroup</code> </td><td> sucht nach Dateien, deren Gruppen-ID keiner Gruppe entspricht. </td></tr><tr><td> <code class="notranslate">-maxdepth n</code> </td><td> sucht ab dem <a class="crosslink" href="#Startpunkt-e">Startpunkt</a> nur n Verzeichnisse tief. Bezeichnet dieser ein Verzeichnis – z.B. implizit das aktuelle Verzeichnis – zählen dessen Einträge schon zu Tiefe 1. </td></tr><tr><td> <code class="notranslate">-depth</code> </td><td> sucht erst rekursiv im Inhalt der Verzeichnisse, bevor das Verzeichnis selbst untersucht wird. (Standard bei <code class="notranslate">-delete</code> Aktion) </td></tr></table><p>
</p><table><tr class="titel"><td colspan="2">Geläufige Aktionen für <code class="notranslate">find</code> </td></tr><tr class="kopf"><td style="width: 200px">Aktion </td><td> Beschreibung </td></tr><tr><td> <code class="notranslate">-fprint DATEI</code> </td><td> gibt die gefunden Dateinamen nicht auf die Standardausgabe (Bildschirm) aus, sondern schreibt diese in die Datei <code class="notranslate">DATEI</code>. </td></tr><tr><td> <code class="notranslate">-exec KOMMANDO {} \;</code> </td><td> wendet auf alle Funde den Shellbefehl <code class="notranslate">KOMMANDO</code> an. <code class="notranslate">{}</code> steht dabei als Platzhalter für die gefundenen Dateinamen. Das Zeichen <code class="notranslate">;</code> terminiert den von find aufzurufenden Shellbefehl. Damit es nicht unbeabsichtigt von der Shell interpretiert wird, muss es mit <code class="notranslate">\ </code> oder zwei umschließenden <code class="notranslate">"</code> maskiert werden. </td></tr><tr><td> <code class="notranslate">-execdir KOMMANDO {} +</code> </td><td> wendet auf die Funde den Shellbefehl <code class="notranslate">KOMMANDO</code> an. Im Gegensatz zu <code class="notranslate">-exec</code> wird das Kommando im Verzeichnis, in dem die Datei liegt, ausgeführt. Das <code class="notranslate">+</code> bewirkt, dass viele Funde (bzw. hier viele eines gleichen Verzeichnisses) auf einmal an <code class="notranslate">KOMMANDO</code> übergeben werden, was die Ausführung stark beschleunigen kann. Das <code class="notranslate">+</code> kann statt dem <code class="notranslate">;</code> (ebenso wie bei <code class="notranslate">-exec</code>) nur verwendet werden, wenn <code class="notranslate">{}</code> der letzte Parameter von <code class="notranslate">KOMMANDO</code> ist. </td></tr><tr><td> <code class="notranslate">-ok KOMMANDO {} \;</code> </td><td> Wie <code class="notranslate">-exec</code>, allerdings wird vor jeder Aktion eine Bestätigung erfragt. <code class="notranslate">{}</code> steht dabei als Platzhalter für die Funde. </td></tr><tr><td> <code class="notranslate">-okdir KOMMANDO {} +</code> </td><td> Wie eine Kombination von <code class="notranslate">-ok</code> und <code class="notranslate">-execdir</code>, d.h. es wird eine Bestätigung erfragt, und das Kommando wird im Fundordner ausgeführt. </td></tr><tr><td> <code class="notranslate">-print</code> </td><td> erzwingt die Ausgabe der gefunden Dateinamen, auch wenn diese als Parameter für eine andere Aktion zunächst verschluckt wurden. Mit <code class="notranslate">-printf FORMAT</code> kann die Ausgabe auch vielfältig gestaltet werden. </td></tr><tr><td> <code class="notranslate">-delete</code> </td><td> löscht die gefundenen Dateien und leeren Verzeichnisse. </td></tr></table></div><div class="section_1"><h2 id="Beispiele">Beispiele<a class="headerlink" href="#Beispiele">¶</a></h2><p>
Es gibt eine Unzahl weiterer Beispiele, z.B. die Suche nach Eigentümer, Berechtigungen, Dateisystem u.v.m. Solche und eine komplette Übersicht – auch über die in diesem Artikel nicht beschriebenen Optionen – bieten die <a class="internal" href="./info.html">Infoseiten</a> und das <a class="internal" href="./man.html">Manual</a> zu <a class="interwiki interwiki-man_de" href="http://manpages.ubuntu.com/cgi-bin/search.py?lr=lang_de&amp;q=find">find</a>, sowie die sehr ausführliche Seite <a class="external" href="http://www.gnu.org/software/findutils/manual/html_mono/find.html" rel="nofollow">findutils auf gnu.org</a> <img alt="{en}" src="./_/d5ecf89114b079f85d02099649c4ee617ffa34c7.png"/>.</p><div class="section_2"><h3 id="Startpunkt-e">Startpunkt(e)<a class="headerlink" href="#Startpunkt-e">¶</a></h3><p>
Dort beginnt <code class="notranslate">find</code> mit der Suche – im aktuellen Verzeichnis, wenn keine extra angegeben sind. Startpunkt(e) müssen <span class="underline">nach</span> eventuellen Optionen (in diesem Artikel nicht beschrieben) und <span class="underline">vor</span> den ebenfalls optionalen Suchkriterien und Aktionen platziert werden. In den meisten Fällen wird es sich dabei um Verzeichnisse handeln, andere Einträge sind aber auch erlaubt. Wenn nicht die ganzen gegebenenfalls dort darunter liegenden Verzeichniszweige durchsucht werden sollen, kann die Durchsuchungstiefe mit <a class="crosslink" href="#Sonstige-Suchkriterien">zusätzlichen Suchkriterien</a> begrenzt werden.
</p><ul><li><div class="bash"><div class="contents"><pre class="notranslate">find </pre></div></div><p> sucht im aktuellen Verzeichnis, findet also auch <strong>.</strong> .</p></li><li><div class="bash"><div class="contents"><pre class="notranslate">find foo </pre></div></div><p> sucht in <strong>foo</strong> im aktuellen Verzeichnisses.</p></li><li><div class="bash"><div class="contents"><pre class="notranslate">find ../ </pre></div></div><p> sucht im übergeordneten Verzeichnis.</p></li><li><div class="bash"><div class="contents"><pre class="notranslate">find /tmp </pre></div></div><p> sucht im absolut angegebenen Verzeichnis <strong>/tmp</strong>).</p></li><li><div class="bash"><div class="contents"><pre class="notranslate">find /tmp /boot </pre></div></div><p> sucht in zwei Verzeichnissen (sowohl in <strong>/tmp</strong> als auch in <strong>/boot</strong>).</p></li><li><div class="bash"><div class="contents"><pre class="notranslate">find Film* </pre></div></div><p> sucht im aktuellen Verzeichnis Einträge die mit <code class="notranslate">Film</code> beginnen, also u.a. Dateien und alles in mit <code class="notranslate">Film</code> beginnenden Pfaden (<code class="notranslate">*</code> wird hier schon von der Shell erweitert).</p></li><li><div class="bash"><div class="contents"><pre class="notranslate">find / </pre></div></div><p> sucht überall (ab dem Wurzelverzeichnis - das kann dauern!).</p></li></ul><p>
</p></div><div class="section_2"><h3 id="Name">Name<a class="headerlink" href="#Name">¶</a></h3><p>
</p><ul><li><div class="bash"><div class="contents"><pre class="notranslate">find -name hausarbeit.odt </pre></div></div><p> sucht nach Dateien mit dem vollständigen Namen <strong>hausarbeit.odt</strong>.</p></li></ul><p>
</p><ul><li><div class="bash"><div class="contents"><pre class="notranslate">find -name "*.pdf" </pre></div></div><p> sucht nach PDF-Dateien. <code class="notranslate">-name</code> (berücksichtigt die Groß-/Kleinschreibung, findet hier also keine Datei(en) mit Endung <strong>*.PDF</strong>).</p></li></ul><p>
</p><ul><li><div class="bash"><div class="contents"><pre class="notranslate">find -iname a\*.pdf </pre></div></div><p> sucht nach <strong>.pdf</strong>- und <strong>.PDF</strong>-Dateien, die mit <code class="notranslate">a</code> oder <code class="notranslate">A</code> beginnen (ignoriert die Groß-/Kleinschreibung).</p></li></ul><p>
</p><ul><li><div class="bash"><div class="contents"><pre class="notranslate">find -name "katze.*" </pre></div></div><p> findet <strong>katze.jpg</strong>, <strong>katze.png</strong>, <strong>katze.txt</strong> usw. </p></li></ul><p>
</p><ul><li><div class="bash"><div class="contents"><pre class="notranslate">find -name "katze.??g" </pre></div></div><p> findet <strong>katze.jpg</strong>, <strong>katze.png</strong> usw. (jedes Fragezeichen steht für ein einzelnes Zeichen).</p></li></ul><p>
</p><ul><li><div class="bash"><div class="contents"><pre class="notranslate">find -name "*foo*.*x*" </pre></div></div><p> findet <strong>foo.x</strong>, <strong>afoo.x</strong>, <strong>foob.txt</strong> usw. </p></li></ul><p>
</p></div><div class="section_2"><h3 id="Pfad-teile">Pfad(teile)<a class="headerlink" href="#Pfad-teile">¶</a></h3><p>
Will man die Suche auf bestimmte Pfade einschränken, kommt man mit <code class="notranslate">-name</code> nicht weiter. Das Suchkriterium <code class="notranslate">-path</code> ist hier die Lösung, denn es erlaubt die Verwendung des Namenstrenners <code class="notranslate">/</code>.
</p><ul><li><div class="bash"><div class="contents"><pre class="notranslate">find -path "*2013/J*" </pre></div></div><p> findet <strong>~/Bilder/2013/Juni</strong> und <strong>~/Musik/2013/Juli</strong>, aber nicht <strong>~/Dokumente/2013-Juni</strong>.</p></li></ul><p>
</p><ul><li><p>Pfade ausschließen </p><div class="bash"><div class="contents"><pre class="notranslate">find ~ -path ~/Dokumente -prune -or -path ~/Downloads -prune -or -iname "*.pdf" -print </pre></div></div><p> findet alle PDF-Dateien im Homeverzeichnis außer die in <strong>~/Dokumente/</strong> und <strong>~/Downloads/</strong>. Das explizite <code class="notranslate">-print</code> ist nötig, da <code class="notranslate">-prune</code> nicht nur die Suche im jeweiligen Pfad sondern auch die Ausgabe zunächst abbricht.</p></li></ul><p>
</p></div><div class="section_2"><h3 id="Typ">Typ<a class="headerlink" href="#Typ">¶</a></h3><p>
</p><ul><li><div class="bash"><div class="contents"><pre class="notranslate">find -type f </pre></div></div><p> findet nur reguläre Dateien. Verzeichnisse, Sockets, etc. werden ausgelassen.</p></li></ul><p>
</p><ul><li><div class="bash"><div class="contents"><pre class="notranslate">find -type d </pre></div></div><p> findet nur Verzeichnisse (Typ: directory).</p></li></ul><p>
</p></div><div class="section_2"><h3 id="Groesse">Größe<a class="headerlink" href="#Groesse">¶</a></h3><p>
</p><ul><li><p>Maximale Größe </p><div class="bash"><div class="contents"><pre class="notranslate">find -size -100c -ls </pre></div></div><p> sucht nach Dateien, die kleiner als 100 Bytes sind, wofür das <code class="notranslate">-</code> vor der Zahl <code class="notranslate">100</code> steht. Das <code class="notranslate">c</code> dahinter bedeutet <code class="notranslate">character</code>, welche früher 1 Byte belegten (<code class="notranslate">b</code> ist schon für die Maßeinheit Block (= 512 Bytes) vergeben). Mittels dem zusätzlichen <code class="notranslate">-ls</code> läßt sich die Größe der gefundenen Dateien überprüfen. Deswegen wird es hier, vor den anderen <a class="crosslink" href="#Aktionen">Aktionen</a>, erwähnt.</p></li></ul><p>
</p><ul><li><p>Exakte Größe </p><div class="bash"><div class="contents"><pre class="notranslate">find -size 100c </pre></div></div><p> sucht nach Dateien, die genau 100 Bytes groß sind (kein Vorzeichen). </p></li></ul><p>
</p><ul><li><p>Mindestgröße </p><div class="bash"><div class="contents"><pre class="notranslate">find -size +100M </pre></div></div><p> sucht nach Dateien, die größer als 100 Mebibytes sind (Vorzeichen <code class="notranslate">+</code>). Statt <code class="notranslate">M</code> kann man auch <code class="notranslate">k</code> für Kibibytes oder <code class="notranslate">G</code> für Gibibytes angeben.</p></li></ul><p>
</p><ul><li><p>Große Einheiten </p><div class="bash"><div class="contents"><pre class="notranslate">find -size 4k </pre></div></div><p> sucht nach Dateien, die zwischen 3073 und 4096 Bytes groß sind. Analog gilt das auch für M und G. Deshalb auch <a class="crosslink" href="#Seltsames-Nichtfinden-bei-Groessen-wie-k-M-G">Vorsicht bei der Verwendung von <code class="notranslate">-</code></a>!</p></li></ul><p>
</p><ul><li><p>Zwischen Mindest- und Maximalgröße </p><div class="bash"><div class="contents"><pre class="notranslate">find -type f -size +64c -size -4096c | wc -l </pre></div></div><p> sucht nach Dateien, die zwischen 65 und 4095 Bytes groß sind, und wird per Pipe an <a class="internal" href="./wc.html">wc</a> übergeben, um die Anzahl der gefundenen Dateien zu bestimmen.</p></li></ul><p>
</p><ul><li><p>Blockbelegung </p><div class="bash"><div class="contents"><pre class="notranslate">find -size 2 </pre></div></div><p> sucht nach Dateien, die 2 Blöcke belegen, also von 513 bis 1024 Bytes Größe. Ohne Multiplikatoren-Angabe wird die Zahl als Anzahl belegter Blöcke à 512 Bytes interpretiert; die Angabe von <code class="notranslate">b</code> ist also optional. Wenn es Probleme mit der Suche nach Größe gibt, dann wahrscheinlich, weil man <code class="notranslate">c</code>, <code class="notranslate">k</code>, <code class="notranslate">M</code> oder <code class="notranslate">G</code> vergessen hast.</p></li></ul><p>
</p></div><div class="section_2"><h3 id="Alter">Alter<a class="headerlink" href="#Alter">¶</a></h3><p>
Auch hier gibt es, ähnlich wie bei der <a class="crosslink" href="#Groesse">Größe</a>, Mindestalter (<code class="notranslate">+</code>), Höchstalter (<code class="notranslate">-</code>), genaues Alter und Zeitbereiche.
</p><ul><li><p>Änderungszeit in Tagen </p><div class="bash"><div class="contents"><pre class="notranslate">find -mtime -100 </pre></div></div><p> sucht nach Dateien, deren Inhalt innerhalb der letzten 100 Tage geändert wurde (<code class="notranslate">mtime</code> = modification time). </p><div class="bash"><div class="contents"><pre class="notranslate">find -mtime +100 </pre></div></div><p> sucht nach Dateien, deren Inhalt vor mehr als 101 Tage geändert wurde. Dateien, die zwischen 100 und 101 Tage alt sind, werden also von keinem der beiden vorangehenden Beispiele gefunden! Weitere Optionen sind </p><ul><li><p><code class="notranslate">-ctime</code> (change time): Zeitpunkt, an dem der Name oder Status (Besitzer, Gruppe, Rechte) der Datei geändert wurde, oder</p></li><li><p><code class="notranslate">-atime</code> (access time): Zeitpunkt, an dem auf die Datei zuletzt zugegriffen wurde. Eine Dateiauflistung selbst ist damit nicht gemeint. Bei Bilddateien z.B. zählt aber die Vorschaufunktion eines grafischen Dateimanagers oder das Auslesen der Bildeigenschaften bereits als Zugriff. Die Zugriffszeit wird erst bei mehr als 24 h Abweichung oder wenn sie älter als die letzte Änderung der Datei ist, also nicht bei jedem Lesen, aktualisiert (wenn das Dateisystem nicht mit vom Standard abweichenden zusätzlichen Optionen eingehangen ist).</p></li></ul></li></ul><p>
</p><ul><li><p>Zugriffszeit in Minuten </p><div class="bash"><div class="contents"><pre class="notranslate">find -amin -5 </pre></div></div><p> sucht nach Dateien, auf die in den letzten 5 Minuten zugegriffen wurde. Analog: <code class="notranslate">-cmin</code>, <code class="notranslate">-mmin</code>. Bei <code class="notranslate">+5</code> werden hier alle Dateien gefunden, auf die vor mehr als 5 Minuten zugegriffen wurde, es entsteht also keine Lücke wie bei <code class="notranslate">-Xtime</code>.</p></li></ul><p>
</p><ul><li><p>Justierung auf Mitternacht </p><div class="bash"><div class="contents"><pre class="notranslate">find -daystart -mtime 0 </pre></div></div><p> sucht nach Dateien, deren Inhalt heute geändert wurde.</p></li></ul><p>
</p><ul><li><p>Im Vergleich zu einer bestimmten Datei </p><div class="bash"><div class="contents"><pre class="notranslate">find -cnewer /tmp/referenz </pre></div></div><p> sucht nach Dateien, deren Name oder Status nach der <span class="underline">Änderungszeit</span> der Referenzdatei geändert wurden. Mit <code class="notranslate">touch --date='2004-02-29 15:00' /tmp/referenz</code> erstellt man sich eine Referenzdatei, wenn man keine hat.</p></li></ul><p>
</p></div><div class="section_2"><h3 id="Sonstige-Suchkriterien">Sonstige Suchkriterien<a class="headerlink" href="#Sonstige-Suchkriterien">¶</a></h3><p>
</p><ul><li><p>Alle Dateien des Benutzers Klaus </p><div class="bash"><div class="contents"><pre class="notranslate">find / -user klaus </pre></div></div></li></ul><p>
</p><ul><li><p>Leere Verzeichnisse und Dateien der Größe 0 </p><div class="bash"><div class="contents"><pre class="notranslate">find -empty </pre></div></div><p> </p></li></ul><p>
</p><ul><li><p>Verzeichnistiefe </p><div class="bash"><div class="contents"><pre class="notranslate">find -maxdepth 3 </pre></div></div><p> steigt bei der Suche nur <code class="notranslate">3</code> Verzeichnisebenen herab. </p><div class="bash"><div class="contents"><pre class="notranslate">find -mindepth 1 </pre></div></div><p> durchsucht die <a class="crosslink" href="#Startpunkt-e">Startverszeichnisse</a>, liefert sie aber nicht als Treffer – hier <strong><code class="notranslate">.</code></strong></p></li></ul><p>
</p></div><div class="section_2"><h3 id="Kombinationen">Kombinationen<a class="headerlink" href="#Kombinationen">¶</a></h3><p>
</p><ul><li><p>Standard: Und-Kombination; die Funde müssen alle Kriterien erfüllen </p><div class="bash"><div class="contents"><pre class="notranslate">find -mindepth 3 -maxdepth 5  </pre></div></div><p> sucht von Verzeichnistiefe 3 bis 5.</p></li></ul><p>
</p><ul><li><p>Weiteres Beispiel der Und-Kombination </p><div class="bash"><div class="contents"><pre class="notranslate">find -mindepth 3 -type f -name "*.avi" -size +5M </pre></div></div><p> beginnt die Suche in Verzeichnistiefe 3 und findet nur reguläre Dateien, die die Endung <code class="notranslate">.avi</code> haben und größer als 5 MiB sind. </p></li></ul><p>
Man kann die Suchoptionen aber auch per oder bzw. nicht verknüpfen:</p><ul><li><p>Negation </p><div class="bash"><div class="contents"><pre class="notranslate">find ! -name "*.avi" -not -name "*.mp*g" </pre></div></div><p> sucht Dateien die weder die Dateiendung <code class="notranslate">avi</code> noch <code class="notranslate">mpg</code> oder <code class="notranslate">mpeg</code> haben. Das Ausrufezeichen und <code class="notranslate">-not</code> sind gleichbedeutend.</p></li></ul><p>
</p><ul><li><p>Oder-Kombination </p><div class="bash"><div class="contents"><pre class="notranslate">find -name "susi.*" -or -name "susanne.*" </pre></div></div><p> sucht Dateien die mit <code class="notranslate">susi.</code> ober <code class="notranslate">susanne.</code> beginnen.</p></li></ul><p>
Bei umfangreichen Kombinationen kann eine Klammerung erforderlich sein, um das gewünschte Resultat zu erhalten:</p><ul><li><p>ohne Klammern </p><div class="bash"><div class="contents"><pre class="notranslate">find -name "susi.*" -or -name "susanne.*" -name "*.txt" </pre></div></div><p> Ohne Klammern wird erst die UND-Verbindung gebildet, also <code class="notranslate">susanne.*</code> und <code class="notranslate">*.txt</code>, danach erst ODER mit <code class="notranslate">susi.*</code>. Auch <strong>susi.png</strong> würde also gefunden. </p></li></ul><p>
</p><ul><li><p>mit Klammern </p><div class="bash"><div class="contents"><pre class="notranslate">find \( -name "susi.*" -or -name "susanne.*" \) -name "*.txt" </pre></div></div><p> Hier wird jetzt für alle Dateien gefordert, dass diese auf <code class="notranslate">.txt</code> enden. Klammern müssen maskiert und mit Leerzeichen isoliert werden. </p></li></ul><p>
</p></div><div class="section_2"><h3 id="Aktionen">Aktionen<a class="headerlink" href="#Aktionen">¶</a></h3><p>
</p><ul><li><p>Ohne weitere Angaben gibt find nur die Namen der gefundenen Dateien mit Pfad aus. </p><div class="bash"><div class="contents"><pre class="notranslate">find /boot/grub/ -name "he*" </pre></div></div><pre class="notranslate">/boot/grub/hexdump.mod
/boot/grub/hello.mod
/boot/grub/help.mod</pre></li></ul><p>
</p><ul><li><p>Wie bereits weiter oben erwähnt kann man mit <code class="notranslate">-ls</code> eine detailliertere Ausgabe erzeugen. </p><div class="bash"><div class="contents"><pre class="notranslate">find /boot/grub/ -name "he*" -ls </pre></div></div><pre class="notranslate">168624    4 -rw-r--r--   1 root     root         3196 Jan 13 17:08 /boot/grub/hexdump.mod
168603    4 -rw-r--r--   1 root     root         1308 Jan 13 17:08 /boot/grub/hello.mod
168623    4 -rw-r--r--   1 root     root         2200 Jan 13 17:08 /boot/grub/help.mod</pre></li></ul><p>
</p><ul><li><p>Eine etwas kritische Angelegenheit ist das Löschen mit der Aktion <code class="notranslate">-delete</code>. </p><div class="box warning"><h3 class="box warning">Achtung!</h3><div class="contents"><p>Da find auch Unterverzeichnisse durchsucht, sollte mit dieser Aktion vorsichtig umgegangen werden. Mit find gelöschte Dateien landen nicht im Papierkorb und können nicht wieder hergestellt werden. Es ist auch sorgfältig darauf zu achten, dass nicht <a class="crosslink" href="#Die-Aktion-delete-steht-an-der-falschen-Stelle"><code class="notranslate">-delete</code> an der falschen Stelle</a> steht.
</p></div></div><p> Der Verwendung sollte ein Test ohne <code class="notranslate">-delete</code> voraus gehen, um sicher zu gehen, nicht zu viele Dateien zu löschen. Die <code class="notranslate">-delete</code>-Aktion impliziert <code class="notranslate">-depth</code>, d.h. man muss zum Testen <code class="notranslate">-depth</code> selbst setzen. Um keine Überraschung zu erleben also erst mal z.B.: </p><div class="bash"><div class="contents"><pre class="notranslate">find STARTVERZEICHNIS -depth -name "c*" </pre></div></div><p> und dann erst: </p><div class="bash"><div class="contents"><pre class="notranslate">find STARTVERZEICHNIS -name "c*" -delete </pre></div></div><p> Löscht im Zweig <code class="notranslate">STARTVERZEICHNIS</code> alle Dateien, die mit <code class="notranslate">c</code> beginnen. Der Befehl löscht auch Verzeichnisse selbst, die mit <code class="notranslate">c</code> beginnen, sofern sie leer sind, wie bei rmdir. Das ist der Grund, weshalb <code class="notranslate">-delete</code> ein <code class="notranslate">-depth</code> impliziert: Wenn erst in den Verzeichnissen gelöscht wird kann ein dadurch leeres auch selbst gelöscht werden, umgekehrt nicht.</p></li></ul><p>
</p><div class="section_3"><h4 id="exec-und-dessen-Varianten"><code class="notranslate">-exec</code> und dessen Varianten<a class="headerlink" href="#exec-und-dessen-Varianten">¶</a></h4><p>
</p><ul><li><p>Die Anzahl der Zeilen in Textdateien findet man mit <code class="notranslate">wc -l DATEI</code>; kombiniert mit find sieht das so aus: </p><div class="bash"><div class="contents"><pre class="notranslate">find -name "*.py" -exec wc -l {} \; </pre></div></div><pre class="notranslate">10 ./abc.py
6 ./x/date-form.py
102 ./x/download.py</pre><p> Das Kommando <code class="notranslate">wc -l</code> (Zeilen zählen) wird auf jede gefundene Datei angewendet. Die geschweiften Klammern werden durch die von <code class="notranslate">find</code> gefundenen Namen ersetzt. Am Ende muss der ganze Befehl mit einem Semikolon abgeschlossen werden. Damit das Semikolon nicht von der Shell interpretiert wird, muss man es mit einem Backslash oder Anführungsstrichen maskieren. </p></li></ul><p>
</p><ul><li><p>Als Parameter für <code class="notranslate">-exec</code> verschluckte Ausgabe von find wieder sichtbar machen </p><div class="bash"><div class="contents"><pre class="notranslate">find tmp -name "a" -exec touch {} \; -print </pre></div></div><pre class="notranslate">./tmp/a
./tmp/a/a
./tmp/a/a/a</pre><p> Weil <a class="internal" href="./touch.html">touch</a> nichts ausgibt und man dann deshalb keine Kontrolle darüber hat, was getan wurde, erhält man diese so über die <code class="notranslate">-print</code>-Ausgabe von find.</p></li></ul><p>
</p><ul><li><p>Oft empfiehlt sich <code class="notranslate">-execdir</code> statt <code class="notranslate">-exec</code> </p><div class="bash"><div class="contents"><pre class="notranslate">find startpunkt -type d -execdir tar -cjf archiv.tar.bz2 {} \; </pre></div></div><p> <code class="notranslate">-execdir</code> führt das Kommando aus dem Verzeichnis heraus aus, in dem die Datei gefunden wird. So wird also für jedes Verzeichnis ein <strong>archiv.tar.bz2</strong> vor Ort angelegt. Mit einem einfachen <code class="notranslate">-exec</code> würde für jedes Verzeichnis ein Archiv im aktuellen Verzeichnis angelegt, d.h. das Archiv immer wieder überschrieben, so dass am Ende nur ein Archiv mit den Ergebnissen der letzten Ausführung von tar verbliebe. </p></li></ul><p>
</p><ul><li><p>Anstatt <code class="notranslate">-exec</code> bzw. <code class="notranslate">-execdir</code> kann man auch <code class="notranslate">-ok</code> bzw. <code class="notranslate">-okdir</code> verwenden </p><div class="bash"><div class="contents"><pre class="notranslate">find -name "*pdf" -okdir xpdf {} \; </pre></div></div><p> fragt vor jeder Datei nach, ob man wirklich die Aktion ausführen möchte. </p></li></ul><p>
</p><ul><li><p>Gesammelte Ausführung mit <code class="notranslate">+</code><br/>Beendet man ein Kommando mit Plus <code class="notranslate">+</code> statt mit Semikolon <code class="notranslate">;</code>, so werden mehrere, u.U. alle Funde auf einen Rutsch an das Kommando übergeben. Dies ist nur möglich, wenn das Kommando selbst mit mehreren Parametern zurechtkommt und das <code class="notranslate">+</code> unmittelbar den geschweiften Klammern folgt. Ein Beispiel mit <a class="internal" href="./du.html">du</a> ergibt zunächst: </p><div class="bash"><div class="contents"><pre class="notranslate">find -name "*pdf" -exec du --total {} ";" </pre></div></div><pre class="notranslate">16      ./A.pdf
16      insgesamt
12      ./B.pdf
12      insgesamt
100     ./C.pdf
100     insgesamt</pre><p> Dagegen erhält man ein sinnvolleres Ergebnis mit <code class="notranslate">+</code>: </p><div class="bash"><div class="contents"><pre class="notranslate">find -name "*pdf" -exec du --total {} + </pre></div></div><pre class="notranslate">16      ./A.pdf
12      ./B.pdf
100     ./C.pdf
128     insgesamt</pre></li></ul><p>
</p></div></div></div><div class="section_1"><h2 id="Weitere-Informationen">Weitere Informationen<a class="headerlink" href="#Weitere-Informationen">¶</a></h2><p>
</p><div class="section_2"><h3 id="Alternativen">Alternativen<a class="headerlink" href="#Alternativen">¶</a></h3><p>
find ist fast immer das Mittel der Wahl, wenn es darum geht, auch Unterverzeichnisse zu durchsuchen. Wenn man den Dateinamen genau kennt, kann <a class="internal" href="./locate.html">locate</a> eine bessere Wahl sein. locate arbeitet allerdings mit einem Index, der 1x täglich aktualisiert wird, und findet daher ganz frische Dateien nicht.</p><p>Für die spezielle Suche nach Programmen wird man whereis benutzen.</p><p>Im aktuellen Verzeichnis, ohne Unterverzeichnisse zu berücksichtigen, kommt man mit <a class="internal" href="./terminal.html#Vervollstaendigen-lassen-nicht-tippen">automatischer Vervollständigung</a> und den Jokerzeichen <code class="notranslate">*</code> und <code class="notranslate">?</code> oft weiter, wenn man Namensbestandteile kennt. Manche Programme bieten auch von sich aus an, Unterverzeichnisse zu berücksichtigen, siehe <a class="internal" href="./ls.html">ls</a> und <a class="internal" href="./shell/grep.html">Shell/grep</a>.</p></div><div class="section_2"><h3 id="Typische-Fehler">Typische Fehler<a class="headerlink" href="#Typische-Fehler">¶</a></h3><p>
</p><div class="section_3"><h4 id="die-Ausfuehrung-von-find-laeuft-zu-lange">die Ausführung von find läuft (zu) lange<a class="headerlink" href="#die-Ausfuehrung-von-find-laeuft-zu-lange">¶</a></h4><p>
Wenn die Suche mit find läuft, viel zu viele Ergebnisse ausgibt und nicht aufhören will, bricht man find mit 
<span class="key">Strg</span>  + 
<span class="key">C</span>  ab.</p></div><div class="section_3"><h4 id="Der-Pfad-muss-vor-dem-Suchkriterium-stehen">Der Pfad muss vor dem Suchkriterium stehen<a class="headerlink" href="#Der-Pfad-muss-vor-dem-Suchkriterium-stehen">¶</a></h4><p>
Wenn man den Stern <code class="notranslate">*</code> nicht maskiert, kommt es oft zu anschließender Meldung:</p><div class="bash"><div class="contents"><pre class="notranslate">find /home/ich -name .* </pre></div></div><p>
</p><pre class="notranslate">find: Der Pfad muß vor dem Ausdruck stehen: ..
Aufruf: find [-H] [-L] [-P] [-Olevel] [-D help|tree|search|stat|rates|opt|exec] [Pfad...] [Ausdruck]</pre><p>Korrekt ist:</p><div class="bash"><div class="contents"><pre class="notranslate">find /home/ich -name ".*" </pre></div></div></div><div class="section_3"><h4 id="Seltsame-Groessenangaben-bei-Dateien">Seltsame Größenangaben bei Dateien<a class="headerlink" href="#Seltsame-Groessenangaben-bei-Dateien">¶</a></h4><p>
Bei der Suche nach Dateigrößen kann man leicht verzweifeln, wenn man nicht dahinter kommt, dass die Vorgabemaßeinheit Blöcke à 512 Bytes sind.</p><div class="bash"><div class="contents"><pre class="notranslate">find -size 200c </pre></div></div><p>sucht nach Größen, die man erwartet.</p></div><div class="section_3"><h4 id="Seltsames-Nichtfinden-bei-Groessen-wie-k-M-G">Seltsames Nichtfinden bei Größen wie k, M, G<a class="headerlink" href="#Seltsames-Nichtfinden-bei-Groessen-wie-k-M-G">¶</a></h4><p>
Sucht man z.B. nach Dateien, die kleiner als 5 kiB sind, so klingt folgender Befehl zunächst plausibel:
</p><div class="bash"><div class="contents"><pre class="notranslate">find -size -5k </pre></div></div><p>
Damit werden aber nur Dateien bis maximal 4 kiB gefunden, d.h. es wird keine Datei gefunden, die 4097 Bytes groß ist, denn es wird erst aufgerundet (auf 5k) und dann verglichen. Wenn man Dateien bis 1 Mebibyte suchen wollte führt deshalb <code class="notranslate">-1M</code> nicht zum Ziel – selbst 1 Byte ist größer als die nächstkleinere Ganzzahl in dieser Maßeinheit, also größer als <code class="notranslate">0M</code>.</p></div><div class="section_3"><h4 id="Kombination-von-or-und-and-ergibt-Unerwartetes">Kombination von -or und -and ergibt Unerwartetes<a class="headerlink" href="#Kombination-von-or-und-and-ergibt-Unerwartetes">¶</a></h4><p>
Bei der Oder- und Und-Verknüpfung von Optionen helfen Klammern, Fehler zu vermeiden.</p></div><div class="section_3"><h4 id="Warnung-bei-falscher-Position-von-globalen-Ausdrucksoptionen">Warnung bei falscher Position von globalen Ausdrucksoptionen<a class="headerlink" href="#Warnung-bei-falscher-Position-von-globalen-Ausdrucksoptionen">¶</a></h4><p>
Im <a class="internal" href="./man.html">Manual</a> zu <a class="interwiki interwiki-man_de" href="http://manpages.ubuntu.com/cgi-bin/search.py?lr=lang_de&amp;q=find">find</a> wird alles nach den Startpunkten als <code class="notranslate">AUSDRUCK</code> benannt. Dieser kann globale und positionale Optionen (nicht zu verwechseln mit den hier nicht beschriebenen <a class="crosslink" href="#Der-Pfad-muss-vor-dem-Suchkriterium-stehen">Befehlsoptionen</a>), Tests, Operatoren und Aktionen beinhalten. Stehen globale Optionen, die immer für die ganze Suche gelten, nicht am Anfang des Ausdrucks, so sieht das aus, als habe der Nutzer eine andere Absicht gehabt, und man bekommt deshalb eine Warnung.</p><p>Provozieren kann man die Warnung etwa so:</p><div class="bash"><div class="contents"><pre class="notranslate">find ./SUCHVERZEICHNIS -maxdepth 4 -name foo -or -maxdepth 2 </pre></div></div><pre class="notranslate">find: Warnung: Sie haben die Option -maxdepth nach einem Argument -name angegeben, das keine Option ist, weil Optionen nicht positional sind (-maxdepth beeinflusst sowohl Tests davor als auch jene danach). Bitte geben Sie Optionen vor anderen Argumenten an.</pre></div><div class="section_3"><h4 id="xargs-und-Schleifen">xargs und Schleifen<a class="headerlink" href="#xargs-und-Schleifen">¶</a></h4><p>
Oft findet man Konstruktionen mit <code class="notranslate">find ... xargs</code> oder Shellschleifen die find bemühen. Fast immer lässt sich das Problem durch eine der <a class="crosslink" href="#exec-und-dessen-Varianten">Aktionen</a> (<code class="notranslate">-okdir</code>, <code class="notranslate">-execdir</code>, ...) eleganter lösen.</p></div><div class="section_3"><h4 id="Die-Aktion-delete-steht-an-der-falschen-Stelle">Die Aktion -delete steht an der falschen Stelle<a class="headerlink" href="#Die-Aktion-delete-steht-an-der-falschen-Stelle">¶</a></h4><p>
Der folgende Aufruf löscht den kompletten Inhalt des Ordners <strong>/home/ottifant/</strong>:</p><div class="bash"><div class="contents"><pre class="notranslate">find /home/ottifant/ -delete -name Cache    # falsch! </pre></div></div></div></div></div><div class="section_1"><h2 id="Links">Links<a class="headerlink" href="#Links">¶</a></h2><p>
</p><ul><li><p><a class="external" href="http://www.easylinux.de/2004/01/072-find/" rel="nofollow">Dateisuche mit find</a> <img alt="{de}" src="./_/ffd333e1d59794eac31aea8b3e984e1b88473c33.png"/> - Artikel von EasyLinux mit weiteren Beispielen, 01/2004</p></li><li><p><a class="external" href="http://www.gnu.org/software/findutils/manual/html_mono/find.html" rel="nofollow">findutils auf gnu.org</a> <img alt="{en}" src="./_/d5ecf89114b079f85d02099649c4ee617ffa34c7.png"/> - Sehr ausführliche Seite zum Thema Suche</p></li><li><p><a class="internal" href="./shell/befehlsübersicht.html">Shell/Befehlsübersicht</a> <img alt="{Übersicht}" src="./_/021d71c30babf2ce4dd27339ba3c55995610945b.png"/></p></li></ul><p>
</p></div></div>
<p class="meta">
<a href="./find/a/revision/941542.html">Diese Revision</a> wurde am 21. Mai 2017 03:31 von <a href="https://ubuntuusers.de/user/user_unknown/">user_unknown</a> erstellt.
    
  </p>
</div>
</div>
<div style="clear: both;"></div>
<div class="pathbar breadcrumb">
<div class="breadcrumb">
<ol>
<li><a href="./startseite.html">Wiki</a></li>
<li><a href="./find.html">find</a></li>
</ol>
</div>
</div>
</div>
<div class="footer" style="clear: both;">
<ul>
<li class="poweredby"><li class="poweredby">Erstellt mit <a href="http://inyokaproject.org/">Inyoka</a></li></li>
<li class="license">

<img alt="Copyleft" src="./_/65dad5b770326dbbe1bd26ee6363e366a76bd8b7.png"/>
          2004 – 2017 ubuntuusers.de • Einige Rechte vorbehalten<br/>
<a href="./_lizenz.html" rel="cc:morePermissions">Lizenz</a> •
          <a href="http://ubuntuusers.de/kontakt/">Kontakt</a> •
          <a href="http://ubuntuusers.de/datenschutz/">Datenschutz</a> •
          <a href="http://ubuntuusers.de/impressum/">Impressum</a> •
          <a href="https://ubuntuusers.statuspage.io">Serverstatus</a>
</li>
<li class="housing">
<span title="Unterbringung und Netzanbindung eines Servers">Serverhousing</span> gespendet von<br/>
<img alt="noris network" src="./_/e7d27e9081eec23a8a5a5fe9434d7b2f1532e1d9.png"/>
<img alt="anexia" src="./_/ad1b63a3fc35749344af0a03e8c3ce05a2a3ee7e.png"/>
</li>
</ul>
</div>
<div style="clear: both;"></div>
</div>






</body>
</html>