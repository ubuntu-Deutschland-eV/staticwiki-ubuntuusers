<!DOCTYPE html>
<html lang="">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>SSH › ubuntuusers statisches Wiki</title>
<link href="./_/34e5d78db234405457773cc26741aada99f7fff2.css" rel="stylesheet" type="text/css"/>
<link href="./_/61af784fc5c93e296fec3be63b8e0bb48443727c.css" rel="stylesheet" type="text/css"/>
<link href="./_/634e8d1015b02df998cdec7cb07c5aff61d068b5.css" rel="stylesheet" type="text/css"/>
<link href="./_/b583ff7e37147497a59224ccf54cfee812a1d21b.css" rel="stylesheet" type="text/css"/>
<link href="./_/a0d5775ed6f36f8cc5b12bcf2f1c1bd98a3eb225.css" rel="stylesheet" type="text/css"/>
<link href="./_/98de73bded109a634cbd1e924abdd8c8964b8df2.css" media="print" rel="stylesheet" type="text/css"/>

<meta content="#a87300" name="theme-color"/>

</head>
<body>
<div class="wrap">
<div class="header">
<h1><a href="http://ubuntuusers.de/"><span>ubuntuusers.de</span></a></h1>
<ul class="tabbar">
<li class="portal">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://ubuntuusers.de/">Portal<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="forum">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://forum.ubuntuusers.de/">Forum<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="wiki active">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://wiki.ubuntuusers.de/">Wiki<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="ikhaya">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://ikhaya.ubuntuusers.de/">Ikhaya<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="planet">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://planet.ubuntuusers.de/">Planet<span></span></a></div>
<div class="tab_right"></div>
</li>
<li class="community">
<div class="tab_left"></div>
<div class="tab_center"><a href="http://wiki.ubuntuusers.de/Mitmachen">Mitmachen<span></span></a></div>
<div class="tab_right"></div>
</li>
</ul>
</div>
<div class="body">
<div class="appheader">

<div class="pagetitle">
<h1 class="breadcrumb_title">
<a class="separator" href="./startseite.html">
              Wiki
            </a>
</h1>
<h2 class="breadcrumb_subtitle"><a href="./ssh.html">SSH</a></h2>
</div>
</div><div class="message staticwikinote"><strong>Hinweis:</strong> Dies ist ein statischer Snapshot unseres Wikis vom Jan. 17, 2018 und kann daher nicht bearbeitet werden. Der aktuelle Artikel ist unter <a href="http://wiki.ubuntuusers.de/SSH">wiki.ubuntuusers.de</a> zu finden.</div>

<!--[if lt IE 8]>
      <div class="message fail">Bitte installiere den Internet Explorer 8 oder neuer.</div>
      <![endif]-->
<div class="page_content">
<div class="navi_sidebar navigation">
<div class="container">
<h3 class="navi_wiki">Wiki</h3>
<ul>
<li><a href="./wiki/index.html">Index</a></li>
<li><a href="./wiki/recentchanges.html">Letzte Änderungen</a></li>
<li><a href="./wiki/neue_artikel.html">Liste neuer Artikel</a></li>
<li><a href="./wiki.html">Übersicht</a></li>
<li><a href="./wiki/faq_-_häufig_gestellte_fragen.html">FAQ</a></li>
<li><a href="./wiki/benutzung.html">Benutzung</a></li>
<li><a href="./kategorien.html">Kategorie</a></li>
<li><a href="./wiki/tagcloud.html">Wortwolke</a></li>
</ul>
<h3 class="navi_join">Mitmachen</h3>
<ul>
<li><a href="./wikiartikel_anlegen.html">Wikiartikel anlegen</a></li>
<li><a href="./howto.html">Howto anlegen</a></li>
<li><a href="./wiki/referenz.html">Wiki-Referenz</a></li>
<li><a href="./wiki/syntax.html">Wiki-Syntax</a></li>
<li><a href="./baustelle.html">Baustellen</a></li>
<li><a href="./wiki/artikelideen.html">Artikelideen</a></li>
<li><a href="./wiki/ungetestet.html">Ungetestete Artikel</a></li>
<li><a href="./wiki/vorlagen/ausbaufähig/a/backlinks.html">Ausbaufähige Artikel</a></li>
<li><a href="./wiki/vorlagen/fehlerhaft/a/backlinks.html">Fehlerhafte Artikel</a></li>
<li><a href="https://forum.ubuntuusers.de/forum/wiki/">Rund ums Wiki</a></li>
</ul>
<h3 class="navi_config">Konfiguration</h3>
<ul>
<li><a href="./ssh/a/backlinks.html">Backlinks anzeigen</a></li>
<li>
        Exportieren
        <ul>
<li><a href="./ssh/a/export/meta.html" rel="nofollow">Metadaten</a></li>
<li><a href="./ssh/a/export/raw.html" rel="nofollow">Rohformat</a></li>
<li><a href="./ssh/a/export/html.html" rel="nofollow">HTML</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div class="content content_tabbar content_sidebar">
<h1 class="pagetitle"><a href="./ssh/a/backlinks.html">SSH</a></h1>
<div id="page"><p>
</p><div class="box tested_for"><h3 class="box tested_for">Dieser Artikel wurde für die folgenden
Ubuntu-Versionen getestet:</h3><div class="contents"><p>
</p><ul><li><p><a class="internal" href="./artful_aardvark.html">Ubuntu 17.10</a> Artful Aardvark</p></li><li><p><a class="internal" href="./xenial_xerus.html">Ubuntu 16.04</a> Xenial Xerus</p></li><li><p><a class="internal" href="./trusty_tahr.html">Ubuntu 14.04</a> Trusty Tahr</p></li></ul></div></div><p>
</p><p>
</p><div class="box advanced"><h3 class="box advanced">Artikel für fortgeschrittene Anwender</h3><div class="contents"><p>
Dieser Artikel erfordert mehr Erfahrung im Umgang mit
Linux und ist daher nur für fortgeschrittene Benutzer
gedacht.
</p></div></div><div class="box knowledge"><h3 class="box knowledge">Zum Verständnis dieses Artikels sind folgende Seiten hilfreich:</h3><div class="contents"><p>
</p><ol class="arabic"><li><p><a class="crosslink anchor" href="#source-1" id="source-1"></a> <a class="internal" href="./pakete_installieren.html">Installation von Programmen</a> </p></li><li><p><a class="crosslink anchor" href="#source-2" id="source-2"></a> <a class="internal" href="./terminal.html">Ein Terminal öffnen</a> </p></li><li><p><a class="crosslink anchor" href="#source-3" id="source-3"></a> <a class="internal" href="./shell.html">Umgang mit der Kommandozeile</a> </p></li><li><p><a class="crosslink anchor" href="#source-4" id="source-4"></a> <a class="internal" href="./sicherheits_1x1.html">Sicherheits-Einmaleins</a> </p></li><li><p><a class="crosslink anchor" href="#source-5" id="source-5"></a> <a class="internal" href="./autostart.html">Automatischer Start von Programmen</a>, <em>optional</em> </p></li></ol></div></div><p>
</p><div class="toc toc-depth-2"><div class="head">Inhaltsverzeichnis</div><ol class="arabic"><li><a class="crosslink" href="#Der-SSH-Client">Der SSH-Client
</a><ol class="arabic"><li><a class="crosslink" href="#Benutzeroberflaeche-fuer-die-Verbindungsverwaltung">Benutzeroberfläche für die Verbindungsve...</a></li><li><a class="crosslink" href="#ssh-config">.ssh/config
</a></li></ol></li><li><a class="crosslink" href="#Der-SSH-Server">Der SSH-Server
</a><ol class="arabic"><li><a class="crosslink" href="#Identifikationsschluessel-uebernehmen">Identifikationsschlüssel übernehmen
</a></li></ol></li><li><a class="crosslink" href="#Dateitransfer">Dateitransfer
</a><ol class="arabic"><li><a class="crosslink" href="#Transfer-von-der-Kommandozeile">Transfer von der Kommandozeile
</a></li><li><a class="crosslink" href="#Entfernte-Dateisysteme-einbinden">Entfernte Dateisysteme einbinden
</a></li><li><a class="crosslink" href="#Grafische-Programme-zum-Dateitransfer">Grafische Programme zum Dateitransfer
</a></li></ol></li><li><a class="crosslink" href="#Authentifizierung-ueber-Public-Keys">Authentifizierung über Public-Keys
</a><ol class="arabic"><li><a class="crosslink" href="#Verschluesseltes-Home-Verzeichnis">Verschlüsseltes Home-Verzeichnis
</a></li><li><a class="crosslink" href="#Der-SSH-Agent">Der SSH-Agent
</a></li><li><a class="crosslink" href="#Login-ueber-mehrere-Rechner">Login über mehrere Rechner
</a></li><li><a class="crosslink" href="#SSH-Askpass">SSH-Askpass
</a></li><li><a class="crosslink" href="#Single-Sign-On">Single-Sign-On
</a></li></ol></li><li><a class="crosslink" href="#X-Forwarding">X-Forwarding
</a><ol class="arabic"><li><a class="crosslink" href="#Serverkonfiguration">Serverkonfiguration
</a></li></ol></li><li><a class="crosslink" href="#SSH-Tunnel">SSH-Tunnel
</a><ol class="arabic"><li><a class="crosslink" href="#Beispiele">Beispiele
</a></li></ol></li><li><a class="crosslink" href="#Weitere-Verschluesselungsdetails">Weitere Verschlüsselungsdetails
</a><ol class="arabic"><li><a class="crosslink" href="#Symmetrische-Verschluesselung">Symmetrische Verschlüsselung
</a></li><li><a class="crosslink" href="#Asymmetrische-Verschluesselung">Asymmetrische Verschlüsselung
</a></li></ol></li><li><a class="crosslink" href="#Problembehebung">Problembehebung
</a><ol class="arabic"><li><a class="crosslink" href="#Offending-Keys">Offending Keys
</a></li><li><a class="crosslink" href="#Unter-sftp-ist-Zugriff-auf-alles-ab-dem-Wurzelverzeichnis-moeglich">Unter sftp ist Zugriff auf alles ab dem ...</a></li></ol></li><li><a class="crosslink" href="#Links">Links
</a><ol class="arabic"><li><a class="crosslink" href="#Intern">Intern
</a></li><li><a class="crosslink" href="#Extern">Extern
</a></li></ol></li></ol></div><p><img alt="Wiki/Icons/security.png" class="image-left" src="./_/41964c605d00862ffb1a26a04504ddefdfeb498d.png"/>
Es gab einmal eine Zeit, als Computer im Netz über das <a class="interwiki interwiki-wikipedia" href="https://de.wikipedia.org/wiki/Telnet">Telnet</a>-Protokoll zugänglich waren. Da dieses Protokoll keine Verschlüsselung bot, wurde das Mitschneiden von Passwörtern zur trivialen Angelegenheit.</p><p>Um den Fernzugang zu sichern, schrieb Tatu Ylönen Mitte der 1990er eine Programmsuite – bestehend aus Server, Client und Hilfsprogrammen – die er <strong>ssh</strong> (<em>secure shell</em>) nannte.</p><p>Später gründete er die Firma <a class="external" href="http://www.ssh.com/" rel="nofollow">ssh.com</a> <img alt="{en}" src="./_/d5ecf89114b079f85d02099649c4ee617ffa34c7.png"/> und bot die Version 2 der SSH-Suite nur noch kommerziell an. Daraufhin wurde von Entwicklern des Betriebssystems <a class="interwiki interwiki-wikipedia" href="https://de.wikipedia.org/wiki/OpenBSD">OpenBSD</a> der öffentliche Quellcode der Version 1 <a class="interwiki interwiki-wikipedia" href="https://de.wikipedia.org/wiki/Abspaltung_(Softwareentwicklung)">geforkt</a>. Sie entwickelten das Programm unter dem Namen "OpenSSH" weiter. Diese OpenSSH-Suite wurde fester Bestandteil quasi aller Linux-Distributionen.</p><p>Drei wichtige Eigenschaften führten zum Erfolg von <strong>ssh</strong>:</p><ul><li><p>Authentifizierung der Gegenstelle, kein Ansprechen falscher Ziele</p></li><li><p>Verschlüsselung der Datenübertragung, kein Mithören durch Unbefugte</p></li><li><p>Datenintegrität, keine Manipulation der übertragenen Daten</p></li></ul><p>
Mehr Details zur verwendeten Verschlüsselung finden sich <a class="crosslink" href="#Weitere-Verschluesselungsdetails">weiter unten</a>. Falls man sich auf den eigenen Computer hinter einem DSL-Router per SSH einloggen will, muss man zuvor in diesem eine <a class="internal" href="./portweiterleitung.html">Portweiterleitung</a> einrichten, sonst kommt keine Verbindung zustande.</p><p><a class="crosslink anchor" href="#SSH-Client" id="SSH-Client"></a></p><div class="section_1"><h2 id="Der-SSH-Client">Der SSH-Client<a class="headerlink" href="#Der-SSH-Client">¶</a></h2><p>
Das funktioniert normalerweise in einen Terminal-Fenster <sup><a href="#source-2">[2]</a></sup> so:</p><div class="bash"><div class="contents"><pre class="notranslate">ssh user@sol-1 </pre></div></div><p>
</p><pre class="notranslate">user@sol-1's password:
Last login: Sun Feb 12 07:38:50 2006 from client.local
Sun Microsystems Inc.   SunOS 5.9       Generic_112234-03       November 2002
bash-2.05$</pre><p>
Und schon befindet man sich auf einem anderen System, in diesem Fall mit dem Betriebssystem Solaris.</p><div class="bash"><div class="contents"><pre class="notranslate">ssh server </pre></div></div><p>
</p><pre class="notranslate">Password:
Linux vdr 2.4.27-ctvdr-1 #1 Fri Oct 15 18:38:29 UTC 2004 i686 GNU/Linux
The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.
Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
You have new mail.
Last login: Sun Feb 12 07:38:23 2006 from client.local
user@server:~$</pre><p>
Oder auf einem anderen Linux-System. Wie man sieht, ist die Angabe des Benutzernamens optional, wenn er auf beiden Systemen gleich ist. Man kann auch einfach einen Befehl anhängen, der anstelle der Terminal-Session ausgeführt wird. Nach der Ausführung des Befehls wird die SSH-Session dann automatisch beendet:</p><div class="bash"><div class="contents"><pre class="notranslate">ssh server cat /etc/issue </pre></div></div><p>
</p><pre class="notranslate">Password:
Debian GNU/Linux 3.1 \n \l</pre><p>
Oder etwas komplizierter - eine Datensicherung machen ("backup"):</p><div class="bash"><div class="contents"><pre class="notranslate">user@client:~$ ssh root@server 'cd /etc; tar czvf - network/' | cat &gt; etc_network_backup.tar.gz </pre></div></div><p>
</p><pre class="notranslate">Password:
network/
network/interfaces
network/if-post-down.d/
network/if-pre-up.d/
network/if-up.d/
network/if-down.d/
network/options
network/interfaces.pre-etherconf
network/interfaces.1
network/run</pre><p>
Bei einer langsamen Verbindung empfiehlt sich zusätzlich die Benutzung der Option <code class="notranslate">-C</code> (großes C), die zusätzlich zur Verschlüsselung eine transparente Kompression der übertragenen Daten aktiviert. Bei einer schnellen Verbindung wird die Kompression aber vermutlich bremsen.</p><p>Woher weiß man nun aber, dass man tatsächlich mit dem richtigen Rechner verbunden ist, und nicht ein Angreifer die Verbindung umgeleitet hat? Dafür gibt es den Host-Schlüssel, der jeden SSH-Server eindeutig identifiziert. Greift man zum ersten Mal auf einen bestimmten Server zu, kennt man diesen Schlüssel natürlich noch nicht. (Außer man hat ihn sich auf anderen Wegen im Voraus besorgt.)</p><div class="bash"><div class="contents"><pre class="notranslate">ssh server </pre></div></div><p>
</p><pre class="notranslate">The authenticity of host 'server (192.168.1.5)' can't be established.
ECDSA key fingerprint is b5:0e:ec:b7:16:06:e6:24:a6:39:18:58:4e:ec:3b:d1.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added 'server' (ECDSA) to the list of known hosts.
Password:</pre><p>
Wenn gerade in diesem Moment jemand die Verbindung gekapert hat, hat man natürlich Pech, außer man kann den Administrator des Servers nach dem richtigen Fingerprint des Host-Schlüssels fragen.</p><p><a class="crosslink anchor" href="#Fingerprint_ueberpruefen" id="Fingerprint_ueberpruefen"></a> 
Den ECDSA-Fingerprint eines Servers kann man mit dem Systemprogramm <strong>ssh-keygen</strong> erfahren:</p><div class="bash"><div class="contents"><pre class="notranslate">ssh-keygen -f /etc/ssh/ssh_host_ecdsa_key.pub -l </pre></div></div><p>
gibt den Fingerprint und einige weitere Informationen aus, z.B. <code class="notranslate">256 b5:0e:ec:b7:16:06:e6:24:a6:39:18:58:4e:ec:3b:d1 root@server (ECDSA)</code>. Wenn man auf Nummer sicher gehen möchte, lässt man sich vom Administrator des Servers diese Ausgabe mitgeben (evtl. ausdrucken) und kann dann beim ersten Verbindungsversuch überprüfen, ob man sich tatsächlich zum richtigen SSH-Server verbunden hat und nicht zu einem dazwischen geschalteten Angreifer.</p><p>Bei allen weiteren Kontakten stellt das <strong>ssh</strong>-Programm jedoch von nun an über asymmetrische Kryptografie sicher, dass der Server auch über den richtigen privaten Schlüssel verfügt, der zum öffentlichen, in der Datei <strong>~/.ssh/known_hosts</strong> abgelegten passt, und verweigert im Zweifelsfall den Verbindungsaufbau. Hier eine Beispielausgabe:</p><pre class="notranslate">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the ED25519 key sent by the remote host is
SHA256:2iJAHZZHlYMrlrBGw3t7Ma62TuZ0p7p+av3O4W+cpHY.
Please contact your system administrator.
Add correct host key in /home/tux/.ssh/known_hosts to get rid of this message.
Offending ECDSA key in /home/tux/.ssh/known_hosts:6
  remove with:
  ssh-keygen -f "/home/tux/.ssh/known_hosts" -R 172.217.22.227
ED25519 host key for 172.217.22.227 has changed and you have requested strict checking.
Host key verification failed.</pre><p>Die Ausgabe enthält auch gleich das Kommando, das man ausführen muss, falls sich der Schlüssel aus legitimen Gründen einmal geändert haben sollte (bspw. weil das System neu aufgesetzt wurde):</p><div class="bash"><div class="contents"><pre class="notranslate">ssh-keygen -f &lt;DATEI&gt; -R &lt;HOST&gt; </pre></div></div><p>Im obigen Beispiel also</p><div class="bash"><div class="contents"><pre class="notranslate">ssh-keygen -f "/home/tux/.ssh/known_hosts" -R 172.217.22.227 </pre></div></div><p>Sollte die Verbindung nicht mehr reagieren, z.B. wenn der SSH-Server heruntergefahren wurde, lässt sich der SSH-Client mit der Eingabe von "<code class="notranslate">~.</code>" (nacheinander) beenden.</p><div class="box notice"><h3 class="box notice">Hinweis:</h3><div class="contents"><p>Wer (noch) einen Windows-Desktop benutzt und über das SSH-Protokoll auf eine Linux-Maschine zugreifen will, kann das Programm <a class="internal" href="./putty.html">PuTTY</a> nutzen. 
</p></div></div><div class="section_2"><h3 id="Benutzeroberflaeche-fuer-die-Verbindungsverwaltung">Benutzeroberfläche für die Verbindungsverwaltung<a class="headerlink" href="#Benutzeroberflaeche-fuer-die-Verbindungsverwaltung">¶</a></h3><p>
Wem es zu mühsam ist, auf der Kommandozeile die SSH-Verbindung zu einem Server aufzubauen, der sucht vielleicht ein grafisches Programm, um Verbindungsdaten zu verwalten.</p><ul><li><p><a class="internal" href="./putty.html">PuTTY</a> - gibt es sowohl für Linux als auch für Windows. Das Programm ist in den offiziellen Paketquellen enthalten.</p></li><li><p><a class="interwiki interwiki-sourceforge" href="http://sourceforge.net/projects/pacmanager">PAC Manager</a> <img alt="{en}" src="./_/d5ecf89114b079f85d02099649c4ee617ffa34c7.png"/> - (<strong>Perl</strong> <strong>A</strong>uto <strong>C</strong>onnector) nicht in den offiziellen Paketquellen enthalten, aber über SourceForge wird ein Fremdpaket angeboten, das manuell installiert werden kann.</p></li><li><p><a class="interwiki interwiki-sourceforge" href="http://sourceforge.net/projects/gnome-rdp">Gnome-RDP</a> <img alt="{en}" src="./_/d5ecf89114b079f85d02099649c4ee617ffa34c7.png"/> - mit diesem Programm kann man nicht nur <a class="interwiki interwiki-wikipedia" href="https://de.wikipedia.org/wiki/Remote_Desktop_Protocol">RDP</a>- und <a class="internal" href="./vnc.html">VNC</a>-Verbindungen aufbauen, sondern auch SSH-Terminalsitzungen. Leider kann man in der aktuellen Version die Zugangspasswörter nicht speichern lassen und keine Angaben zum verwendeten Port machen. Es funktioniert somit nur mit Servern, die den Standard-SSH-Port <code class="notranslate">22</code> nutzen. In den offiziellen Paketquellen enthalten, benötigt aber <a class="interwiki interwiki-wikipedia" href="https://de.wikipedia.org/wiki/Mono-Projekt">Mono</a> als Voraussetzung.</p></li></ul><p>
</p></div><div class="section_2"><h3 id="ssh-config">.ssh/config<a class="headerlink" href="#ssh-config">¶</a></h3><p>
Wenn man sich auf der Konsole mit einem anderen Server verbinden möchte, muss man evtl. z.B. Port und Benutzernamen angeben. Um das Ganze zu vereinfachen, kann man Voreinstellungen für ssh in der config-Datei <strong>$HOME/.ssh/config</strong> hinterlegen. Hier ein Beispiel: 
</p><pre class="notranslate"># ssh (secure shell) configuration file
Host test1
    HostName 123.456.789.0
    Port 980
    User MeinBenutzerName

Host test2
    HostName test.mynet.local
    User test
    CheckHostIP no
    Cipher blowfish

Host foobar
    HostName domain.tld
    Port 55550
    User fanta
    IdentityFile ~/.ssh/private_ssh_key_rsa</pre><p>Nun braucht man nicht mehr
</p><div class="bash"><div class="contents"><pre class="notranslate">ssh MeinBenutzerName@123.456.789.0 -p980 </pre></div></div><p>
zu schreiben, es reicht nun ein kurzes</p><div class="bash"><div class="contents"><pre class="notranslate">ssh test1 </pre></div></div><p>
für einen Verbindungsaufbau. Alle Parameter, die man verwenden kann, findet man unter <a class="external" href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh_config" rel="nofollow">openbsd.org</a> <img alt="{en}" src="./_/d5ecf89114b079f85d02099649c4ee617ffa34c7.png"/> oder in der <a class="internal" href="./man.html">Manpages</a> von <strong>ssh_config</strong>.</p><p><a class="crosslink anchor" href="#SSH-Server" id="SSH-Server"></a></p></div></div><div class="section_1"><h2 id="Der-SSH-Server">Der SSH-Server<a class="headerlink" href="#Der-SSH-Server">¶</a></h2><p>
Im Gegensatz zum SSH-Klienten ist der SSH-Server unter Ubuntu standardmäßig nicht installiert. Er lässt sich über das Paket 
</p><ul><li><p><strong>openssh-server</strong></p></li></ul><p><img alt="Wiki/Vorlagen/Installbutton/button.png" class="image-default" src="./_/fd60ccb86c4d96df2f4518df2936cc7d038467aa.png"/>
mit <a class="internal" href="./apturl.html">apturl</a>
</p><div class="package-list"><div class="contents"><p>
Paketliste zum Kopieren:
</p><div class="bash"><div class="contents"><pre class="notranslate">sudo apt-get install openssh-server </pre></div></div><p>
</p><div class="bash"><div class="contents"><pre class="notranslate">sudo aptitude install openssh-server </pre></div></div><p>
</p></div></div><p>
installieren <sup><a href="#source-1">[1]</a></sup>.</p><p>Die Konfiguration des SSH-Servers <strong>sshd</strong> findet über die Datei <strong>/etc/ssh/sshd_config</strong> statt. Die Voreinstellungen sind aber durchweg akzeptabel.</p><p>Wer den <strong>sshd</strong> auf einem Gateway oder Router betreibt oder aus einem anderen Grund mehrere Netzwerkschnittstellen verwendet (bspw. WLAN), der möchte dort vielleicht die <strong>ListenAddress</strong>-Direktive benutzen, um den Server nur an bestimmten Netzwerk-Schnittstellen laufen zu lassen.</p><p>Außerdem kann es sinnvoll sein, <strong>PermitRootLogin</strong> auf <strong>no</strong> zu setzen. Dann kann sich niemand direkt als <em>root</em> einloggen, sondern man meldet sich unter seinem Benutzernamen an und ruft dann <strong>su</strong> oder <strong>sudo -s</strong> auf. Dies ist aber unter Ubuntu nur relevant, sollte man dem "root"-Benutzerkonto ein Passwort zugewiesen haben.</p><p>Mit den Direktiven <strong>AllowUsers</strong> und <strong>AllowGroups</strong> bzw. <strong>DenyUsers</strong> und <strong>DenyGroups</strong> lässt sich noch genauer festlegen, welche Benutzer sich anmelden dürfen und welche nicht. Dies empfiehlt sich besonders bei Servern. <strong>AllowGroups admin</strong> verbietet bspw. allen Benutzern, die keine Mitglieder der Gruppe <em>admin</em> sind, den Zugriff.</p><p>Wer sich ausschließlich über das noch sicherere <a class="crosslink" href="#Authentifizierung-ueber-Public-Keys">Public-Key-Verfahren</a> anmelden will, der sollte die Benutzung von Passwörtern mit <strong>PasswordAuthentication no</strong> abschalten.</p><p>Falls lange Wartezeiten bei der Anmeldung am SSH-Server auftreten, könnte das an einer fehlgeschlagenen Namensauflösung liegen. Da man SSH normalerweise sowieso über die IP benutzt, können diese DNS-Anfragen in der <strong>sshd_config</strong> deaktiviert werden. Der dafür nötige Eintrag wäre <strong>UseDNS no</strong>.</p><p>Nach erfolgter Änderung der Datei <strong>sshd_config</strong> muss der Server mit dem Befehl:</p><div class="bash"><div class="contents"><pre class="notranslate">sudo service ssh restart  # ab Ubuntu 15.04 </pre></div></div><p>neugestartet werden, damit die Änderungen wirksam werden.</p><div class="box notice"><h3 class="box notice">Hinweis:</h3><div class="contents"><p>Standardmäßig wird der SSH-Server beim Booten geladen. Unter <a class="internal missing" href="./14_04.html">Ubuntu 14.04</a> ist Upstart für den Autostart des SSH-Servers zuständig. Wie man den Autostart deaktiviert, wird im <a class="internal" href="./upstart.html#Deaktivieren-von-Init-Jobs">Upstart-Artikel</a> beschrieben. <a class="internal missing" href="./16_04.html">Ubuntu 16.04</a> verwendet für die Steuerung des Autostart <a class="internal" href="./systemd.html">systemd</a> .
</p></div></div><div class="section_2"><h3 id="Identifikationsschluessel-uebernehmen">Identifikationsschlüssel übernehmen<a class="headerlink" href="#Identifikationsschluessel-uebernehmen">¶</a></h3><p>
Bei der Installation des SSH-Servers wird ein Satz Identifikationsschlüssel für das System (Fingerprints) erzeugt. Die entsprechenden Dateien lauten <strong>/etc/ssh/ssh_host*</strong>. Möchte man die Identifikationsschlüssel aus einem bestehenden System oder einer früheren Installation übernehmen, so muß man die oben genannten Dateien ersetzen. Sinnvoll ist dies z.B. im Rahmen einer Neuinstallation oder wenn man auf ein und dem selben Rechner mehrere Linux-Versionen installiert hat. Damit vermeidet man auf Client-Seite die Offending-Key-Problematik (siehe <a class="crosslink" href="#Offending-Keys">Problembehebung</a>).</p><p><a class="crosslink anchor" href="#Dateitransfer" id="Dateitransfer"></a></p></div></div><div class="section_1"><h2 id="Dateitransfer">Dateitransfer<a class="headerlink" href="#Dateitransfer">¶</a></h2><p>
Wenn man also ein Protokoll hat, das so sicher wie nach dem heutigen Stand der Technik möglich Daten durch einen verschlüsselten Kanal senden und empfangen kann, dann wäre es wohl Verschwendung, dieses Protokoll nur für interaktive Terminal-Sessions zu benutzen. Sehr häufig möchte man bspw. einfach nur Dateien sicher von einem System zum anderen bewegen. Dafür existieren verschiedene Programme der grafischen Benutzeroberfläche sowie gleich zwei Terminalbefehle nämlich <strong>scp</strong> und <strong>sftp</strong>.</p><div class="section_2"><h3 id="Transfer-von-der-Kommandozeile">Transfer von der Kommandozeile<a class="headerlink" href="#Transfer-von-der-Kommandozeile">¶</a></h3><p>
<a class="crosslink anchor" href="#scp" id="scp"></a>
</p><div class="section_3"><h4 id="scp">scp<a class="headerlink" href="#scp">¶</a></h4><p>
Das Kommandozeilenwerkzeug <strong>scp</strong> funktioniert in etwa so wie das normale Unix-Kommando <strong>cp</strong>, nur dass es über Systemgrenzen hinweg funktioniert. Jedes Datei- oder Verzeichnisargument kann dabei optional, getrennt durch einen Doppelpunkt, durch einen vorangestellten Benutzer- bzw. Hostnamen ergänzt werden. Dabei werden weggelassene Teile durch den aktuellen Benutzernamen, <em>localhost</em> bzw. das Homeverzeichnis (bzw. das aktuelle Verzeichnis) ergänzt, etwa so:</p><div class="bash"><div class="contents"><pre class="notranslate">scp benutzerx@server1:datei1 datei2 benutzery@server2: </pre></div></div><p>
In diesem Beispiel wurde die <em>datei1</em> aus dem Homeverzeichnis von <em>benutzerx</em> auf <em>server1</em> und die <em>datei2</em> aus dem aktuellen Verzeichnis des lokalen Hosts in das Homeverzeichnis von <em>benutzery</em> auf <em>server2</em> kopiert.</p><p>Der Befehl <strong>scp</strong> versteht auch einige von <strong><a class="internal" href="./cp.html">cp</a></strong> bekannte Optionen, bspw. <code class="notranslate">-r</code> für das rekursive Kopieren ganzer Verzeichnisbäume. Bedauerlicherweise unterstützt <strong>scp</strong> aber nicht alle <strong>cp</strong>-Optionen, die für das exakte Klonen von Verzeichnissen, inkl. aller Dateirechte und symbolischen Verknüpfungen notwendig sind. Für die exakte Replikation sollte deswegen entweder das Werkzeug <code class="notranslate">rsync -e ssh</code> genutzt werden (man beachte die Handbuchseite zu diesem Tool) oder der oben schon genutzte Trick mit <strong>tar</strong> und einer Pipe.</p><div class="bash"><div class="contents"><pre class="notranslate">ssh root@server 'cd verzeichnis; tar czvf - verz./dateien' | tar xzf - </pre></div></div><p><a class="crosslink anchor" href="#sftp" id="sftp"></a></p></div><div class="section_3"><h4 id="sftp">sftp<a class="headerlink" href="#sftp">¶</a></h4><p>
Die andere Möglichkeit des Dateitransfers lautet <strong>sftp</strong>. Das funktioniert genau so wie der normale Kommandozeilen-FTP-Client:</p><div class="bash"><div class="contents"><pre class="notranslate">sftp server </pre></div></div><p>
</p><pre class="notranslate">Connecting to server...
user@server's password:
sftp&gt; pwd
Remote working directory: /export/home/user
sftp&gt; dir
[...]
wichtige_datei.txt
[...]
sftp&gt; get wichtige_datei.txt
Fetching /export/home/user/wichtige_datei.txt to wichtige_datei.txt
/export/home/user/wichtige_datei.txt                                                     100%   62KB  62.2KB/s   00:00
sftp&gt; quit</pre><p>
Mit dem Befehl <strong>help</strong> bekommt man eine Übersicht über die möglichen Kommandos.</p></div></div><div class="section_2"><h3 id="Entfernte-Dateisysteme-einbinden">Entfernte Dateisysteme einbinden<a class="headerlink" href="#Entfernte-Dateisysteme-einbinden">¶</a></h3><p>
Man kann das Dateisystem eines entfernten Rechners in sein eigenes Dateisystem mittels <a class="internal" href="./fuse/sshfs.html">sshfs</a> einbinden. Damit ist eine transparente Nutzung von Dateien auch über unsichere Netze hinweg möglich.</p></div><div class="section_2"><h3 id="Grafische-Programme-zum-Dateitransfer">Grafische Programme zum Dateitransfer<a class="headerlink" href="#Grafische-Programme-zum-Dateitransfer">¶</a></h3><p>
</p><div class="section_3"><h4 id="Gnome-Ubuntu">Gnome/Ubuntu<a class="headerlink" href="#Gnome-Ubuntu">¶</a></h4><p>
Der Gnome-Dateimanager <a class="internal" href="./nautilus.html">Nautilus</a> unterstützt das SSH-Protokoll von Haus aus. Dazu benutzt man eine Adresse der Form <code class="notranslate">ssh://rechnername/pfad</code>, um über SSH die Dateien auf dem angegebenen Rechner zu sehen. Wenn man sich als ein anderer Benutzer anmelden möchte, verwendet man stattdessen eine Adresse der Form <code class="notranslate">ssh://andererbenutzer@rechnername/pfad</code>. Alternativ können auch die Hosts aus der <code class="notranslate">~/.ssh/config</code> verwendet werden. Dort lassen sich auch noch andere SSH-Einstellung, wie. z.B SSH-Keys, definieren. Der Zugriff erfolgt mit <code class="notranslate">ssh://hostname</code>. Diese Adressen funktionieren übrigens auch in einigen anderen Gnome-Anwendungen.</p></div><div class="section_3"><h4 id="KDE-Kubuntu">KDE/Kubuntu<a class="headerlink" href="#KDE-Kubuntu">¶</a></h4><p>
Auch bei KDE ist SSH-Unterstützung eingebaut: Mit einer Adresse der Form <strong>fish://rechnername/pfad</strong> kann man auf die Dateien auf einem anderen Rechner zugreifen, und mit<strong> fish://andererbenutzer@rechnername/pfad</strong> meldet man sich als anderer Benutzer auf dem Zielrechner an. Dies funktioniert im <a class="internal" href="./konqueror.html">Konqueror</a> sowie in allen KDE-Anwendungen. Man kann also beispielsweise im Malprogramm <a class="internal" href="./kolourpaint.html">KolourPaint</a> via <em>Datei</em> -&gt; <em>Öffnen..</em> und dann oben in der Adresszeile eine <em>fish://</em>-Adresse eingeben, um direkt ein Bild auf einem anderen Rechner anzusehen oder zu bearbeiten. Im Dateimanager <a class="internal" href="./dolphin.html">Dolphin</a> (Kubuntu-Standard) können über das Bookmark "Netzwerk" und den Assistenten "Netzwerkordner hinzufügen" neue ssh-basierte Netzwerkordner als feste Bookmarks erstellt werden. Wenn der Zielrechner ebenfalls ein UTF-8 codiertes Dateisystem hat, sind u.U. die Umlaute falsch angezeigt. Um dies zu ändern, muss man im Konqueror eine fish-Adresse aufrufen und kann nun unter <em>"Extras -&gt; Entfernte Zeichencodierung wählen..."</em> die entsprechende Codierung einstellen. Diese Einstellung ist fortan auch in Dolphin gültig. Diese Option einzustellen wird in KDE4 vermutlich in Dolphin selbst möglich sein.</p></div><div class="section_3"><h4 id="Xfce-Xubuntu">Xfce/Xubuntu<a class="headerlink" href="#Xfce-Xubuntu">¶</a></h4><p>
Der Xfce-Dateimanager <a class="internal" href="./thunar.html">Thunar</a> unterstützt das SSH-Protokoll wie Nautilus unter GNOME. Siehe <a class="internal" href="./ssh.html#Gnome-Ubuntu">Gnome-Ubuntu</a>.</p></div><div class="section_3"><h4 id="Weitere-grafische-Programme">Weitere grafische Programme<a class="headerlink" href="#Weitere-grafische-Programme">¶</a></h4><p>
Die meisten grafischen FTP-Clients (<a class="internal" href="./ftp.html">FTP</a>) unterstützen auch sftp oder scp über das SSH-Protokoll. Beim Gnome FTP-Cient <a class="internal" href="./gftp.html">gFTP</a> etwa muss man unter <em>"FTP -&gt; Optionen -&gt; Netz -&gt; Voreingestelltes Protokoll"</em> in der Drop-Down-Liste <strong>SSH2</strong> an Stelle von <strong>FTP</strong> auswählen. Leider hat <strong>gftp</strong> Probleme, wenn man neben Passwörtern auch <em>Public-Keys</em> (siehe <a class="crosslink" href="#Authentifizierung-ueber-Public-Keys">Public-Key-Verfahren</a>) benutzt. Das funktioniert nur mit dem SSH-Agenten (ebenfalls weiter unten beschrieben) und der Einstellung "Benötige SSH Benutzername/Passwort nicht" in <em>"FTP -&gt; Optionen -&gt; SSH"</em>.</p><p>SSH-Verbindungen zu Datenverzeichnissen auf Fremdrechnern unterstützen auch Datensynchronisationsprogramme wie <a class="internal" href="./unison.html">Unison</a> und Backupprogramme wie Keep.</p><p><a class="crosslink anchor" href="#PubKeys" id="PubKeys"></a></p></div></div></div><div class="section_1"><h2 id="Authentifizierung-ueber-Public-Keys">Authentifizierung über Public-Keys<a class="headerlink" href="#Authentifizierung-ueber-Public-Keys">¶</a></h2><p>
Wem die Authentifizierung über Passwörter trotz der Verschlüsselung zu unsicher ist, - immerhin könnte das Passwort ja erraten werden - der benutzt am besten das Public-Key-Verfahren. Hierbei wird asymmetrische Verschlüsselung genutzt, um den Benutzer zu authentifizieren. Der (oder die) öffentliche(n) Schlüssel des Benutzers befindet sich dabei in der Datei <strong>~/.ssh/authorized_keys</strong> des Zielsystems, der private Schlüssel in einer Datei (meist <strong>id_rsa</strong>) im Verzeichnis <strong>~/.ssh</strong> auf dem lokalen System, wo er zusätzlich von einer "pass phrase" geschützt wird. Wenn man sich nun mit der Public-Key-Methode auf einem SSH-Server anmelden möchte, so schickt der Server dem Klienten eine zufällig generierte <em>Challenge</em>. Der Server verschlüsselt diesen Datenblock mit dem öffentlichen Schlüssel des Klienten und wenn der Klient diesen Chiffre mit dem zugehörigen privaten Schlüssel wieder entschlüsseln kann (wofür nötigenfalls die Passphrase abgefragt wird), ist die Identität des Benutzers bestätigt.</p><p>Damit man dieses Verfahren überhaupt verwenden kann, muss man sich zunächst mit Hilfe des Kommandozeilenprogramms <code class="notranslate">ssh-keygen</code> ein entsprechendes Schlüsselpaar erzeugen:</p><div class="bash"><div class="contents"><pre class="notranslate">ssh-keygen -t rsa -b 4096 </pre></div></div><p>
</p><pre class="notranslate">Generating public/private rsa key pair.
Enter file in which to save the key (/home/user/.ssh/id_rsa):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/user/.ssh/id_rsa.
Your public key has been saved in /home/user/.ssh/id_rsa.pub.
The key fingerprint is:
24:55:ee:67:83:72:82:55:5f:b9:b4:09:2a:fa:56:a1 user@client.local
The key's randomart image is:
+--[ RSA 4096]----+
|                 |
|                 |
|                 |
|         +    .  |
|        S    E   |
|         .  + +  |
|          .o . o.|
|         o.oo. oo|
|          ==o.BO+|
+-----------------+</pre><p>
Der voreingestellte Dateiname (<strong>id_rsa</strong>) kann einfach mit der Taste 
<span class="key">⏎</span>  bestätigt werden, außer man möchte sich ein weiteres Schlüsselpaar erzeugen. Von der Benutzung einer leeren Passphrase ist jedoch abzuraten, weil sonst jeder, der evtl. in den Besitz dieser Datei kommt, sofortigen Zugriff auf alle zugehörigen Systeme erhält.</p><p>Nun muss noch der öffentliche Schlüssel, zu erkennen an der Endung <em>.pub</em> (<strong>id_rsa.pub</strong>), auf dem Zielsystem deponiert werden. Dazu dient das Programm <strong>ssh-copy-id</strong>. Zu diesem Zeitpunkt muss die Authentifizierung per Passwort noch erlaubt sein (<strong>PasswordAuthentication yes</strong>):</p><div class="bash"><div class="contents"><pre class="notranslate">ssh-copy-id -i ~/.ssh/id_rsa.pub user@server </pre></div></div><p>
</p><pre class="notranslate">Password:
Now try logging into the machine, with "ssh 'user@server'", and check in:
  .ssh/authorized_keys
to make sure we haven't added extra keys that you weren't expecting.</pre><div class="box notice"><h3 class="box notice">Hinweis:</h3><div class="contents"><p>Sollte man - warum  auch immer - bei der Angabe des Dateinamens des Schlüssels die Endung <strong>.pub</strong> vergessen, so wird diese automatisch durch <code class="notranslate">ssh-copy-id</code> angehängt. Man kann also nie aus Versehen seinen privaten Schlüssel Namens <strong>id_rsa</strong> (also ohne Endung <strong>.pub</strong>) übertragen.
</p></div></div><div class="box experts"><h3 class="box experts">Experten-Info:</h3><div class="contents"><p>Wenn man die Sicherheit des Schlüssels weiter erhöhen möchte, benutzt man anstatt dem rsa Verschlüsselungsverfahren, die Eliptische Kurve ED25519.</p><p>Der Schlüssel wird durch diesen Befehl erstellt:
</p><div class="bash"><div class="contents"><pre class="notranslate">ssh-keygen -t ed25519 </pre></div></div><p>
und durch übertragen:
</p><div class="bash"><div class="contents"><pre class="notranslate">ssh-copy-id -i ~/.ssh/id_ed25519.pub user@server </pre></div></div><p>
</p></div></div><div class="box notice"><h3 class="box notice">Hinweis:</h3><div class="contents"><p>Wenn man mit dem aktuellen puttygen unter Windows die Schlüsseldateien erstellt hat kopiert man direkt aus puttygen den angezeigten Block in die authorized_keys hinein.</p><p>Die Datei muss folgendermaßen aussehen:
</p><pre class="notranslate">ssh-rsa   rsa-pub-key   Key Kommentar</pre><p>
</p></div></div><p>Sollte <strong>ssh-copy-id</strong> nicht funktionieren, kann man den öffentlichen Schlüssel auch anders auf das Zielsystem kopieren und in die Datei <strong>~/.ssh/authorized_keys</strong> einfügen. Dabei ist unbedingt darauf zu achten, dass die Datei mit der Endung <strong>.pub</strong> und nicht der private Schlüssel ohne diese Endung verwendet wird:</p><div class="bash"><div class="contents"><pre class="notranslate">cat id_rsa.pub | ssh server 'cat&gt;&gt; ~/.ssh/authorized_keys' </pre></div></div><p>
Wenn ein vom Standard abweichender Dateiname für den Key gewählt wurde, muss er mittels der Kommandozeilenoption <code class="notranslate">-i ~/pfad/dateiname</code> gesondert angegeben werden. Für die dauerhafte Nutzung empfiehlt sich ein Eintrag in der <a class="internal" href="./ssh.html#ssh-config">~/.ssh/config</a> mittels <code class="notranslate">IdentityFile</code>-Parameter.</p><p>Anschließend kann man sich ohne Passwort anmelden:</p><div class="bash"><div class="contents"><pre class="notranslate">ssh user@server </pre></div></div><p>
</p><pre class="notranslate">Enter passphrase for key '/home/user/.ssh/id_rsa':
Linux server.local 2.6.12-10-686 #1 Mon Feb 13 12:18:37 UTC 2006 i686 GNU/Linux
The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.
Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.
Last login: Fri Mar  3 03:51:14 2006</pre><p>
In einigen Fällen tritt ein Fehler beim ersten Anmeldeversuch auf:
</p><blockquote><p>"Agent admitted failure to sign using the key."</p></blockquote><p>
In diesem Fall einfach <strong>ssh-add</strong> ausführen.</p><div class="bash"><div class="contents"><pre class="notranslate">ssh-add </pre></div></div><pre class="notranslate">Identity added: /home/user/.ssh/id_rsa (/home/user/.ssh/id_rsa)</pre><div class="box notice"><h3 class="box notice">Hinweis:</h3><div class="contents"><p>Falls es noch nicht klappt kann es daran liegen, dass die Rechte beim Server nicht korrekt sind. sshd achtet darauf, dass das Homeverzeichnis, das dem Login-Namen entspricht (also die "Mappe" selbst), das <code class="notranslate">.ssh</code>-Verzeichnis und <code class="notranslate">authorized_keys</code> nur für den Eigentümer Schreibrechte hat. Hintergrund ist wohl, die Gefahr zu verringern, dass <code class="notranslate">authorized_keys</code> manipuliert wird und man keinen Zugriff mehr hat, wenn der Passwortzugang (s.u.) gesperrt ist.</p><p>Wer also bei bestimmten Konten auf dem Server auch einer Gruppe Schreibrechte gewähren will, muss evtl. die Optionen in <strong>/etc/ssh/sshd_config</strong> prüfen.
</p></div></div><p>Jetzt ist es aber immer noch möglich, sich mit dem Passwort anzumelden. Um dies zu unterbinden, sind in der Datei <strong>/etc/ssh/sshd_config</strong> die Optionen</p><pre class="notranslate">PasswordAuthentication no
UsePAM no</pre><p>zu setzen und mit einem</p><div class="bash"><div class="contents"><pre class="notranslate">sudo /etc/init.d/ssh reload </pre></div></div><p>
die Konfiguration neu einlesen lassen.</p><p>Alternativ: Auf der Serverseite eingeben <code class="notranslate">passwd -l &lt;user&gt;</code>. Damit sind Passwörter nur für ausgewählte Accounts sperrbar.</p><p><a class="crosslink anchor" href="#Verschluesseltes-Home-Verzeichnis" id="Verschluesseltes-Home-Verzeichnis"></a></p><div class="section_2"><h3 id="Verschluesseltes-Home-Verzeichnis">Verschlüsseltes Home-Verzeichnis<a class="headerlink" href="#Verschluesseltes-Home-Verzeichnis">¶</a></h3><p>
Man sollte darauf achten, dass bei verschlüsselten Home-Verzeichnissen (ecryptfs) auch die <code class="notranslate">authorized_keys</code> mit verschlüsselt ist und somit nicht zur Authentifizierung verwendet werden kann, solange das Home-Verzeichnis nicht entschlüsselt ist (durch parallele Anmeldung mit dem gleichen Benutzernamen).</p><p>Eine Abhilfe ist z.B. die <code class="notranslate">authorized_keys</code> in ein nicht-verschlüsseltes Verzeichnis zu legen (z.B. /etc/ssh/username/) und die Einstellung <em>AuthorizedKeysFile</em> in der <code class="notranslate">/etc/ssh/sshd_config</code> auf  <em>/etc/ssh/%u/authorized_keys</em> zu ändern (Root-Rechte und Neustart des SSH-Daemons erforderlich).</p><div class="bash"><div class="contents"><pre class="notranslate">sudo mkdir /etc/ssh/$USER
sudo mv $HOME/.ssh/authorized_keys /etc/ssh/$USER/
ln -s /etc/ssh/$USER/authorized_keys $HOME/.ssh/ </pre></div></div><p>Quelle: <a class="external" href="http://superuser.com/questions/61057/ssh-with-authorized-keys-to-an-ubuntu-system-with-encrypted-homedir" rel="nofollow">SSH with authorized_keys to an Ubuntu system with encrypted homedir?</a> <img alt="{en}" src="./_/d5ecf89114b079f85d02099649c4ee617ffa34c7.png"/></p><p><a class="crosslink anchor" href="#SSH-Agent" id="SSH-Agent"></a>
</p></div><div class="section_2"><h3 id="Der-SSH-Agent">Der SSH-Agent<a class="headerlink" href="#Der-SSH-Agent">¶</a></h3><p>
Unter grafischen Desktop-Sitzungen (Unity, Gnome, etc.) startet automatisch im Hintergrund der SSH-Agent. In diesem werden automatisch die privaten Schlüssel abgelegt, sodass nicht jedes Mal die "pass phrase" abgefragt wird. Dies verbindet die Bequemlichkeit der Bedienung mit der Sicherheit des Public-Key-Verfahrens.</p><p>Zur direkten Interaktion mit dem SSH-Agenten im Terminal dient das Programm <code class="notranslate">ssh-add</code>, wobei die Option <code class="notranslate">-l</code> die augenblicklich gespeicherten Schlüssel auflistet:</p><div class="bash"><div class="contents"><pre class="notranslate">ssh-add -l </pre></div></div><p>
</p><pre class="notranslate">The agent has no identities.</pre><div class="bash"><div class="contents"><pre class="notranslate">ssh-add </pre></div></div><p>
</p><pre class="notranslate">Enter passphrase for /home/user/.ssh/id_rsa:
Identity added: /home/user/.ssh/id_rsa (/home/user/.ssh/id_rsa)</pre><div class="bash"><div class="contents"><pre class="notranslate">ssh-add -l </pre></div></div><p>
</p><pre class="notranslate">1024 24:55:ee:67:83:72:82:55:5f:b9:b4:09:2a:fa:56:a1 /home/user/.ssh/id_rsa (RSA)</pre><div class="bash"><div class="contents"><pre class="notranslate">ssh server </pre></div></div><p>
</p><pre class="notranslate">Last login: Wed Mar  8 11:11:58 2006 from 192.168.4.56</pre><p>Wenn man nicht über Unity oder eine andere graphische Benutzeroberfläche, die unter dem ssh-agent läuft, eingeloggt ist, funktioniert das so leider nicht. Dann muss man vorher noch ein</p><div class="bash"><div class="contents"><pre class="notranslate">exec ssh-agent bash </pre></div></div><p>
ausführen, um eine Shell zu öffnen, die mit dem ssh-agent kommunizieren kann.</p><p>Arbeitet man oft im Terminal und möchte nicht immer wieder die "pass phrase" eingeben, kann man das folgende in seine <strong>.bashrc</strong> eintragen:</p><pre class="notranslate">if [ $SSH_AGENT_PID ]; then
    if [[ $(ssh-add -l) != *id_?sa* ]]; then
        ssh-add -t 2h  ## Haltbarkeit von 2 Std.
    fi
fi</pre><p>Man kann aber auch in seiner lokalen Konfiguration <strong>$HOME/.ssh/config</strong>
</p><pre class="notranslate">AddKeysToAgent yes</pre><p>
einfügen. Dann wird bei der ersten Ausführung von ssh der Schlüssel automatisch zum Agent hinzugefügt (ab openssh 7.2).</p></div><div class="section_2"><h3 id="Login-ueber-mehrere-Rechner">Login über mehrere Rechner<a class="headerlink" href="#Login-ueber-mehrere-Rechner">¶</a></h3><p>
Ab und zu muss man sich von Rechner zu Rechner hangeln, da kein direkter Zugriff besteht. Doch der Key wird nicht automatisch übertragen. Darum besteht die Möglichkeit dies direkt in der ~/.ssh/config zu vermerken.</p><pre class="notranslate">ForwardAgent yes</pre></div><div class="section_2"><h3 id="SSH-Askpass">SSH-Askpass<a class="headerlink" href="#SSH-Askpass">¶</a></h3><p>
Wenn eines der Pakete <strong>ssh-askpass</strong>, <strong>ssh-askpass-gnome</strong>, <strong>ssh-askpass-fullscreen</strong> oder <strong>gtk-led-askpass</strong> installiert ist, kann <code class="notranslate">ssh-add</code> die Passphrase in Ermangelung eines Terminals auch über ein Dialogfenster abfragen. Das nutzt man sinnvollerweise, um seinen Schlüssel gleich nach der Anmeldung auf einem grafischen System zu laden <sup><a href="#source-5">[5]</a></sup>. Für KDE-Nutzer gibt es das Paket <strong>ksshaskpass</strong>, das für ssh-add eine graphische Oberfläche zur Verfügung stellt.</p></div><div class="section_2"><h3 id="Single-Sign-On">Single-Sign-On<a class="headerlink" href="#Single-Sign-On">¶</a></h3><p>
Wem immer noch zu umständlich ist, beim Login nacheinander erst das Login-Passwort und dann die SSH-Passphrase einzugeben, der installiert sich stattdessen das Paket <strong>libpam-ssh</strong>. Mit den richtigen Einstellungen wird man beim Login nach der Eingabe des Benutzernamens nicht mehr nach dem Passwort, sondern nach der SSH-Passphrase gefragt und kann sich danach ohne nervige Passwortabfrage mittels SSH auf seinen Systemen bewegen. Nur wenn man die Passphrase nicht richtig eintippt, kann man sich stattdessen auch mit seinem normalen Passwort authentifizieren. Zu beachten ist allerdings, dass der <a class="internal" href="./gnome_schlüsselbund.html">GNOME-Schlüsselbund</a> dann nicht mehr automatisch freigeschaltet wird.</p><div class="box notice"><h3 class="box notice">Hinweis:</h3><div class="contents"><p>Macht man hier einen Fehler, kann man sich eventuell nicht mehr am System anmelden. Sollte das passiert sein, ist es normalerweise noch möglich, sich per SSH einzuloggen und den Fehler zu beheben. Wenn auch das nicht mehr hilft, muss man das System zum Reparieren im Single-User-<a class="interwiki interwiki-wikipedia" href="https://de.wikipedia.org/wiki/Runlevel">Runlevel</a> oder von einer Live-CD starten.
</p></div></div><p><a class="crosslink anchor" href="#X-Forwarding" id="X-Forwarding"></a>
</p></div></div><div class="section_1"><h2 id="X-Forwarding">X-Forwarding<a class="headerlink" href="#X-Forwarding">¶</a></h2><p>
<img alt="./screenshot_ssh_X-neu.png" class="image-right" src="./_/40c6b899e98c0e45c4974a79d6a9fad080662e79.png" title="Auf einem lokalen Ubuntu 12.04 LTS wird via X-Forwarding das Mailprogramm eines entfernten Kubuntu 12.10 - Rechners angezeigt."/> Mit dem <em>X11-Forwarding</em> kann man auch grafische Programme, die man über SSH auf einem anderen Rechner startet, auf dem eigenen Display anzeigen lassen, und zwar unabhängig davon, welches Betriebssystem auf dem entfernten Rechner läuft (siehe Bild.) Das Programm muss sich nur an den X11-Standard halten, was leider die meisten Windows- und Mac-Programme ausschließt.</p><p>Um das X11-Forwarding zu aktivieren, muss man dem <strong>ssh</strong>-Befehl die Option <code class="notranslate">-X</code> <strong>(großes X)</strong> hinzufügen, die dem Programm eingeschränkte Rechte am eigenen Display einräumt. Für den Fall, dass es zu einem Programmabbruch kommt, weil diese eingeschränkten Rechte nicht ausreichen, existiert noch die Option <code class="notranslate">-Y</code>, die dem Programm volle Rechte gewährt. Diese sollte man jedoch nicht verwenden, wenn man dem Administrator des entfernten Rechners nicht vertraut, denn sie öffnet einen Tunnel, der auch in der umgekehrten Richtung für einen Angriff auf das eigene Display genutzt werden könnte. Vorsicht: mit der Option <code class="notranslate">-x</code> <strong>(kleines x)</strong> wird X11-Forwarding deaktiviert.</p><p>Hinweis: bei Nutzung von VNC (z.B. für Fernwartung) muss auf dem Server X11VNC installiert sein.</p><p>Einen deutlichen Geschwindigkeitszuwachs erreicht man durch die Wahl einer anderen Verschlüsselung und der Aktivierung der Kompression der Daten für langsame Verbindungen (DSL, etc.) mit diesen zusätzlichen Optionen im Aufruf von ssh: <strong>-c arcfour,blowfish-cbc -XC</strong>. Beispiele:</p><ul><li><p>Öffnen des Programms <a class="internal" href="./leafpad.html">Leafpad</a>: </p><div class="bash"><div class="contents"><pre class="notranslate">ssh -X user@server leafpad &amp; </pre></div></div></li><li><p>Zur bequemeren Nutzung entfernter Programme können auch die Panel-Programme der jeweiligen Desktop-Umgebung gestartet werden, z.B. <a class="internal" href="./lxde_einstellungen.html#Panel">LXPanel</a>, <a class="internal" href="./xfce_panel.html">Xfce Panel</a> und andere: </p><div class="bash"><div class="contents"><pre class="notranslate">ssh -X user@server lxpanel &amp; </pre></div></div><p> Da Panel-Programme in der Regel nicht über eine Funktion "schließen" verfügen kann man diese z.B. mittels <a class="internal" href="./xkill.html">xkill</a> schließen.</p></li></ul><p>
</p><div class="section_2"><h3 id="Serverkonfiguration">Serverkonfiguration<a class="headerlink" href="#Serverkonfiguration">¶</a></h3><p>
</p><div class="box notice"><h3 class="box notice">Hinweis:</h3><div class="contents"><p>Dies sollte in der Regel nicht notwendig sein.
</p></div></div><p>Auf dem Server muss hierfür das Paket</p><ul><li><p><strong>xauth</strong> </p></li></ul><p>installiert werden, wenn es das noch nicht ist.</p><p>Außerdem muss dem SSH-Daemon des Servers mitgeteilt werden, dass X-Forwarding verwendet wird. Das wird über die Konfigurationsdatei <strong>/etc/ssh/sshd_config</strong> erledigt. Dort werden die Optionen:</p><pre class="notranslate">X11Forwarding yes
X11UseLocalhost no</pre><p>
gesetzt. Danach ist ein Neustart des Daemons erforderlich.</p><p>Zusätzlich müssen in der Client-Konfigurationsdatei  <strong>/etc/ssh/ssh_config</strong> die Einträge:</p><pre class="notranslate">ForwardX11 yes</pre><p>
und</p><pre class="notranslate">ForwardX11Trusted yes</pre><p>
durch Entfernen von <code class="notranslate">#</code> am Zeilenanfang einkommentiert werden.</p><p><a class="crosslink anchor" href="#SSH-Tunnel" id="SSH-Tunnel"></a></p></div></div><div class="section_1"><h2 id="SSH-Tunnel">SSH-Tunnel<a class="headerlink" href="#SSH-Tunnel">¶</a></h2><p>
Wenn man mit Hilfe von SSH so ein nicht ganz triviales Protokoll wie X-Window tunneln kann, dann muss das doch auch mit anderen Protokollen funktionieren, oder? - Aber sicher geht das. Allerdings ist die Syntax für den SSH-Tunnelbau ein wenig verwirrend:</p><div class="bash"><div class="contents"><pre class="notranslate">ssh -L [bind_address:]port:host:port user@server
ssh -R [bind_address:]port:host:port user@server </pre></div></div><p>
Hierbei richtet die Option <code class="notranslate">-L</code> laut Dokumentation eine <em>lokale</em>, und die Option '-R' eine <em>entfernte</em> (englisch <em>remote</em>) Port-Weiterleitung ein. Der verschlüsselte Tunnel wird dabei <strong>immer</strong> zwischen dem eigenen Rechner und <em>server</em> hergestellt. Die Verbindung vom <em>Ende des Tunnels</em> zu <em>host</em> läuft dagegen unverschlüsselt ab, und wird aus Sicht des betreffenden Systems angegeben, weswegen man <em>host</em> in den allermeisten Fällen wohl auf <em>"localhost"</em> setzen sollte. Hierbei darf <em>"localhost"</em> nicht mit dem lokalen Rechner verwechselt werden. Es handelt sich um <em>"localhost"</em> von <em>server</em> aus betrachtet, daher um den Server selbst.</p><p>Die Option <code class="notranslate">-L</code> bzw. <code class="notranslate">-R</code> gibt dabei die Richtung an, aus der der Tunnel benutzt werden kann. Bei <code class="notranslate">-L</code> vom eigenen Rechner zum entfernten hin, bei <code class="notranslate">-R</code> in der entgegengesetzten Richtung. (Das merkt man sich am Besten als norma<strong>L</strong> und <strong>R</strong>ückwärts.)</p><p>Das erste <em>port</em>-Argument bezeichnet dabei den Einstiegsport in die Verbindung. Zu beachten ist hierbei, dass die Öffnung eines <em>privilegierten</em> Ports, also unter 1024, nur dem Superuser <em>root</em> gestattet ist. Man sollte also auf die höheren Ports ausweichen.</p><p>Mit dem optionalen Parameter <em>bind_address</em> kann man festlegen, auf welchen Netzwerkschnittstellen die Weiterleitung laufen soll, wobei <em>localhost</em> der Standard ist. Ein <strong>*</strong> oder ein leeres <em>bind_address</em>-Argument vor dem Doppelpunkt bedeutet, dass die Weiterleitung an allen Schnittstellen läuft. Möglicherweise funktioniert das nicht auf jedem Ubuntu-System auf Anhieb, da die IPv6-Adresse das irgendwie verhindert, weshalb man den SSH-Tunnel mit dem Argument <strong>-4</strong> auf die IPv4-Schnittstellen beschränken muss.</p><p>Der zweite <em>port</em>-Parameter gibt schließlich an, auf welchen Port von <em>host</em> die Weiterleitung gehen soll.</p><p>Ein weiteres nützliches Argument ist die Option <code class="notranslate">-N</code>, die das Erzeugen einer Terminal-Sitzung auf dem entfernten System unterbindet, wenn man nur die Port-Weiterleitung benutzen möchte.</p><div class="section_2"><h3 id="Beispiele">Beispiele<a class="headerlink" href="#Beispiele">¶</a></h3><p>
Weiterleitung von Port 8000 auf dem lokalen System an den Webserver (Port 80) auf <em>server</em>:</p><div class="bash"><div class="contents"><pre class="notranslate">ssh -L 8000:localhost:80 server -N &amp;
netstat -anp --inet | egrep '(^Proto|8000)' </pre></div></div><p>
</p><pre class="notranslate">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 127.0.0.1:8000          0.0.0.0:*               LISTEN     10843/ssh</pre><div class="bash"><div class="contents"><pre class="notranslate">fg </pre></div></div><p>
</p><pre class="notranslate">ssh -L 8000:localhost:80 server -N
[Strg-C]
Killed by signal 2.</pre><p>
Dasselbe, aber es wird nicht nur vom lokalen Host weitergeleitet, sondern von allen Schnittstellen (hierzu ist die Option <code class="notranslate">GatewayPorts</code> in der Server-Konfiguration entsprechend zu setzen, genaueres zu finden in der Manpage; man wähle diese Option mit Bedacht!):</p><div class="bash"><div class="contents"><pre class="notranslate">ssh -L *:8000:localhost:80 server -N -4 &amp;
netstat -anp --inet | egrep '(^Proto|8000)' </pre></div></div><p>
</p><pre class="notranslate">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:8000            0.0.0.0:*               LISTEN     10906/ssh</pre><p>
Umgekehrte Richtung. Benutzern auf <em>server</em> wird ermöglicht, über <em>localhost:3306</em> auf den MySQL-Server auf <em>client</em> zuzugreifen:</p><div class="bash"><div class="contents"><pre class="notranslate">ssh -R 3306:localhost:3306 server </pre></div></div><p>
</p><pre class="notranslate">Last login: Sat Mar 11 23:24:20 2006 from 192.168.4.56
netstat -an --inet | egrep '(^Proto|3306)'
Proto Recv-Q Send-Q Local Address           Foreign Address         State
tcp        0      0 127.0.0.1:3306          0.0.0.0:*               LISTEN
exit
logout
Connection to server closed.</pre><p>
Zur Veranschaulichung folgt hier noch einmal eine grafische Darstellung dieser Beispiele:</p><p><img alt="./ssh-tunnel-improved.png" class="image-center" src="./_/9927a0eaeae1a2b0ebc5fa494ed013763b491978.png"/></p><p>Doppelter SSH-Tunnel über zwei Konsolen:</p><p><img alt="./doppelter_ssh_tunnel.png" class="image-center" src="./_/139ae7cd492f40c6e83ca93e34e7452eddbe047a.png"/></p><div class="bash"><div class="contents"><pre class="notranslate">supportpc$ ssh -L 54321:localhost:54321 zwischennutzer@zwischen
zwischen$ ssh -L 54321:localhost:8080 zielnutzer@ziel </pre></div></div><p>SSH-Tunnel über Zwischenrechner mit Zielrechner verbinden:</p><p><img alt="./ssh_tunnel_zu_ziel.png" class="image-center" src="./_/4fd07c5ee0429409c8053f34a8369ccb4c1cd571.png"/></p><div class="bash"><div class="contents"><pre class="notranslate">supportpc$ ssh -L 54322:ziel:22 zwischennutzer@zwischen </pre></div></div></div></div><div class="section_1"><h2 id="Weitere-Verschluesselungsdetails">Weitere Verschlüsselungsdetails<a class="headerlink" href="#Weitere-Verschluesselungsdetails">¶</a></h2><p>
</p><div class="section_2"><h3 id="Symmetrische-Verschluesselung">Symmetrische Verschlüsselung<a class="headerlink" href="#Symmetrische-Verschluesselung">¶</a></h3><p>
Wer als Laie an Verschlüsselung denkt, der denkt meist an die "symmetrische Verschlüsselung". Hierbei gibt es genau einen Schlüssel, mit dem ein Datensatz verschlüsselt wird. Nur wer diesen Schlüssel kennt (oder durch geschicktes Probieren herausfindet) kann die Verschlüsselung umkehren und den Klartext wieder extrahieren. Bekannte und bewährte Algorithmen wie TripleDES, AES und Twofish wurden so konzipiert, dass das Erraten des Schlüssels sehr aufwendig und damit teuer ist  – selbst wenn eine verschlüsselte Nachricht auch entschlüsselt vorliegt. Das größte Problem bei der Benutzung von <em>symmetrischer Verschlüsselung</em> ist daher, den Schlüssel sicher zum Kommunikationspartner zu befördern.</p></div><div class="section_2"><h3 id="Asymmetrische-Verschluesselung">Asymmetrische Verschlüsselung<a class="headerlink" href="#Asymmetrische-Verschluesselung">¶</a></h3><p>
Um dieses Problem der <em>symmetrischen Verschlüsselung</em> zu umgehen, gibt es andere Algorithmen, die das für eine erfolgreiche Ver- und Entschlüsselung nötige gemeinsame Geheimnis so verschleiern, dass man es öffentlich verteilen kann. Bei diesem Verfahren, <em>asymmetrische Verschlüsselung</em> genannt, wird nicht ein Schlüssel erzeugt, sondern ein Schlüsselpaar. Dieses hängt mathematisch voneinander ab, kann aber nur mit sehr viel Aufwand voneinander abgeleitet werden. Jeweils zwei zueinander passende Schlüssel wirken dabei genau entgegengesetzt: Was mit dem einen Schlüssel verschlüsselt wird, kann nur durch den anderen Schlüssel einfach wieder entschlüsselt werden. Der Sender und eventuelle Angreifer müssen dagegen für die Entschlüsselung aufwendige Rechnungen anstellen, die sehr viel Rechenzeit kosten würden. Dies ermöglicht es, einen der beiden Schlüssel öffentlich zur Verfügung zu stellen. Mit diesem kann man dann Sendungen verschlüsseln, die man aber <em>"einzig und allein"</em> mit dem anderen Schlüssel, den man niemals weitergibt, entschlüsseln kann.</p><p>Im Gegenzug kann man ein Datenpaket auch mit dem eigenen privaten Schlüssel chiffrieren. Wenn dieser Chiffretext sich dann mit dem öffentlichen Schlüssel wieder in Klartext zurückverwandeln lässt, weiß jeder, dass die Nachricht vom Besitzer des privaten Schlüssels kommt. Diese Anwendungsmöglichkeit nennt man <em>digitale Signatur</em>. Der Umgang mit asymmetrischen Verschlüsselungsalgorithmen wie RSA oder DSA erfordert signifikant mehr Rechenleistung als der mit symmetrischen. Daher ist es gängige Praxis, am Beginn der Kommunikation mit Hilfe des öffentlichen Schlüssels einen neu generierten, symmetrischen <em>Session-Schlüssel</em> auszutauschen und für den Rest der Kommunikation auf symmetrische Verschlüsselung umzusteigen.</p></div></div><div class="section_1"><h2 id="Problembehebung">Problembehebung<a class="headerlink" href="#Problembehebung">¶</a></h2><p>
<a class="crosslink anchor" href="#Offending-Keys" id="Offending-Keys"></a>
</p><div class="section_2"><h3 id="Offending-Keys">Offending Keys<a class="headerlink" href="#Offending-Keys">¶</a></h3><p>
Die Fehlermeldung </p><pre class="notranslate">Warning: the ECDSA host key for 'SERVER_IP' differs from the key for the IP address '123.123.123.123'
Offending key for IP in /home/BENUTZER/.ssh/known_hosts:<strong class="highlighted">3</strong>
Matching host key in /home/BENUTZER/.ssh/known_hosts:1
Are you sure you want to continue connecting (yes/no)? yes</pre><p>
durch eine geänderte IP kann man durch den Einzeiler
</p><pre class="notranslate">sed -i '<strong class="highlighted">3</strong>d' /home/BENUTZER/.ssh/known_hosts</pre><p> beheben. Dadurch wird der betroffene Eintrag entfernt.</p></div><div class="section_2"><h3 id="Unter-sftp-ist-Zugriff-auf-alles-ab-dem-Wurzelverzeichnis-moeglich">Unter sftp ist Zugriff auf alles ab dem Wurzelverzeichnis möglich<a class="headerlink" href="#Unter-sftp-ist-Zugriff-auf-alles-ab-dem-Wurzelverzeichnis-moeglich">¶</a></h3><p>
Bei der Nutzung von <code class="notranslate">sftp</code> erhält man Zugriff auf alles ab dem Wurzelverzeichnis (/). Dies sollte man aus Sicherheitsgründen einschränken.</p><div class="section_3"><h4 id="Vorbereitung">Vorbereitung<a class="headerlink" href="#Vorbereitung">¶</a></h4><p>
Zuerst legt man eine Gruppe an, die später alle Benutzer beherbergen soll, denen nur der Dateitransfer per <code class="notranslate">sftp</code> erlaubt wird:</p><div class="bash"><div class="contents"><pre class="notranslate">sudo addgroup exchangefiles </pre></div></div><p>Dann werden ein root-Verzeichnis <strong>/home/exchangefiles</strong>, in dem der Benutzer eingesperrt wird, und ein Depot-Verzeichnis <strong>/home/exchangefiles/files</strong> angelegt:</p><div class="bash"><div class="contents"><pre class="notranslate">sudo mkdir -p /home/exchangefiles/files
sudo chmod 755 /home/exchangefiles/
sudo chgrp -R exchangefiles /home/exchangefiles/
sudo chmod 1777 /home/exchangefiles/files/ </pre></div></div><p>Wichtig: Die Verzeichnisberechtigung auf dem Root-Verzeichnis darf maximal 755 betragen. Ist die Berechtigung zu hoch (z. B. 777), lässt <code class="notranslate">ssh</code> keine Client-Verbindungen herstellen: meist treten dann am Client Fehler wie "Konnte SFTP-Sitzung nicht initialisieren!" oder "Unable to startup channel" auf.</p><p>Anschließend fügt man einen Benutzer hinzu:</p><div class="bash"><div class="contents"><pre class="notranslate">sudo useradd -g exchangefiles -s /bin/false -d /home/exchangefiles hugo </pre></div></div><p>Der Benutzer <code class="notranslate">hugo</code> erhält hierbei keinen Shell-Zugang (<strong>/bin/false</strong>).</p><p>Dem Benutzer vergibt man im Anschluss noch ein Passwort:
</p><div class="bash"><div class="contents"><pre class="notranslate">sudo passwd hugo </pre></div></div></div><div class="section_3"><h4 id="sshd-Konfiguration">sshd Konfiguration<a class="headerlink" href="#sshd-Konfiguration">¶</a></h4><p>
Danach muss man die Konfiguration vom openssh-server wie folgt anpassen:
</p><div class="bash"><div class="contents"><pre class="notranslate">sudo vi /etc/ssh/sshd_config </pre></div></div><p>Den bereits vorhandenen Eintrag:
</p><pre class="notranslate">Subsystem sftp /usr/lib/openssh/sftp-server</pre><p>ändert man wie folgt ab:
</p><pre class="notranslate">Subsystem sftp internal-sftp</pre><p>Und ganz am Ende der Datei <strong>/etc/ssh/sshd_config</strong> fügt man eine Sektion <code class="notranslate">Match Group exchangefiles</code> hinzu. Die darauf folgenden Regeln gelten für alle Benutzer der Gruppe <strong>exchangefiles</strong>. Statt <code class="notranslate">Group</code> kann man auch <code class="notranslate">User</code> für einen einzelnen Benutzer verwenden.</p><p>So sehen dann die Veränderungen/Ergänzungen der Datei <strong>/etc/ssh/sshd_config</strong> aus:
</p><div class="code"><table class="notranslate syntaxtable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="notranslate syntax"><pre><span></span>###Subsystem sftp /usr/lib/openssh/sftp-server
# Enable to built-in implementation of SFTP
Subsystem sftp internal-sftp

# This section must be placed at the very end of sshd_config
Match Group exchangefiles
  # Force the connection to use the built-in SFTP support
  ForceCommand internal-sftp
  # Chroot the connection into the home directory of the user being authenticated
  ChrootDirectory %h
  # Disable network tunneling
  PermitTunnel no
  # Disable authentication agent forwarding
  AllowAgentForwarding no
  # Disable TCP connection forwarding
  AllowTcpForwarding no
  # Disable X11 remote desktop forwarding
  X11Forwarding no
</pre></div>
</td></tr></table></div><p>Eine Beschreibung der einzelnen Begriffen kann man der <code class="notranslate">man sshd_config</code> entnehmen.</p><p>Damit die Änderungen übernommen werden, muss der Dienst neu gestartet werden:
</p><div class="bash"><div class="contents"><pre class="notranslate">sudo service ssh restart </pre></div></div><p>Hier im Beispiel hat der Benutzer mit dem Namen hugo nur noch einen SFTP-Zugriff auf alle Dateien und Verzeichnisse (Dateirechte beachten), die unter dem Verzeichnis <strong>/home/exchangefiles</strong> liegen - eine lokale Anmeldung ist verboten (<strong>/bin/false</strong>).</p><p>Will man auf den SFTP/SSH-Server über das Internet zugreifen, so muss man im Router eine entsprechende <a class="internal" href="./portweiterleitung.html">Portweiterleitung</a> einrichten, sonst kommt keine Verbindung zustande. Dabei kann man nach außen einen anderen Port als Standard (22) verwenden (z.B. 2017), ein geänderter Port kann Angriffe erschweren.</p></div><div class="section_3"><h4 id="Test">Test<a class="headerlink" href="#Test">¶</a></h4><p>
Auf dem SSH-Client:</p><div class="bash"><div class="contents"><pre class="notranslate">sftp -P 2017 hugo@server.example.com
ssh -p 2017 hugo@server.example.com </pre></div></div><p>Mit dem <code class="notranslate">sftp</code> soll eine Verbindung zustande kommen, aber <code class="notranslate">ssh</code> soll eine Fehlermeldung zurückbringen:</p><pre class="notranslate">Could not chdir to home directory /home/exchangefiles: No such file or directory
This service allows sftp connections only.
Connection to server.example.com closed.</pre><p>Ist man verbunden, soll man in der Lage sein die Dateien unter <strong>/home/exchangefiles/files</strong> auflisten, hochladen, runterladen und löschen.</p></div></div></div><div class="section_1"><h2 id="Links">Links<a class="headerlink" href="#Links">¶</a></h2><p>
</p><div class="section_2"><h3 id="Intern">Intern<a class="headerlink" href="#Intern">¶</a></h3><p>
</p><ul><li><p><a class="internal" href="./mosh.html">Mosh</a> - auf SSH aufsetzende Lösung für den Fernzugriff auf andere Rechner</p></li><li><p><a class="internal" href="./fail2ban.html">fail2ban</a> - unerlaubte Zugriffe via SSH blockieren</p></li><li><p><a class="internal" href="./portweiterleitung.html">Portweiterleitung</a> - DSL-Router für SSH freischalten</p></li></ul><p>
</p></div><div class="section_2"><h3 id="Extern">Extern<a class="headerlink" href="#Extern">¶</a></h3><p>
</p><ul><li><p><a class="external" href="http://www.ietf.org/rfc/rfc4251.txt" rel="nofollow">The Secure Shell (SSH) Protocol Architecture</a> <img alt="{en}" src="./_/d5ecf89114b079f85d02099649c4ee617ffa34c7.png"/></p></li><li><p><a class="interwiki interwiki-youtube" href="https://www.youtube.com/watch?v=Hxsl-jj2Bq0">Video</a> vom Vortrag Ubuntu im sicheren Netz - Ubucon 2011 <img alt="{de}" src="./_/ffd333e1d59794eac31aea8b3e984e1b88473c33.png"/></p></li><li><p><a class="interwiki interwiki-youtube" href="https://www.youtube.com/watch?v=V-fhXawtQXQ?t=12m32s">Tunneling 101 – von überall ins Netz (SSH, Tinc, Socks, Krypto)</a> <img alt="{de}" src="./_/ffd333e1d59794eac31aea8b3e984e1b88473c33.png"/> - Vortrag Ubucon Berlin, 2015</p></li><li><p><a class="external" href="http://thepcspy.com/read/making-ssh-secure/" rel="nofollow">Putting the Secure in SSH</a> <img alt="{en}" src="./_/d5ecf89114b079f85d02099649c4ee617ffa34c7.png"/> - Tipps und Tricks für sicheres SSH. Blogbeitrag, 11/2014</p></li><li><p><a class="external" href="http://www.harding.motd.ca/autossh/" rel="nofollow">autossh</a> <img alt="{en}" src="./_/d5ecf89114b079f85d02099649c4ee617ffa34c7.png"/> - Monitor für SSH-Verbindungen mit Reconnect-Möglichkeit (in den Paketquellen enthalten)</p></li><li><p><a class="external" href="http://www.codejungle.org/site/SSH+Reverse+Tunnel+oder+wie+mache+ich+ein+Loch+in+die+Firewall.html" rel="nofollow">SSH Reverse Tunnel oder wie mache ich ein Loch in die Firewall</a> <img alt="{de}" src="./_/ffd333e1d59794eac31aea8b3e984e1b88473c33.png"/> - Reverse SSH (keine Portweiterleitung nötig). Blogbeitrag 07/2009</p></li><li><p><a class="external" href="http://ctaas.de/linux-install.htm#OpenSSH-Server_SFTP-Server_Secure_Shell" rel="nofollow">SFTP-Server Tutorial</a> <img alt="{de}" src="./_/ffd333e1d59794eac31aea8b3e984e1b88473c33.png"/> - Grundkonfiguration, Brute-Force-Angriffe erschweren, User in Verzeichnisse einsperren, Public-Key-Authentifizierung (Zugriff über Zertifikate) sowie einige Client Zugriffsmöglichkeiten</p></li></ul><p>
</p></div></div></div>
<p class="meta">
<a href="./ssh/a/revision/946336.html">Diese Revision</a> wurde am 14. Januar 2018 17:47 von <a href="https://ubuntuusers.de/user/ubot/">ubot</a> erstellt.
    
  </p>
</div>
</div>
<div style="clear: both;"></div>
<div class="pathbar breadcrumb">
<div class="breadcrumb">
<ol>
<li><a href="./startseite.html">Wiki</a></li>
<li><a href="./ssh.html">SSH</a></li>
</ol>
</div>
</div>
</div>
<div class="footer" style="clear: both;">
<ul>
<li class="poweredby"><li class="poweredby">Erstellt mit <a href="http://inyokaproject.org/">Inyoka</a></li></li>
<li class="license">

<img alt="Copyleft" src="./_/65dad5b770326dbbe1bd26ee6363e366a76bd8b7.png"/>
          2004 – 2017 ubuntuusers.de • Einige Rechte vorbehalten<br/>
<a href="./_lizenz.html" rel="cc:morePermissions">Lizenz</a> •
          <a href="http://ubuntuusers.de/kontakt/">Kontakt</a> •
          <a href="http://ubuntuusers.de/datenschutz/">Datenschutz</a> •
          <a href="http://ubuntuusers.de/impressum/">Impressum</a> •
          <a href="https://ubuntuusers.statuspage.io">Serverstatus</a>
</li>
<li class="housing">
<span title="Unterbringung und Netzanbindung eines Servers">Serverhousing</span> gespendet von<br/>
<img alt="noris network" src="./_/e7d27e9081eec23a8a5a5fe9434d7b2f1532e1d9.png"/>
<img alt="anexia" src="./_/ad1b63a3fc35749344af0a03e8c3ce05a2a3ee7e.png"/>
</li>
</ul>
</div>
<div style="clear: both;"></div>
</div>






</body>
</html>